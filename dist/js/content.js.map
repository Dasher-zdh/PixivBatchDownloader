{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/ts/content.ts","webpack:///./src/ts/modules/API.ts","webpack:///./src/ts/modules/BlackandWhiteImage.ts","webpack:///./src/ts/modules/BookmarkAfterDL.ts","webpack:///./src/ts/modules/BookmarkAllWorks.ts","webpack:///./src/ts/modules/BookmarksAddTag.ts","webpack:///./src/ts/modules/CenterPanel.ts","webpack:///./src/ts/modules/CheckNew.ts","webpack:///./src/ts/modules/Colors.ts","webpack:///./src/ts/modules/Config.ts","webpack:///./src/ts/modules/DOM.ts","webpack:///./src/ts/modules/DateFormat.ts","webpack:///./src/ts/modules/Deduplication.ts","webpack:///./src/ts/modules/DeleteWorks.ts","webpack:///./src/ts/modules/Download.ts","webpack:///./src/ts/modules/DownloadButton.ts","webpack:///./src/ts/modules/DownloadControl.ts","webpack:///./src/ts/modules/DownloadStates.ts","webpack:///./src/ts/modules/EVT.ts","webpack:///./src/ts/modules/ExportCSV.ts","webpack:///./src/ts/modules/ExportLST.ts","webpack:///./src/ts/modules/ExportResult.ts","webpack:///./src/ts/modules/FastScreen.ts","webpack:///./src/ts/modules/FileName.ts","webpack:///./src/ts/modules/Filter.ts","webpack:///./src/ts/modules/ImageToIcon.ts","webpack:///./src/ts/modules/ImgViewer.ts","webpack:///./src/ts/modules/IndexedDB.ts","webpack:///./src/ts/modules/InitBookmarkLegacyPage.ts","webpack:///./src/ts/modules/InitBookmarkPage.ts","webpack:///./src/ts/modules/InitFollowingPage.ts","webpack:///./src/ts/modules/InitIndexPage.ts","webpack:///./src/ts/modules/InitPage.ts","webpack:///./src/ts/modules/InitPageBase.ts","webpack:///./src/ts/modules/InitPixivisionPage.ts","webpack:///./src/ts/modules/InitUserPage.ts","webpack:///./src/ts/modules/Lang.ts","webpack:///./src/ts/modules/ListenPageSwitch.ts","webpack:///./src/ts/modules/Log.ts","webpack:///./src/ts/modules/MsgBox.ts","webpack:///./src/ts/modules/PageType.ts","webpack:///./src/ts/modules/ProgressBar.ts","webpack:///./src/ts/modules/QuickBookmark.ts","webpack:///./src/ts/modules/QuickDownloadBtn.ts","webpack:///./src/ts/modules/Resume.ts","webpack:///./src/ts/modules/SaveAvatarIcon.ts","webpack:///./src/ts/modules/ShowConvertCount.ts","webpack:///./src/ts/modules/ShowSkipCount.ts","webpack:///./src/ts/modules/ShowWhatIsNew.ts","webpack:///./src/ts/modules/States.ts","webpack:///./src/ts/modules/Store.ts","webpack:///./src/ts/modules/Theme.ts","webpack:///./src/ts/modules/Tip.ts","webpack:///./src/ts/modules/TitleBar.ts","webpack:///./src/ts/modules/Token.ts","webpack:///./src/ts/modules/artwork/InitAreaRankingPage.ts","webpack:///./src/ts/modules/artwork/InitArtworkPage.ts","webpack:///./src/ts/modules/artwork/InitBookmarkDetailPage.ts","webpack:///./src/ts/modules/artwork/InitBookmarkNewArtworkPage.ts","webpack:///./src/ts/modules/artwork/InitDiscoverPage.ts","webpack:///./src/ts/modules/artwork/InitNewArtworkPage.ts","webpack:///./src/ts/modules/artwork/InitRankingArtworkPage.ts","webpack:///./src/ts/modules/artwork/InitSearchArtworkPage.ts","webpack:///./src/ts/modules/artwork/InitSeriesPage.ts","webpack:///./src/ts/modules/artwork/SaveArtworkData.ts","webpack:///./src/ts/modules/langText.ts","webpack:///./src/ts/modules/novel/InitBookmarkNewNovelPage.ts","webpack:///./src/ts/modules/novel/InitNewNovelPage.ts","webpack:///./src/ts/modules/novel/InitNovelPage.ts","webpack:///./src/ts/modules/novel/InitNovelSeriesPage.ts","webpack:///./src/ts/modules/novel/InitRankingNovelPage.ts","webpack:///./src/ts/modules/novel/InitSearchNovelPage.ts","webpack:///./src/ts/modules/novel/MakeEPUB.ts","webpack:///./src/ts/modules/novel/MakeNovelFile.ts","webpack:///./src/ts/modules/novel/SaveNovelData.ts","webpack:///./src/ts/modules/output/OutputPanel.ts","webpack:///./src/ts/modules/output/PreviewFileName.ts","webpack:///./src/ts/modules/output/ShowURLs.ts","webpack:///./src/ts/modules/setting/Form.ts","webpack:///./src/ts/modules/setting/FormHTML.ts","webpack:///./src/ts/modules/setting/FormSettings.ts","webpack:///./src/ts/modules/setting/Options.ts","webpack:///./src/ts/modules/setting/SaveNamingRule.ts","webpack:///./src/ts/modules/setting/SettingAPI.ts","webpack:///./src/ts/modules/setting/Settings.ts","webpack:///./src/ts/modules/ugoira/ConvertUgoira.ts","webpack:///./src/ts/modules/ugoira/ExtractImage.ts","webpack:///./src/ts/modules/ugoira/ToAPNG.ts","webpack:///./src/ts/modules/ugoira/ToGIF.ts","webpack:///./src/ts/modules/ugoira/ToWebM.ts"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,2BAA2B;AAC3B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoC;AACR;AACM;AACH;AACS;AACZ;AACO;AACC;AACb;AACK;AACU;AACI;AACP;AACT;AACE;AACK;AACJ;AACG;AACH;;;;;;;;;;;;;ACnC7B;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mCAAmC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,uDAAuD,GAAG,GAAG,KAAK,iBAAiB,IAAI,UAAU,OAAO,kBAAkB,uBAAuB,OAAO,cAAc;AACtK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,KAAK;AACxD;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,uDAAuD,GAAG,oBAAoB,OAAO,SAAS,MAAM,QAAQ,KAAK,OAAO,IAAI,QAAQ,KAAK;AACzI;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,GAAG;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,GAAG;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,GAAG,GAAG,KAAK,WAAW,IAAI,UAAU,OAAO,SAAS,MAAM;AACjH;AACA;AACA;AACA;AACA,yDAAyD,GAAG;AAC5D;AACA;AACA;AACA;AACA,yDAAyD,GAAG;AAC5D;AACA;AACA;AACA;AACA,wDAAwD,GAAG;AAC3D;AACA;AACA;AACA;AACA;AACA,yDAAyD,GAAG;AAC5D;AACA;AACA;AACA;AACA;AACA,4DAA4D,YAAY,KAAK,SAAS;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,GAAG,uBAAuB,OAAO;AACxG;AACA;AACA;AACA,oEAAoE;AACpE;AACA,uDAAuD,KAAK,GAAG,yBAAyB,QAAQ,yBAAyB,KAAK,EAAE;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA,8DAA8D,yBAAyB,QAAQ,yBAAyB,KAAK,EAAE;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,cAAc,SAAS,aAAa,QAAQ,YAAY,OAAO,WAAW;AAC5I;AACA;AACA;AACA;AACA,iEAAiE,cAAc,SAAS,aAAa,OAAO,WAAW;AACvH;AACA;AACA;AACA;AACA;AACA,2CAA2C,KAAK,SAAS,EAAE;AAC3D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,MAAM;AACjD;AACA;AACA;AACA;AACA,uEAAuE,UAAU,SAAS,MAAM,cAAc,WAAW,YAAY,SAAS;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,UAAU,KAAK,OAAO;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,KAAK;AACjE;AACA;AACA;AACA,kDAAkD;AAClD;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;;;;;;;;;;;;;AClaf;AAAA;AAAA;AAA4B;AAC5B;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wCAAG;AAC3B;AACA;AACA;AACA,8DAA8D,IAAI;AAClE,iBAAiB;AACjB;AACA;AACA,wBAAwB,wCAAG;AAC3B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,4CAA4C;AAC5C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AAC8B;;;;;;;;;;;;;ACxF9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACI;AACA;AACc;AAChB;AACF;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oCAAoC,0CAAI,gBAAgB,GAAG,kBAAkB,GAAG,qBAAqB;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4CAAK,yBAAyB,4CAAK,cAAc,4CAAK;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,GAAG;AACvD;AACA,kBAAkB,wCAAG,oEAAoE,0DAAQ,oCAAoC,0DAAQ,mBAAmB,4CAAK;AACrK;AACA;AACA;AACA,mCAAmC,aAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AAC2B;;;;;;;;;;;;;AC3F3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACI;AACF;AACgB;AAClB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG;AACf,qBAAqB,0CAAI;AACzB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,yBAAyB,KAAK,mBAAmB;AACxG;AACA;AACA,iCAAiC,wCAAG;AACpC;AACA;AACA,iCAAiC,wCAAG;AACpC;AACA,mDAAmD;AACnD,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,MAAM,KAAK,yBAAyB;AAC/F,sBAAsB,wCAAG,iCAAiC,0DAAQ,oCAAoC,0DAAQ,mBAAmB,4CAAK;AACtI;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AAC4B;;;;;;;;;;;;;AC7G5B;AAAA;AAAA;AAAA;AAAA;AAA4B;AACA;AACI;AAChC;AACA;AACA;AACA,8BAA8B;AAC9B,6BAA6B;AAC7B,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,YAAY,wCAAG,iBAAiB,wCAAG;AACnC,YAAY,wCAAG,iBAAiB,wCAAG;AACnC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,4CAAK;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wCAAG;AACjB;AACA;AACA,sCAAsC,MAAM,KAAK,eAAe;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2B;;;;;;;;;;;;;ACtF3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8B;AACF;AACA;AACM;AACF;AAChC;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,0CAAI,mBAAmB;AACtF;AACA;AACA,wDAAwD,0CAAI,mBAAmB;AAC/E;AACA;AACA,iEAAiE,0CAAI,iBAAiB;AACtF;AACA;AACA,6EAA6E,0CAAI,sBAAsB;AACvG;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mEAAmE,0CAAI,iBAAiB;AACxF,0FAA0F,0CAAI,iBAAiB;AAC/G,yGAAyG,0CAAI,6BAA6B;AAC1I;AACA;AACA;AACA;AACA,gCAAgC,0CAAI,iBAAiB;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0CAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY,wCAAG,MAAM,wCAAG;AACxB,SAAS;AACT;AACA,gCAAgC,wCAAG;AACnC,YAAY,wCAAG,MAAM,wCAAG;AACxB,SAAS;AACT;AACA,0BAA0B,wCAAG,mBAAmB,wCAAG;AACnD;AACA,qBAAqB,8CAAM;AAC3B;AACA;AACA,aAAa;AACb;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,6CAA6C,wCAAG;AAChD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG,MAAM,wCAAG;AACxB;AACA;AACA,YAAY,wCAAG,MAAM,wCAAG;AACxB;AACA;AACA;AACA;;;;;;;;;;;;;ACzIA;AAAA;AAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG,MAAM,wCAAG;AACxB;AACA;AACA;AACA;;;;;;;;;;;;;ACjCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkB;;;;;;;;;;;;;ACTlB;AAAA;AACe;AACf;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACLF;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,KAAK;AACnE;AACA,6CAA6C,KAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,IAAI;AAC/D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACe;;;;;;;;;;;;;AC3Mf;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsB;;;;;;;;;;;;;ACxEtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACA;AACA;AACE;AACF;AACkB;AACN;AACR;AACM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,6BAA6B;AAC7B,gCAAgC;AAChC,uBAAuB,oDAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,gBAAgB;AAC9E,mDAAmD,eAAe;AAClE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT,SAAS,wCAAG,mBAAmB,wCAAG;AAClC;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oBAAoB,wCAAG,MAAM,wCAAG;AAChC,iBAAiB;AACjB;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oBAAoB,wCAAG,MAAM,wCAAG;AAChC,iBAAiB;AACjB;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oBAAoB,wCAAG,MAAM,wCAAG;AAChC,iBAAiB;AACjB;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAAQ;AAC3B;AACA,6BAA6B,4CAAK;AAClC;AACA,uBAAuB,kDAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG;AACX,iBAAiB,0CAAI;AACrB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2BAA2B;AACjE;AACA,QAAQ,wCAAG,6BAA6B,wCAAG,+CAA+C;AAC1F;AACA;AACA;AACA,8BAA8B,wCAAG;AACjC,mBAAmB,wCAAG;AACtB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wCAAG;AACtB;AACA;AACA,aAAa;AACb;AACA;AACA,QAAQ,wCAAG,SAAS,0CAAI;AACxB;AACA;AACA;AACA;AACA,YAAY,wCAAG,QAAQ,OAAO,GAAG,MAAM;AACvC;AACA,gBAAgB,wCAAG,SAAS,0CAAI;AAChC;AACA;AACA,SAAS;AACT;AACA,2BAA2B,mCAAmC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG;AACX,oBAAoB,0CAAI,mBAAmB,MAAM,0CAAI,eAAe;AACpE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,sCAAsC,2BAA2B;AACjE;AACA,QAAQ,wCAAG,kCAAkC,OAAO;AACpD;AACA;AACA;AACyB;;;;;;;;;;;;;AC5QzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC4B;AACE;AACI;AACN;AACM;AACN;AAC5B;AACA;AACA,gCAAgC;AAChC,mCAAmC;AACnC,iCAAiC;AACjC,6BAA6B;AAC7B,yCAAyC,GAAG;AAC5C;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oDAAoD,EAAE;AACtD;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,MAAM,0CAAI;AAChD,sBAAsB,0CAAI;AAC1B;AACA,gBAAgB,8CAAM;AACtB,gBAAgB,wCAAG;AACnB,yBAAyB,0CAAI;AAC7B;AACA,iBAAiB;AACjB;AACA;AACA,YAAY,wCAAG,MAAM,wCAAG;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA,kDAAkD,EAAE;AACpD;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,MAAM,0CAAI;AAChD,sBAAsB,0CAAI;AAC1B;AACA,gBAAgB,8CAAM;AACtB,gBAAgB,wCAAG;AACnB,yBAAyB,0CAAI;AAC7B;AACA,iBAAiB;AACjB;AACA;AACA,YAAY,wCAAG,MAAM,wCAAG;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA,2CAA2C,EAAE;AAC7C;AACA,uBAAuB,wCAAG,qBAAqB,8CAAM,MAAM,0CAAI,+BAA+B,0CAAI;AAClG;AACA;AACA;AACA;AACA,qCAAqC,0CAAI;AACzC;AACA,oBAAoB,wCAAG,MAAM,wCAAG;AAChC,iBAAiB;AACjB;AACA;AACA,qCAAqC,0CAAI;AACzC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8CAAM;AAC9B,wBAAwB,wCAAG;AAC3B,iCAAiC,0CAAI;AACrC;AACA,yBAAyB;AACzB;AACA;AACA;AACA,oBAAoB,wCAAG;AACvB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,wCAAG,SAAS,0CAAI,iBAAiB,wCAAG;AAC5C;AACA;AACuB;;;;;;;;;;;;;AC7HvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC4B;AACA;AACE;AACF;AACU;AACa;AACP;AACV;AACc;AACF;AAC9C;AACA;AACA;AACA;AACA,uBAAuB;AACvB,4BAA4B;AAC5B,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,wCAAG,oBAAoB,wCAAG;AACnC;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,QAAQ,wDAAW;AACnB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,wCAAG;AACX,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA;AACA;AACA,gCAAgC,4DAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE,0CAAI;AACnB;AACA;AACA,wBAAwB,kDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8CAAM,QAAQ,oBAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,EAAE,0CAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,0BAA0B,0CAAI;AAC9B;AACA;AACA;AACA,0BAA0B,0CAAI;AAC9B;AACA;AACA;AACA;AACA,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAW;AAC3B;AACA;AACA;AACA;AACA;AACA,yCAAyC,+DAAS;AAClD;AACA;AACA,yCAAyC,+DAAS;AAClD;AACA;AACA,yCAAyC,+DAAS;AAClD;AACA;AACA;AACA,gEAAgE,eAAe;AAC/E;AACA;AACA;AACA;AACA,wBAAwB,wCAAG,MAAM,wCAAG;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8CAAM;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,EAAE,0CAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wCAAG;AACrC,qCAAqC,8CAAM;AAC3C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,EAAE,0CAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoB;;;;;;;;;;;;;ACpOpB;AAAA;AAAA;AAA4B;AACE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0CAAI;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG,MAAM,wCAAG;AACxB,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC4B;AACA;AACI;AACJ;AACE;AACI;AACY;AACR;AACM;AACM;AACF;AACM;AACF;AAClB;AACA;AACJ;AAC9B;AACA;AACA,wBAAwB;AACxB;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,8BAA8B;AAC9B,4BAA4B;AAC5B;AACA;AACA;AACA,0BAA0B;AAC1B,2BAA2B;AAC3B;AACA;AACA;AACA,YAAY,6DAAa;AACzB;AACA,YAAY,mEAAgB;AAC5B;AACA;AACA;AACA,gBAAgB,iEAAe;AAC/B;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT;AACA,YAAY,wCAAG;AACf,YAAY,wCAAG;AACf,YAAY,wCAAG;AACf;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAG,UAAU,YAAY,yBAAyB,QAAQ;AAC1E,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAG,OAAO,0CAAI;AAC9B;AACA,SAAS;AACT;AACA;AACA;AACA,UAAU,0CAAI,+DAA+D;;AAE7E;AACA,oEAAoE,8CAAM,OAAO,KAAK,0CAAI,kBAAkB;AAC5G,oEAAoE,8CAAM,SAAS,KAAK,0CAAI,kBAAkB;AAC9G,mEAAmE,8CAAM,MAAM,KAAK,0CAAI,kBAAkB;AAC1G,8DAA8D,8CAAM,QAAQ,KAAK,0CAAI,kBAAkB;AACvG;AACA;AACA,YAAY,0CAAI,iBAAiB;AACjC,gCAAgC,0CAAI,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA,uBAAuB,wCAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,YAAY,wCAAG,MAAM,wCAAG;AACxB,SAAS;AACT;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA,YAAY,4CAAK;AACjB,mBAAmB,wDAAW;AAC9B;AACA;AACA,yCAAyC,4CAAK;AAC9C;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA;AACA,YAAY,0DAAQ,kBAAkB,+CAAM;AAC5C;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAAM;AAClC;AACA;AACA,YAAY,8DAAc;AAC1B;AACA;AACA;AACA;AACA,YAAY,8DAAc;AAC1B;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA,8BAA8B,0CAAI;AAClC,QAAQ,wCAAG,SAAS,0CAAI;AACxB;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB;AACA,sCAAsC,0CAAI;AAC1C,gBAAgB,wCAAG,SAAS,0CAAI;AAChC,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA;AACA,8BAA8B,0CAAI;AAClC,QAAQ,wCAAG,OAAO,0CAAI;AACtB;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAc;AACtB;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4CAAK;AACnC;AACA;AACA;AACA;AACA;AACA,oDAAoD,4CAAK;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0DAAQ;AAC3C;AACA,wBAAwB,gDAAM;AAC9B;AACA;AACA,0BAA0B,gDAAM;AAChC;AACA;AACA,oCAAoC;AACpC;AACA;AACA,YAAY,4CAAK;AACjB,0BAA0B,4CAAK;AAC/B;AACA;AACA,QAAQ,wDAAW;AACnB;AACA;AACA;AACA,sBAAsB,8DAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4CAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAQ;AACxB;AACA;AACA;AACA,0BAA0B,8DAAc;AACxC,wBAAwB,gBAAgB,KAAK,4CAAK,eAAe;AACjE,QAAQ,wCAAG;AACX;AACA,QAAQ,wDAAW;AACnB;AACA,kCAAkC,0CAAI;AACtC;AACA;AACA,gCAAgC,4CAAK;AACrC;AACA;AACA,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B,aAAa;AACb;AACA,kCAAkC,0CAAI,kBAAkB,8CAAM;AAC9D,YAAY,wCAAG,SAAS,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,4CAAK;AAC/D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,mCAAmC,8CAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtWA;AAAA;AAAA;AAAA;AAA4B;AACI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wCAAG,mBAAmB,wCAAG;AAC9C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gCAAgC,4CAAK;AACrC;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0B;;;;;;;;;;;;;ACnE1B;AAAA;AAAA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,qBAAqB,aAAa;AAClC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;;;;;;;;;;;;;ACrHf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACA;AACA;AACE;AACA;AACE;AACM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAM;AACjC,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB,YAAY,wCAAG;AACf,qBAAqB,0CAAI;AACzB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAK;AACzB;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wCAAG;AACtB;AACA;AACA,QAAQ,wCAAG,mBAAmB,wCAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvNA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACA;AACI;AACM;AACtC;AACA;AACA;AACA,6BAA6B;AAC7B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY,4CAAK;AACjB,YAAY,wCAAG;AACf;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,2BAA2B,4CAAK;AAChC,uDAAuD,kDAAQ;AAC/D;AACA;AACA;AACA;AACA,qBAAqB,wCAAG;AACxB,QAAQ,wCAAG;AACX;AACA;AACA;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACA;AACA;AACI;AAChC;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA,mCAAmC,4CAAK;AACxC,sCAAsC,2BAA2B;AACjE;AACA,QAAQ,wCAAG,6BAA6B,wCAAG,kBAAkB,wCAAG,aAAa,GAAG,4CAAK,6BAA6B;AAClH;AACA;AACA;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACA;AACA;AACI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,4CAAK;AACb;AACA;AACA;AACA;AACA;AACA,uBAAuB,wCAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG;AACX;AACA;AACsB;;;;;;;;;;;;;AClEtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACkB;AACd;AACF;AACI;AACQ;AAC1C;AACA;AACA,mBAAmB;AACnB;AACA;AACA,kBAAkB;AAClB,qBAAqB,0DAAQ,kBAAkB,GAAG;AAClD;AACA;AACA,cAAc,QAAQ;AACtB,uBAAuB,4CAAK;AAC5B;AACA;AACA,aAAa;AACb,cAAc,MAAM;AACpB,uBAAuB,4CAAK;AAC5B;AACA;AACA,aAAa;AACb,cAAc,GAAG;AACjB;AACA;AACA;AACA,aAAa;AACb,cAAc,OAAO;AACrB;AACA;AACA;AACA,aAAa;AACb,cAAc,MAAM;AACpB;AACA;AACA;AACA,aAAa;AACb,cAAc,KAAK;AACnB;AACA;AACA;AACA,aAAa;AACb,cAAc,MAAM;AACpB;AACA;AACA;AACA,aAAa;AACb,cAAc,KAAK;AACnB;AACA;AACA;AACA,aAAa;AACb,cAAc,OAAO;AACrB;AACA;AACA;AACA,aAAa;AACb,cAAc,QAAQ;AACtB;AACA;AACA;AACA,aAAa;AACb,cAAc,GAAG;AACjB;AACA,0CAA0C,GAAG;AAC7C;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb,cAAc,KAAK;AACnB;AACA;AACA;AACA,aAAa;AACb,cAAc,eAAe;AAC7B;AACA;AACA;AACA,aAAa;AACb,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA,aAAa;AACb,cAAc,IAAI;AAClB;AACA;AACA;AACA,aAAa;AACb,cAAc,KAAK;AACnB,uBAAuB,sDAAU,mBAAmB,0DAAQ;AAC5D;AACA;AACA,aAAa;AACb,cAAc,UAAU;AACxB,uBAAuB,sDAAU,QAAQ,4CAAK,oBAAoB,0DAAQ;AAC1E;AACA;AACA,aAAa;AACb,cAAc,KAAK;AACnB,uBAAuB,+CAAM;AAC7B;AACA;AACA,aAAa;AACb,cAAc,aAAa;AAC3B;AACA;AACA;AACA,aAAa;AACb,cAAc,aAAa;AAC3B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB,wCAAG;AACpB;AACA;AACA;AACA,iCAAiC,MAAM,kBAAkB,0DAAQ;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,MAAM;AACpC;AACA,8BAA8B,GAAG,wBAAwB,OAAO;AAChE;AACA;AACA;AACA;AACA,2BAA2B,wCAAG;AAC9B;AACA;AACA,oBAAoB,0DAAQ;AAC5B;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA,8DAA8D,IAAI;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAM;AAClB,YAAY,4CAAK;AACjB,aAAa,0DAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAQ;AACxB;AACA;AACA;AACA,qBAAqB,0DAAQ;AAC7B;AACA;AACA,uCAAuC,GAAG;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0DAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAQ;AACpB,wCAAwC,0DAAQ;AAChD;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoB;;;;;;;;;;;;;AClOpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8B;AACF;AACA;AACA;AACM;AACY;AACY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,4CAA4C;AAC5C,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAM;AAClB,wBAAwB,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAQ;AACrB,aAAa,0DAAQ;AACrB,aAAa,0DAAQ;AACrB,aAAa,0DAAQ;AACrB,4BAA4B,0CAAI;AAChC;AACA;AACA,sBAAsB,0DAAQ,kBAAkB,0CAAI;AACpD,sBAAsB,0DAAQ,kBAAkB,0CAAI;AACpD,sBAAsB,0DAAQ,kBAAkB,0CAAI;AACpD,sBAAsB,0DAAQ,kBAAkB,0CAAI;AACpD;AACA,wBAAwB,0CAAI;AAC5B;AACA;AACA;AACA;AACA,sBAAsB,0DAAQ,sBAAsB,0CAAI;AACxD,sBAAsB,0DAAQ,qBAAqB,0CAAI;AACvD;AACA,wBAAwB,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAQ,kBAAkB,0DAAQ;AAC/C,4BAA4B,0CAAI;AAChC;AACA;AACA,sBAAsB,0DAAQ,qBAAqB,0CAAI;AACvD,sBAAsB,0DAAQ,0BAA0B,0CAAI;AAC5D;AACA,wBAAwB,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAQ;AACrB;AACA;AACA,0CAA0C,0DAAQ;AAClD;AACA,wBAAwB,0CAAI;AAC5B;AACA;AACA;AACA;AACA,aAAa,0DAAQ;AACrB;AACA;AACA,6CAA6C,0DAAQ;AACrD;AACA,wBAAwB,0CAAI;AAC5B;AACA;AACA;AACA;AACA,aAAa,0DAAQ;AACrB;AACA;AACA,sBAAsB,wCAAG,qBAAqB,0DAAQ;AACtD,uBAAuB,wCAAG,qBAAqB,0DAAQ;AACvD;AACA;AACA;AACA,0BAA0B,0DAAQ;AAClC,8BAA8B,0CAAI;AAClC,8BAA8B,0CAAI;AAClC,4BAA4B,0CAAI,eAAe,GAAG,0DAAQ,kBAAkB,GAAG,eAAe,GAAG,MAAM,GAAG,0CAAI,eAAe,GAAG,0DAAQ,kBAAkB,GAAG,gBAAgB;AAC7K;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAQ;AACrB;AACA;AACA;AACA;AACA,oBAAoB,wCAAG,qBAAqB,0DAAQ;AACpD,oBAAoB,wCAAG,qBAAqB,0DAAQ;AACpD;AACA;AACA,wBAAwB,0CAAI;AAC5B;AACA;AACA;AACA,wBAAwB,0CAAI;AAC5B;AACA;AACA;AACA;AACA,YAAY,0DAAQ;AACpB,wBAAwB,0CAAI;AAC5B;AACA;AACA;AACA;AACA,aAAa,0DAAQ;AACrB;AACA;AACA,qBAAqB,0DAAQ;AAC7B;AACA,wBAAwB,0CAAI,wBAAwB,0CAAI;AACxD;AACA;AACA,wBAAwB,0CAAI,wBAAwB,0CAAI;AACxD;AACA;AACA;AACA,uCAAuC,0DAAQ;AAC/C;AACA,4BAA4B,0CAAI;AAChC;AACA;AACA;AACA,4BAA4B,0CAAI,oBAAoB,0DAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAQ;AACrB;AACA;AACA,uBAAuB,0DAAQ;AAC/B;AACA,8BAA8B,0DAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0DAAQ,cAAc;AACtD;AACA;AACA,gCAAgC,0DAAQ,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAQ;AACrB,YAAY,0DAAQ;AACpB,YAAY,0DAAQ;AACpB;AACA;AACA;AACA,uCAAuC,0DAAQ;AAC/C,qCAAqC,0DAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0CAAI,iBAAiB,IAAI,0DAAQ,eAAe,KAAK,0DAAQ,aAAa;AACrG;AACA;AACA;AACA;AACA,YAAY,0DAAQ;AACpB,iCAAiC,0DAAQ;AACzC;AACA,iCAAiC,0DAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,IAAI,QAAQ,IAAI;AACjD;AACA;AACA;AACA,aAAa,0DAAQ;AACrB;AACA;AACA;AACA,qBAAqB,0DAAQ;AAC7B;AACA;AACA;AACA,SAAS;AACT;AACA,wBAAwB,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAAQ;AAC3B;AACA;AACA,mBAAmB,0DAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAQ,iBAAiB,0DAAQ;AACzD;AACA;AACA;AACA,6BAA6B,sEAAkB;AAC/C,2BAA2B,0DAAQ;AACnC,wBAAwB,0DAAQ;AAChC;AACA;AACA;AACA,kCAAkC,0DAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,0DAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAQ;AACpB;AACA,gBAAgB,0DAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAQ;AACzB;AACA,gBAAgB,0DAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAQ;AACpB;AACA;AACA,iBAAiB,0DAAQ;AACzB;AACA;AACA;AACA,gDAAgD,0DAAQ;AACxD;AACA;AACA;AACA;AACA,iCAAiC,0DAAQ;AACzC;AACA;AACA;AACA,+BAA+B,0DAAQ;AACvC,YAAY,0DAAQ;AACpB;AACA;AACA;AACA,iBAAiB,0DAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8CAAM;AACnB;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG;AACX;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB,QAAQ,wCAAG;AACX,QAAQ,wCAAG;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,0BAA0B,wCAAG,qBAAqB,wCAAG;AACrD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACkB;;;;;;;;;;;;;AC9lBlB;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,gCAAgC;AAChC,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,kCAAkC;AAClC,6BAA6B;AAC7B,6BAA6B;AAC7B,oCAAoC;AACpC,qCAAqC;AACrC,sDAAsD;AACtD,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACmB;;;;;;;;;;;;;ACxMnB;AAAA;AAAA;AAAA;AAAA;AACA;AAC4B;AACI;AAChC;AACA;AACA,2DAA2D;AAC3D,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8CAA8C;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,2BAA2B,wCAAG,gBAAgB,wCAAG;AACjD;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA,mCAAmC,wBAAwB;AAC3D,iDAAiD,iCAAiC,cAAc,oCAAoC;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,0CAA0C,IAAI,MAAM,IAAI;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqB;;;;;;;;;;;;;AC9PrB;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,UAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACqB;;;;;;;;;;;;;AChPrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC8C;AAClB;AACM;AACF;AACF;AACc;AACQ;AACpB;AACJ;AACA;AAC5B,qCAAqC,0DAAY;AACjD;AACA;AACA,yBAAyB;AACzB,8BAA8B;AAC9B,4BAA4B;AAC5B,+BAA+B;AAC/B,+BAA+B;AAC/B,wBAAwB;AACxB,sCAAsC;AACtC;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI,mBAAmB,0CAAI;AACjD;AACA;AACA,SAAS;AACT;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI;AAC1B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY,4CAAK;AACjB,wBAAwB,wCAAG,qBAAqB,8CAAM,QAAQ,0CAAI,sCAAsC,0CAAI;AAC5G,gBAAgB,gEAAe;AAC/B;AACA;AACA;AACA;AACA,QAAQ,wDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,qBAAqB,0CAAI;AACzB,SAAS;AACT;AACA,QAAQ,wDAAO;AACf;AACA;AACA;AACA;AACA,sBAAsB,0CAAI;AAC1B;AACA;AACA,sBAAsB,0CAAI;AAC1B;AACA,mDAAmD,0CAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wCAAG,uCAAuC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wCAAG;AACzB,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA,YAAY,wCAAG,KAAK,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAG,iBAAiB,wCAAG,yBAAyB,4CAAK;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK,UAAU,4CAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,wCAAG,eAAe,wCAAG;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAK;AACrB;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,kCAAkC,4CAAK;AACvC;AACA;AACkC;;;;;;;;;;;;;ACnLlC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC8C;AAClB;AACM;AACJ;AACc;AACZ;AACJ;AACA;AAC5B,+BAA+B,0DAAY;AAC3C;AACA;AACA,yBAAyB;AACzB,8BAA8B;AAC9B,4BAA4B;AAC5B,+BAA+B;AAC/B,+BAA+B;AAC/B,wBAAwB;AACxB;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI,mBAAmB,0CAAI;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,wDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,qBAAqB,0CAAI;AACzB,SAAS;AACT;AACA,QAAQ,wDAAO;AACf;AACA;AACA,mDAAmD,0CAAI,uBAAuB,0CAAI;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wCAAG,uCAAuC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wCAAG;AACzB,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA,YAAY,wCAAG,KAAK,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAG,iBAAiB,wCAAG,yBAAyB,4CAAK;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK,UAAU,4CAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;;;;;;;;;;;;;ACtH5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC8C;AACZ;AACJ;AACc;AAChB;AACI;AACJ;AACA;AACA;AAC5B,gCAAgC,0DAAY;AAC5C;AACA;AACA,4BAA4B;AAC5B,6BAA6B;AAC7B,+BAA+B;AAC/B,yBAAyB;AACzB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI,mBAAmB,0CAAI;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,wDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,qBAAqB,0CAAI;AACzB,SAAS;AACT;AACA;AACA,mDAAmD,0CAAI,uBAAuB,0CAAI;AAClF;AACA;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA;AACA;AACA,wBAAwB,wCAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wCAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAG;AAC9B;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK,UAAU,4CAAK;AAC5B;AACA;AACA;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI,mBAAmB,4CAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK,aAAa,wCAAG;AAC7B;AACA;AAC6B;;;;;;;;;;;;;AC5I7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC8C;AACZ;AACJ;AACc;AAChB;AACI;AACJ;AACA;AAC5B,4BAA4B,0DAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACrE;AACA;AACA;AACA;AACA;AACA,qDAAqD,0CAAI;AACzD,QAAQ,wCAAG;AACX,QAAQ,wCAAG,qBAAqB,8CAAM,QAAQ,0CAAI;AAClD,YAAY,wCAAG,MAAM,wCAAG;AACxB,SAAS;AACT;AACA;AACA,QAAQ,wDAAO;AACf;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oBAAoB,wCAAG,MAAM,wCAAG;AAChC,iBAAiB;AACjB,gDAAgD,0CAAI;AACpD;AACA;AACA;AACA,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B,gDAAgD,0CAAI;AACpD;AACA,SAAS;AACT;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wCAAG,OAAO,0CAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,QAAQ,wCAAG;AACX,QAAQ,wCAAG;AACX,QAAQ,wCAAG;AACX;AACA;AACyB;;;;;;;;;;;;;AC/FzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC4B;AACU;AACU;AACY;AACd;AACoB;AACZ;AACkB;AACJ;AACM;AAChB;AACgB;AACQ;AACpB;AACI;AACZ;AACY;AACA;AACE;AACQ;AAChB;AACF;AACF;AACxD;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,gBAAgB,kDAAQ;AACxB;AACA,2BAA2B,4DAAa;AACxC;AACA,2BAA2B,wEAAe;AAC1C;AACA,2BAA2B,0DAAY;AACvC;AACA,2BAA2B,8EAAsB;AACjD;AACA,2BAA2B,kEAAgB;AAC3C;AACA,2BAA2B,oFAAqB;AAChD;AACA,2BAA2B,gFAAmB;AAC9C;AACA,2BAA2B,sFAAsB;AACjD;AACA,2BAA2B,uEAAkB;AAC7C;AACA,2BAA2B,uFAAsB;AACjD;AACA,2BAA2B,+FAA0B;AACrD;AACA,2BAA2B,2EAAgB;AAC3C;AACA,2BAA2B,+EAAkB;AAC7C;AACA,2BAA2B,mEAAa;AACxC;AACA,2BAA2B,+EAAmB;AAC9C;AACA,2BAA2B,+EAAmB;AAC9C;AACA,2BAA2B,iFAAoB;AAC/C;AACA,2BAA2B,yFAAwB;AACnD;AACA,2BAA2B,yEAAgB;AAC3C;AACA,2BAA2B,uEAAc;AACzC;AACA,2BAA2B,qEAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC8B;AACI;AACN;AACA;AACI;AACJ;AACA;AACgB;AACE;AACI;AAChB;AAC0B;AACN;AACtD;AACA;AACA,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;AAC7B,kCAAkC;AAClC,qCAAqC;AACrC,mDAAmD;AACnD,qCAAqC;AACrC;AACA;AACA;AACA,QAAQ,wDAAO;AACf;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,wDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,qBAAqB,0CAAI;AACzB,SAAS;AACT;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI,mBAAmB,0CAAI;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,QAAQ,wCAAG;AACX,QAAQ,wCAAG;AACX;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB,oBAAoB,0CAAI;AACxB,QAAQ,wCAAG;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,8BAA8B,0DAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG,iCAAiC;AAChD;AACA;AACA,YAAY,wCAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wCAAG,qBAAqB,0DAAQ;AACvD;AACA;AACA;AACA,gBAAgB,wCAAG,SAAS,0CAAI;AAChC;AACA;AACA,gBAAgB,wCAAG,SAAS,0CAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,YAAY,0DAAQ;AACpB,YAAY,wCAAG,SAAS,0CAAI,wBAAwB,8DAAU;AAC9D;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAM;AAClB,YAAY,wCAAG;AACf,qBAAqB,0CAAI;AACzB;AACA,aAAa;AACb;AACA;AACA,QAAQ,wCAAG;AACX,QAAQ,wCAAG,SAAS,0CAAI;AACxB;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB,YAAY,+CAAM;AAClB;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI,mBAAmB,4CAAK;AAC5C;AACA;AACA,YAAY,4CAAK;AACjB,+BAA+B,4CAAK;AACpC;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA,2BAA2B,4CAAK;AAChC;AACA;AACA;AACA,YAAY,wCAAG;AACf;AACA;AACA,aAAa;AACb;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,mCAAmC,wCAAG;AACtC,sBAAsB,mEAAa;AACnC;AACA;AACA,mCAAmC,wCAAG;AACtC,sBAAsB,yEAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA,QAAQ,4CAAK;AACb;AACA,QAAQ,wCAAG,KAAK,0CAAI,qBAAqB,4CAAK;AAC9C,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAG,mBAAmB,0CAAI;AAC1C;AACA;AACA,gBAAgB,wCAAG,mBAAmB,0CAAI;AAC1C;AACA;AACA,gBAAgB,wCAAG,mBAAmB,0CAAI;AAC1C;AACA;AACA,gBAAgB,wCAAG,mBAAmB,0CAAI;AAC1C;AACA;AACA,gBAAgB,wCAAG,OAAO,0CAAI;AAC9B;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI,qBAAqB,4CAAK;AAC9C;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB,QAAQ,wCAAG,MAAM,wCAAG;AACpB,oBAAoB,0CAAI;AACxB,QAAQ,wCAAG;AACX,QAAQ,wCAAG;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACwB;;;;;;;;;;;;;ACtRxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC8C;AACZ;AACJ;AACF;AACgB;AACZ;AAChC,iCAAiC,0DAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACrD;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,wDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ,EAAE,GAAG;AACnD;AACA;AACA;AACA;AACA,iBAAiB;AACjB,4BAA4B;AAC5B;AACA;AACA,QAAQ,4CAAK;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,cAAc,wCAAG;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AAC8B;;;;;;;;;;;;;ACtI9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC8C;AACZ;AACJ;AACc;AAChB;AACI;AACJ;AACA;AACA;AACM;AACR;AAC4B;AACtD,2BAA2B,0DAAY;AACvC;AACA;AACA,0BAA0B;AAC1B,6BAA6B;AAC7B,+BAA+B,mEAAgB;AAC/C;AACA,gBAAgB,8CAAM;AACtB;AACA;AACA,mCAAmC,4CAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,gBAAgB,4CAAK,aAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI,mBAAmB,0CAAI;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,QAAQ,0CAAI;AAClD,sBAAsB,0CAAI;AAC1B;AACA,YAAY,wCAAG,MAAM,wCAAG;AACxB,SAAS;AACT;AACA,+BAA+B,wCAAG,qBAAqB,8CAAM,QAAQ,0CAAI;AACzE,+BAA+B,mEAAgB;AAC/C;AACA;AACA;AACA,YAAY,wCAAG,MAAM,wCAAG;AACxB,YAAY,4CAAK,OAAO,wCAAG;AAC3B,iCAAiC;AACjC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA;AACA;AACA,QAAQ,wDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,qBAAqB,0CAAI;AACzB,SAAS;AACT;AACA;AACA,mDAAmD,0CAAI,uBAAuB,0CAAI;AAClF;AACA;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,QAAQ,4CAAK;AACb;AACA;AACA,wBAAwB,wCAAG,uCAAuC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAG,oBAAoB,wCAAG;AACrD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oBAAoB,wCAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK,UAAU,4CAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAG,2BAA2B,wCAAG,oBAAoB,4CAAK;AACnF;AACA;AACA;AACA,2CAA2C,4CAAK;AAChD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAK;AACrB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK,aAAa,wCAAG;AAC7B;AACA;AACA,QAAQ,wCAAG;AACX,QAAQ,wCAAG;AACX,mCAAmC,wCAAG;AACtC;AACA;AACwB;;;;;;;;;;;;;AC/OxB;AAAA;AAAA;AAAA;AAAA;AAAsC;AACV;AACkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA;AACA,gBAAgB,wCAAG;AACnB;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA,qCAAqC,0DAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAsB,kDAAQ;AAC9B,2DAA2D;AAC3D;AACA;AACA;AACA;AACgB;;;;;;;;;;;;;ACpDhB;AAAA;AAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B,aAAa;AACb,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACA;AACM;AACF;AACE;AAClC;AACA;AACA;AACA,qDAAqD;AACrD,4BAA4B;AAC5B,sDAAsD;AACtD;AACA,8BAA8B;AAC9B;AACA;AACA,gCAAgC,wCAAG;AACnC,iBAAiB,8CAAM;AACvB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG;AACf,YAAY,4CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8CAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACe;;;;;;;;;;;;;ACxFf;AAAA;AAAA;AAAA;AAAA;AAA8B;AACF;AACI;AACE;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8CAAM,YAAY;AAC3D;AACA;AACA,2BAA2B,iBAAiB;AAC5C,6BAA6B,WAAW,GAAG,SAAS;AACpD,4CAA4C,YAAY,0CAAI,eAAe;AAC3E;AACA,QAAQ,4CAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,oCAAoC,wCAAG;AACvC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClDA;AAAA;AAAA;AAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,KAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG,MAAM,wCAAG;AACxB;AACA;AACA,YAAY,wCAAG,MAAM,wCAAG;AACxB;AACA;AACA;AACA;AACoB;;;;;;;;;;;;;AClGpB;AAAA;AAAA;AAAA;AAAA;AAAA;AACgC;AACJ;AACE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0CAAI,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wCAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4CAAK;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4CAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mCAAmC,GAAG,kCAAkC;AAC9F;AACA;AACA;AACA,sBAAsB,kCAAkC,GAAG,iCAAiC;AAC5F;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuB;;;;;;;;;;;;;AC5GvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC4B;AACE;AACE;AACc;AAC9C;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,aAAa,4CAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yBAAyB,wCAAG,cAAc,wCAAG;AAC7C;AACA;AACA,yBAAyB,wCAAG,gBAAgB,wCAAG;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wCAAG,gBAAgB,wCAAG;AAC5D;AACA,YAAY,wCAAG,mBAAmB,4CAAK;AACvC;AACA,qDAAqD,kBAAkB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAG,6BAA6B,0DAAQ,mBAAmB,4CAAK;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0DAA0D,wCAAG,cAAc;AAC3E;AACA;AACA,uEAAuE,wCAAG,eAAe;AACzF;AACA;AACA;AACyB;;;;;;;;;;;;;AC1JzB;AAAA;AAAA;AAAA;AAAA;AAA4B;AACE;AACI;AAClC;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0CAAI;AAC3C;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAM;AAClB,YAAY,wCAAG,MAAM,wCAAG;AACxB,SAAS;AACT;AACA;AACA;AACA,gBAAgB,8CAAM;AACtB,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B;AACA,SAAS;AACT;AACA;AACA,YAAY,wCAAG;AACf,YAAY,wCAAG;AACf,YAAY,wCAAG;AACf,YAAY,wCAAG;AACf;AACA;AACA;AACA,gBAAgB,8CAAM;AACtB,aAAa;AACb;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;;;;;;;;;;;;;AC1D5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACA;AACE;AACE;AACE;AACgB;AACV;AACxC;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC,uCAAuC;AACvC,uBAAuB;AACvB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,mCAAmC;AACnC,uBAAuB,oDAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,mDAAmD,eAAe;AAClE,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA,iBAAiB;AACjB,mDAAmD,eAAe;AAClE;AACA;AACA;AACA;AACA,iBAAiB;AACjB,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY,8CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,SAAS,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA;AACA,oBAAoB,4CAAK;AACzB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY,8DAAc;AAC1B;AACA,QAAQ,4CAAK;AACb;AACA;AACA,QAAQ,wCAAG,SAAS,0CAAI;AACxB;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA;AACA,qBAAqB,wCAAG,mBAAmB,wCAAG;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8DAAc,uBAAuB,4CAAK;AAC9D;AACA;AACA,gBAAgB,wCAAG,SAAS,0CAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4CAAK;AAC/B;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAc;AAC1C;AACA;AACA,gBAAgB,wCAAG,SAAS,0CAAI;AAChC,aAAa;AACb;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA,6BAA6B,wCAAG,wBAAwB,wCAAG;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAc;AAC1C;AACA;AACA;AACA,oBAAoB,8DAAc,uBAAuB,4CAAK;AAC9D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4CAAK;AACzC;AACA;AACA;AACA;AACA,sBAAsB,4CAAK;AAC3B;AACA;AACA;AACA;AACA,iDAAiD;AACjD,6BAA6B;AAC7B;AACA,2CAA2C,4CAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wCAAG;AAC3B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG;AACX,iBAAiB,0CAAI;AACrB;AACA,SAAS;AACT;AACA;AACA;AACkB;;;;;;;;;;;;;AC9TlB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8B;AACF;AACA;AACA;AACA;AACY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA,uBAAuB,wCAAG;AAC1B,kCAAkC,wCAAG;AACrC,iDAAiD;AACjD,uDAAuD;AACvD;AACA;AACA,2BAA2B,oDAAO;AAClC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B,sBAAsB,GAAG,OAAO;AAC5D,QAAQ,wCAAG;AACX,QAAQ,wCAAG,gBAAgB,0CAAI;AAC/B,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AAA4B;AACE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA;AACA,8BAA8B,0CAAI;AAClC;AACA;AACA,SAAS;AACT;AACA;AAC4B;;;;;;;;;;;;;ACnB5B;AAAA;AAAA;AAAA;AAA4B;AACE;AAC9B;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA;AACA;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8BAA8B,0CAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACyB;;;;;;;;;;;;;ACvCzB;AAAA;AAAA;AAA8B;AACF;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG;AACf,oDAAoD,0CAAI,iBAAiB;AACzE,qBAAqB,0CAAI;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG;AACf,YAAY,wCAAG;AACf,YAAY,wCAAG;AACf,YAAY,wCAAG;AACf,YAAY,wCAAG;AACf;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,YAAY,wCAAG;AACf,YAAY,wCAAG;AACf,YAAY,wCAAG;AACf;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACkB;;;;;;;;;;;;;ACzDlB;AAAA;AAAA;AAAA;AAAA;AAA4B;AACA;AACA;AAC5B;AACA;AACA;AACA,yBAAyB;AACzB,6BAA6B;AAC7B;AACA,+BAA+B;AAC/B;AACA,yBAAyB;AACzB,2BAA2B;AAC3B,sBAAsB;AACtB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA,6CAA6C,EAAE;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wCAAG;AACtB,qBAAqB,wCAAG;AACxB;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC,uBAAuB,wCAAG;AAC1B,yBAAyB,wCAAG;AAC5B,SAAS;AACT;AACA;AACA;AACiB;;;;;;;;;;;;;ACzGjB;AAAA;AAAA;AAAA;AAA4B;AACkB;AAC9C;AACA;AACA;AACA;AACA,oCAAoC;AACpC,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,gBAAgB,0DAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiB;;;;;;;;;;;;AC3GjB;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7CA;AAAA;AAAA;AAAA;AACsC;AACV;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA,YAAY,wCAAG;AACf,YAAY,wCAAG;AACf,YAAY,wCAAG;AACf;AACA;AACA;AACA,aAAa;AACb;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,KAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAQ,cAAc,kDAAQ,eAAe,kDAAQ;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,KAAK;AAC9B;AACA;AACA,gCAAgC,KAAK,GAAG,eAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,KAAK;AAC9B,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;ACzIA;AAAA;AAAA;AAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiB;;;;;;;;;;;;;ACvDjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACF;AACgB;AACV;AACN;AACI;AACjC,kCAAkC,0DAAY;AAC9C;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,wDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,2BAA2B,wCAAG;AAC9B,gBAAgB,4CAAK;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AAC+B;;;;;;;;;;;;;ACtD/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACN;AACE;AACc;AACZ;AACgB;AACR;AACZ;AACA;AACA;AAC0B;AACpB;AACR;AAC3B,8BAA8B,0DAAY;AAC1C;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC,gCAAgC,wCAAG;AACnC;AACA,YAAY,mEAAgB;AAC5B,gCAAgC,wCAAG;AACnC;AACA;AACA,YAAY,oDAAS;AACrB;AACA;AACA,YAAY,4DAAa;AACzB;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD;AACA;AACA,SAAS;AACT,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD;AACA;AACA,SAAS;AACT,+BAA+B,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACxE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,QAAQ,0CAAI;AAClD,sBAAsB,0CAAI;AAC1B;AACA,YAAY,wCAAG,MAAM,wCAAG;AACxB,SAAS;AACT;AACA;AACA;AACA,QAAQ,wDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB;AACA,gBAAgB,0CAAI;AACpB,qBAAqB,0CAAI;AACzB,SAAS;AACT;AACA;AACA,QAAQ,wCAAG;AACX,QAAQ,wCAAG;AACX;AACA,mCAAmC,wCAAG;AACtC,mCAAmC,wCAAG;AACtC,mCAAmC,wCAAG;AACtC;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0CAAI;AAC1B,sBAAsB,0CAAI;AAC1B,2DAA2D,0CAAI;AAC/D;AACA;AACA;AACA,2DAA2D,0CAAI,sBAAsB,0CAAI;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+CAAM;AACvB;AACA,YAAY,4CAAK;AACjB;AACA,oBAAoB,wCAAG;AACvB,aAAa;AACb,YAAY,yCAAG,KAAK,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAG,oBAAoB,wCAAG;AACrD;AACA,6BAA6B,wCAAG;AAChC;AACA;AACA;AACA;AACA,gBAAgB,4CAAK;AACrB;AACA;AACA;AACA,gBAAgB,4CAAK;AACrB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,4CAAK,aAAa,wCAAG;AACrC;AACA;AACA;AACA,gBAAgB,4CAAK,aAAa,wCAAG;AACrC;AACA,YAAY,4CAAK,UAAU,4CAAK;AAChC;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAG,gBAAgB,wCAAG;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA,aAAa;AACb;AACA,QAAQ,yCAAG,KAAK,0CAAI,qBAAqB,4CAAK;AAC9C;AACA;AACA;AACA,gCAAgC;AAChC,kCAAkC;AAClC;AACA;AAC2B;;;;;;;;;;;;;ACtL3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACF;AACgB;AAChB;AACI;AACjC,qCAAqC,0DAAY;AACjD;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,wDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,4BAA4B,cAAc;AAC1C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAG,oBAAoB,wCAAG;AACnD;AACA,YAAY,4CAAK;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,4BAA4B;AAC5B;AACkC;;;;;;;;;;;;;AC5ClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACF;AACgB;AACV;AACN;AACI;AACJ;AAC7B,yCAAyC,0DAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI,mBAAmB,0CAAI;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,wDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,4BAA4B,cAAc;AAC1C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wCAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wCAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,gBAAgB,4CAAK;AACrB,0BAA0B,wCAAG;AAC7B;AACA,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA,YAAY,wCAAG,KAAK,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsC;;;;;;;;;;;;;ACxFtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACF;AACgB;AACA;AAChB;AACI;AACjC,+BAA+B,0DAAY;AAC3C;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,wDAAO;AACf;AACA;AACA,gCAAgC,wDAAW;AAC3C;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wCAAG;AAC1B,YAAY,4CAAK;AACjB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,4BAA4B;AAC5B;AAC4B;;;;;;;;;;;;;AC/C5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACc;AACV;AACN;AACI;AACJ;AACA;AAC7B,iCAAiC,0DAAY;AAC7C;AACA;AACA;AACA,2BAA2B;AAC3B,4BAA4B;AAC5B;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,wDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,4BAA4B,cAAc;AAC1C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,gBAAgB,4CAAK;AACrB,0BAA0B,wCAAG;AAC7B;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA,YAAY,wCAAG,KAAK,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8B;;;;;;;;;;;;;ACrH9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACN;AACE;AACF;AACA;AACgB;AACV;AACF;AACJ;AACM;AACnC,qCAAqC,0DAAY;AACjD;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA,qBAAqB,wCAAG;AACxB;AACA,YAAY,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACrD,0BAA0B,0CAAI;AAC9B;AACA,gBAAgB,+CAAM;AACtB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC,YAAY,+CAAM;AAClB,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,wDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,4BAA4B,cAAc;AAC1C,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,0CAAI,wBAAwB,0CAAI;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAG;AAC9B,gCAAgC,wCAAG;AACnC,2BAA2B,wCAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,gBAAgB,4CAAK;AACrB,gBAAgB,4CAAK;AACrB,0BAA0B,wCAAG;AAC7B;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;;;;;;;;;;;;;ACnJlC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACE;AACY;AACA;AAChB;AACM;AACN;AACI;AACJ;AACkB;AACI;AACR;AACd;AAC0B;AACpB;AACnC,oCAAoC,0DAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,oCAAoC;AACpC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,0BAA0B;AAC1B,kCAAkC;AAClC,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAK;AACzB;AACA,oBAAoB,wCAAG,MAAM,wCAAG;AAChC;AACA;AACA;AACA;AACA;AACA,kCAAkC,4CAAK;AACvC;AACA,oDAAoD,4CAAK;AACzD;AACA,gBAAgB,yCAAG,KAAK,0CAAI;AAC5B;AACA;AACA,YAAY,yCAAG,SAAS,0CAAI,qBAAqB,4CAAK;AACtD;AACA;AACA;AACA,uCAAuC,wCAAG;AAC1C;AACA,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B,aAAa;AACb;AACA;AACA;AACA,oDAAoD,4CAAK;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iBAAiB,qBAAqB,cAAc;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe,aAAa,WAAW;AACxD;AACA;AACA;AACA,mEAAmE,WAAW;AAC9E;AACA;;AAEA;AACA,cAAc;;AAEd;AACA,cAAc;;AAEd;AACA;AACA;AACA,wBAAwB,WAAW,SAAS,WAAW,2BAA2B,gCAAgC;AAClH;AACA,gBAAgB;AAChB;AACA;AACA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA,2CAA2C,oBAAoB;AAC/D,mFAAmF,eAAe;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW,IAAI,WAAW;AACvF;AACA;AACA;AACA;AACA;AACA,oDAAoD,YAAY;AAChE,oCAAoC,UAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,oBAAoB;AACvE;AACA;AACA;AACA,6BAA6B,QAAQ,kCAAkC,EAAE;AACzE,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY,wCAAG,4CAA4C,2DAAQ,oCAAoC,2DAAQ,mBAAmB,4CAAK;AACvI;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,uDAAU;AACtB;AACA;AACA;AACA,QAAQ,wDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,4BAA4B,cAAc;AAC1C,SAAS;AACT;AACA;AACA,QAAQ,yCAAG,qBAAqB,8CAAM,QAAQ,0CAAI;AAClD,sBAAsB,0CAAI;AAC1B;AACA;AACA,oCAAoC,wCAAG;AACvC;AACA,SAAS;AACT,QAAQ,yCAAG,qBAAqB,8CAAM,MAAM,0CAAI;AAChD,sBAAsB,0CAAI;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA,gCAAgC,wDAAW,KAAK,eAAe;AAC/D,4CAA4C,mBAAmB;AAC/D,YAAY,wCAAG,MAAM,wCAAG;AACxB,SAAS;AACT,0CAA0C,iBAAiB;AAC3D,YAAY,wCAAG,MAAM,wCAAG;AACxB,SAAS;AACT;AACA,YAAY,wCAAG,MAAM,wCAAG;AACxB,SAAS;AACT;AACA,+BAA+B,yCAAG,qBAAqB,8CAAM,QAAQ,0CAAI;AACzE,gCAAgC,mEAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8BAA8B,2DAAQ;AACtC,gCAAgC,wCAAG;AACnC;AACA,gCAAgC,wCAAG;AACnC,gCAAgC,wCAAG;AACnC,gCAAgC,wCAAG;AACnC,gCAAgC,wCAAG;AACnC,gCAAgC,wCAAG;AACnC;AACA;AACA,QAAQ,yCAAG;AACX,QAAQ,yCAAG;AACX,mCAAmC,wCAAG;AACtC,mCAAmC,wCAAG;AACtC;AACA,QAAQ,+CAAM;AACd;AACA;AACA,mDAAmD,0CAAI,uBAAuB,0CAAI;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAG;AACnB;AACA;AACA;AACA;AACA,wBAAwB,wCAAG;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAG,eAAe,4CAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,gBAAgB,4CAAK;AACrB,0BAA0B,wCAAG;AAC7B;AACA,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,yCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yCAAG,KAAK,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK,iBAAiB,wCAAG;AACjC,QAAQ,4CAAK,aAAa,wCAAG;AAC7B;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB,IAAI,eAAe;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG;AACf,qBAAqB,0CAAI;AACzB;AACA,aAAa;AACb;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB,QAAQ,yCAAG;AACX,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK;AACb;AACA;AACA,4BAA4B,+DAAU;AACtC;AACA,4CAA4C,mBAAmB;AAC/D;AACA,YAAY,4CAAK;AACjB;AACA;AACA;AACA;AACA,YAAY,+CAAM;AAClB,YAAY,wCAAG;AACf,qBAAqB,0CAAI;AACzB;AACA,aAAa;AACb;AACA;AACA,QAAQ,yCAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8CAAM;AACzB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yCAAG;AACnB;AACA,SAAS;AACT;AACA;AACiC;;;;;;;;;;;;;ACtmBjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACN;AACE;AACF;AACgB;AACV;AACF;AACJ;AAC7B,6BAA6B,0DAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI,mBAAmB,0CAAI;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,wDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,4BAA4B,cAAc;AAC1C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wCAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wCAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,gBAAgB,4CAAK;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA,YAAY,wCAAG,KAAK,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,gBAAgB,4CAAK;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG,KAAK,0CAAI;AACxB;AACA;AACA;AACA;AACA,YAAY,wCAAG,KAAK,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AAC0B;;;;;;;;;;;;;ACxK1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6B;AACM;AACY;AACI;AAClB;AACjC;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,uCAAuC;AACvC,uCAAuC;AACvC,sCAAsC;AACtC,wBAAwB;AACxB,kCAAkC;AAClC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8CAAM;AACxB;AACA,qCAAqC;AACrC,uCAAuC;AACvC,uCAAuC;AACvC;AACA;AACA;AACA;AACA,6BAA6B,4CAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8DAAU;AAC1C,kDAAkD;AAClD;AACA;AACA;AACA,gBAAgB,4CAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mCAAmC,wCAAG;AACtC;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAQ;AACpC,gBAAgB,4CAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AAC2B;;;;;;;;;;;;;AC3I3B;AAAA;AAAA;AAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,sBAAsB;AACtB;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,eAAe;AACf,yBAAyB;AACzB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,gBAAgB;AAChB,oBAAoB;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,gBAAgB;AAChB,4BAA4B;AAC5B,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,mBAAmB;AACnB,oBAAoB;AACpB,mBAAmB;AACnB;AACA;AACA,mBAAmB;AACnB,mBAAmB;AACnB,oBAAoB;AACpB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,0BAA0B;AAC1B,gDAAgD;AAChD,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd,yBAAyB;AACzB,eAAe;AACf;AACA;AACA,eAAe;AACf,cAAc;AACd,+BAA+B;AAC/B,eAAe;AACf;AACA;AACA,kBAAkB;AAClB,mBAAmB;AACnB,gBAAgB;AAChB,mBAAmB;AACnB;AACA;AACA,kBAAkB;AAClB,kBAAkB;AAClB,sCAAsC;AACtC,kBAAkB;AAClB;AACA;AACA,iBAAiB;AACjB,kBAAkB;AAClB,2BAA2B;AAC3B,iBAAiB;AACjB;AACA;AACA,uBAAuB;AACvB,2BAA2B;AAC3B,yDAAyD;AACzD,wBAAwB;AACxB;AACA;AACA,0BAA0B;AAC1B,4BAA4B;AAC5B,4CAA4C;AAC5C,2BAA2B;AAC3B;AACA;AACA,iBAAiB;AACjB,WAAW;AACX,wBAAwB;AACxB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,WAAW;AACX,mBAAmB;AACnB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,WAAW;AACX,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc;AACd,4BAA4B;AAC5B,gBAAgB;AAChB;AACA;AACA;AACA,+BAA+B,KAAK,EAAE,GAAG;AACzC,kCAAkC,KAAK,EAAE,GAAG;AAC5C,yDAAyD,KAAK,EAAE,GAAG;AACnE,gCAAgC,KAAK,EAAE,GAAG;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,GAAG,KAAK,QAAQ,MAAM,qCAAqC,GAAG,EAAE,OAAO;AACvF,YAAY,GAAG,IAAI,QAAQ,MAAM,gEAAgE,GAAG,EAAE,OAAO;AAC7G,6BAA6B,GAAG,KAAK,QAAQ,MAAM,uGAAuG,GAAG,EAAE,OAAO;AACtK,gBAAgB,GAAG,KAAK,QAAQ,MAAM,gCAAgC,GAAG,EAAE,OAAO;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+CAAM,mBAAmB;AAC3C,0BAA0B,+CAAM,mBAAmB;AACnD,2CAA2C,+CAAM,mBAAmB;AACpE,kBAAkB,+CAAM,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,oBAAoB;AACpB,kDAAkD;AAClD,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA,gBAAgB;AAChB,WAAW;AACX,sBAAsB;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,wBAAwB;AACxB,2BAA2B;AAC3B,qBAAqB;AACrB;AACA;AACA,cAAc;AACd,gBAAgB;AAChB,gBAAgB;AAChB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,WAAW;AACX,WAAW;AACX,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,WAAW;AACX,WAAW;AACX,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,kBAAkB;AAClB,4CAA4C;AAC5C,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX,WAAW;AACX,eAAe;AACf;AACA;AACA,WAAW;AACX,WAAW;AACX,WAAW;AACX,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,2BAA2B;AAC3B,mCAAmC;AACnC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,KAAK,IAAI,UAAU;AAC5D,mDAAmD,KAAK,IAAI,UAAU;AACtE,+FAA+F,KAAK,MAAM,UAAU;AACpH,yCAAyC,KAAK,IAAI,UAAU;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoB;;;;;;;;;;;;;ACp4CpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACN;AACE;AACF;AACgB;AACV;AACF;AACJ;AAC7B,uCAAuC,0DAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI,mBAAmB,0CAAI;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,wDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,4BAA4B,cAAc;AAC1C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wCAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,gBAAgB,4CAAK;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA,YAAY,wCAAG,KAAK,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoC;;;;;;;;;;;;;ACpHpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACc;AACV;AACN;AACI;AACJ;AACA;AAC7B,+BAA+B,0DAAY;AAC3C;AACA;AACA;AACA,2BAA2B;AAC3B,4BAA4B;AAC5B;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,wDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,4BAA4B,cAAc;AAC1C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,gBAAgB,4CAAK;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA,YAAY,wCAAG,KAAK,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;;;;;;;;;;;;;AC7G5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACc;AACZ;AACgB;AACpB;AACA;AACA;AACA;AACM;AACoB;AAC5B;AAC3B,4BAA4B,0DAAY;AACxC;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,YAAY,mEAAgB;AAC5B,gCAAgC,wCAAG;AACnC;AACA;AACA,YAAY,4DAAa;AACzB;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD;AACA;AACA,SAAS;AACT,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,QAAQ,0CAAI;AAClD,sBAAsB,0CAAI;AAC1B;AACA,YAAY,wCAAG,MAAM,wCAAG;AACxB,SAAS;AACT;AACA;AACA;AACA,QAAQ,wDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB;AACA,gBAAgB,0CAAI;AACpB,qBAAqB,0CAAI;AACzB,SAAS;AACT;AACA;AACA,QAAQ,wCAAG;AACX,QAAQ,wCAAG;AACX;AACA,QAAQ,wCAAG;AACX,mCAAmC,wCAAG;AACtC,mCAAmC,wCAAG;AACtC;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0CAAI;AACtB,kBAAkB,0CAAI;AACtB,uDAAuD,0CAAI;AAC3D;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA,YAAY,4CAAK;AACjB;AACA,oBAAoB,wCAAG;AACvB,aAAa;AACb,YAAY,wCAAG,KAAK,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAG,oBAAoB,wCAAG;AACrD;AACA,6BAA6B,wCAAG;AAChC;AACA;AACA;AACA;AACA,gBAAgB,4CAAK;AACrB;AACA;AACA;AACA,gBAAgB,4CAAK;AACrB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,4CAAK,aAAa,wCAAG;AACrC;AACA;AACA;AACA,gBAAgB,4CAAK,aAAa,wCAAG;AACrC;AACA,YAAY,4CAAK,UAAU,4CAAK;AAChC;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACyB;;;;;;;;;;;;;ACxIzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACc;AACZ;AACJ;AACA;AAC7B,kCAAkC,0DAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,wDAAO;AACf;AACA,mBAAmB;AACnB;AACA,wBAAwB,wCAAG;AAC3B;AACA;AACA;AACA,iCAAiC,wCAAG;AACpC;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;;;;;;;;;;;;;ACrD/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACF;AACgB;AACV;AACF;AACJ;AAC7B,mCAAmC,0DAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,wDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,4BAA4B,cAAc;AAC1C,SAAS;AACT;AACA;AACA;AACA,mDAAmD,0CAAI,wBAAwB,0CAAI;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,gBAAgB,4CAAK;AACrB,gBAAgB,4CAAK;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA,YAAY,4CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgC;;;;;;;;;;;;;AC9HhC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACc;AACV;AACN;AACI;AACJ;AACc;AACd;AAC0B;AACvD,kCAAkC,0DAAY;AAC9C;AACA;AACA;AACA;AACA,iCAAiC;AACjC,oCAAoC;AACpC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAU;AACtB;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,QAAQ,0CAAI;AAClD,sBAAsB,0CAAI,mBAAmB,0CAAI;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wCAAG,qBAAqB,8CAAM,QAAQ,0CAAI;AACzE,gCAAgC,mEAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,wDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,4BAA4B,cAAc;AAC1C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,0CAAI,uBAAuB,0CAAI;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAG,oBAAoB,4CAAK;AACrD;AACA;AACA;AACA;AACA,gBAAgB,wCAAG;AACnB;AACA;AACA;AACA;AACA,wBAAwB,wCAAG;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,gBAAgB,4CAAK;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAG,KAAK,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK,iBAAiB,wCAAG;AACjC,QAAQ,4CAAK,aAAa,wCAAG;AAC7B;AACA;AAC+B;;;;;;;;;;;;;AC/M/B;AAAA;AAAA;AAA6B;AAC7B;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wCAAG;AAC/B;AACA;AACA;AACA;AACA,aAAa;AACb,+EAA+E,aAAa;AAC5F;AACA;AACA;AACA,aAAa;AACb,2BAA2B,wCAAG;AAC9B,+DAA+D,mBAAmB;AAClF;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACoB;;;;;;;;;;;;;AC9BpB;AAAA;AAAA;AAAsC;AACtC;AACA;AACA,eAAe,kDAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACyB;;;;;;;;;;;;;ACbzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmC;AACF;AACc;AACC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,sCAAsC;AACtC,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8CAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4CAAK;AAClC;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAQ;AAC9B;AACA;AACA,gBAAgB,0DAAQ;AACxB,2EAA2E,GAAG;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4DAAa;AACpC;AACA;AACA;AACA;AACA,iCAAiC,4DAAa;AAC9C;AACA;AACA;AACA,2BAA2B,4DAAa;AACxC;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe,GAAG,eAAe;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe,GAAG,eAAe;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,eAAe;AAC7D,sEAAsE,IAAI,oBAAoB,IAAI;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyB;;;;;;;;;;;;;AC3JzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6B;AACE;AACE;AACJ;AACE;AACE;AACjC;AACA;AACA;AACA;AACA,QAAQ,4CAAK;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0CAAI;AAC3C;AACA;AACA,2CAA2C,0CAAI;AAC/C,aAAa;AACb,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sCAAsC,0CAAI,eAAe;AACzD,+BAA+B,0CAAI,iBAAiB;AACpD;AACA;AACA,0CAA0C,0CAAI,eAAe;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0CAAI;AAChC;AACA,YAAY,4CAAK,iBAAiB,+CAAM;AACxC,uDAAuD;AACvD;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,wCAAG;AACf;AACA;AACA,sBAAsB,0CAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiC;AACJ;AACU;AACR;AACA;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA,YAAY,4CAAK;AACjB,YAAY,wCAAG;AACf,qBAAqB,0CAAI;AACzB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,uBAAuB,4CAAK;AAC5B,uBAAuB,YAAY;AACnC,yBAAyB,4CAAK;AAC9B;AACA;AACA,6BAA6B,kDAAQ;AACrC,+BAA+B,YAAY,IAAI,SAAS;AACxD,yBAAyB,+CAAM;AAC/B;AACA,kEAAkE,YAAY;AAC9E;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA,4DAA4D,IAAI;AAChE;AACA;AACA;AACA,4DAA4D,IAAI;AAChE;AACA;AACA;AACA,iDAAiD,gBAAgB,IAAI,aAAa;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA,mBAAmB,0CAAI;AACvB,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;AC9DA;AAAA;AAAA;AAAA;AAAA;AAAiC;AACJ;AACE;AACgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA,YAAY,4CAAK;AACjB,YAAY,wCAAG;AACf,qBAAqB,0CAAI;AACzB;AACA,aAAa;AACb;AACA;AACA;AACA,qBAAqB,0DAAQ;AAC7B,6BAA6B,4CAAK;AAClC;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA,mBAAmB,0CAAI;AACvB,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;ACjCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6B;AACA;AACM;AACJ;AACG;AACgB;AACjB;AACa;AAC9C;AACA;AACA;AACA;AACA,mDAAmD;AACnD,oBAAoB,wCAAG,iBAAiB,iDAAQ;AAChD,QAAQ,4CAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAc;AAC1B,YAAY,0DAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA,2BAA2B,iCAAiC;AAC5D;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,YAAY,wCAAG;AACf,YAAY,wCAAG;AACf,YAAY,wCAAG;AACf;AACA;AACA;AACA,aAAa;AACb;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA,QAAQ,wCAAG,sBAAsB,8CAAM,QAAQ,0CAAI;AACnD,YAAY,wCAAG,MAAM,wCAAG;AACxB,SAAS;AACT;AACA,QAAQ,wCAAG,sBAAsB,8CAAM,QAAQ,0CAAI;AACnD,YAAY,wCAAG,MAAM,wCAAG;AACxB,SAAS;AACT;AACA,QAAQ,wCAAG,sBAAsB,8CAAM,QAAQ,0CAAI;AACnD,YAAY,wCAAG,MAAM,wCAAG;AACxB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kDAAkD,0CAAI;AACtD;AACA,wBAAwB,wCAAG,MAAM,wCAAG;AACpC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wCAAG,MAAM,wCAAG;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wCAAG,MAAM,wCAAG;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,6CAA6C,wCAAG;AAChD;AACA;AACA;AACA,6CAA6C,wCAAG;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,aAAa;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACgB;;;;;;;;;;;;;ACtNhB;AAAA;AAA+B;AAC/B;AACA;AACA,yBAAyB,0CAAI,eAAe;AAC5C,yBAAyB,0CAAI,eAAe;AAC5C,yBAAyB,0CAAI,eAAe;AAC5C;AACA;AACA;AACA;AACA;AACA,0EAA0E,0CAAI,eAAe,2BAA2B,IAAI,0CAAI,eAAe;AAC/I,oDAAoD;AACpD;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;;AAEA;AACA,0DAA0D,0CAAI,sBAAsB,IAAI,0CAAI,mBAAmB;AAC/G;AACA;AACA,mCAAmC,0CAAI,eAAe,MAAM;AAC5D;AACA;AACA,mCAAmC,0CAAI,eAAe,MAAM;AAC5D;AACA;AACA,mCAAmC,0CAAI,eAAe,MAAM;AAC5D;AACA;AACA,mCAAmC,0CAAI,eAAe,MAAM;AAC5D;;AAEA;AACA,0DAA0D,0CAAI,sBAAsB,IAAI,0CAAI,mBAAmB;AAC/G;AACA;AACA,uCAAuC,0CAAI,iBAAiB,MAAM;AAClE;AACA;AACA,sCAAsC,0CAAI,iBAAiB,MAAM;AACjE;;AAEA;AACA,0DAA0D,0CAAI,sBAAsB,IAAI,0CAAI,mBAAmB;AAC/G;AACA;AACA,sCAAsC,0CAAI,iBAAiB,MAAM;AACjE;AACA;AACA,2CAA2C,0CAAI,iBAAiB,MAAM;AACtE;;AAEA;AACA,0DAA0D,0CAAI,qBAAqB,IAAI,0CAAI,mBAAmB;AAC9G;AACA;AACA;AACA,QAAQ,0CAAI,oBAAoB;AAChC;AACA;AACA;;AAEA;AACA,0DAA0D,0CAAI,sBAAsB,IAAI,0CAAI,mBAAmB;AAC/G;AACA;AACA;;AAEA;AACA,0DAA0D,0CAAI,sBAAsB,IAAI,0CAAI,mBAAmB;AAC/G;AACA;AACA;AACA,cAAc,0CAAI,gBAAgB,MAAM;AACxC;AACA,cAAc,0CAAI,gBAAgB,MAAM;AACxC;AACA;AACA;;AAEA;AACA,0DAA0D,0CAAI,yBAAyB,GAAG,0CAAI,sBAAsB,IAAI,0CAAI,sBAAsB;AAClJ;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,OAAO;;AAEhD;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA,yCAAyC,OAAO;;AAEhD;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;;AAEA;AACA,0DAA0D,0CAAI,wBAAwB,IAAI,0CAAI,mBAAmB;AACjH;AACA;AACA;AACA;AACA;AACA,6BAA6B,0CAAI,eAAe,MAAM;AACtD;AACA;AACA,6BAA6B,0CAAI,eAAe,MAAM;AACtD;AACA;AACA,6BAA6B,0CAAI,kBAAkB;AACnD;AACA;AACA;;AAEA;AACA,0DAA0D,0CAAI,qBAAqB,IAAI,0CAAI,mBAAmB,MAAM,MAAM;AAC1H;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAAI,eAAe,MAAM;AACzD;AACA;AACA,gCAAgC,0CAAI,eAAe,MAAM;AACzD;AACA;AACA;;AAEA;AACA,0DAA0D,0CAAI,qBAAqB,IAAI,0CAAI,mBAAmB;AAC9G;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA,0DAA0D,0CAAI,uBAAuB,IAAI,0CAAI,oBAAoB;AACjH;AACA;AACA;AACA;AACA;AACA,oCAAoC,0CAAI,eAAe,MAAM;AAC7D;AACA;AACA,oCAAoC,0CAAI,eAAe,MAAM;AAC7D;AACA;AACA;;AAEA;AACA,0DAA0D,0CAAI,uBAAuB,IAAI,0CAAI,oBAAoB;AACjH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0DAA0D,0CAAI,sBAAsB,IAAI,0CAAI,iBAAiB;AAC7G,8FAA8F,GAAG;AACjG;AACA;AACA,wBAAwB,GAAG,GAAG,GAAG;AACjC,wBAAwB,KAAK,GAAG,KAAK;AACrC,wBAAwB,QAAQ,GAAG,QAAQ;AAC3C,wBAAwB,MAAM,GAAG,MAAM;AACvC,wBAAwB,QAAQ,GAAG,QAAQ;AAC3C,wBAAwB,KAAK,GAAG,KAAK;AACrC,wBAAwB,eAAe,GAAG,eAAe;AACzD,wBAAwB,iBAAiB,GAAG,iBAAiB;AAC7D,wBAAwB,MAAM,GAAG,MAAM;AACvC,wBAAwB,KAAK,GAAG,KAAK;AACrC,wBAAwB,IAAI,GAAG,IAAI;AACnC,wBAAwB,KAAK,GAAG,KAAK;AACrC,wBAAwB,KAAK,GAAG,KAAK;AACrC,wBAAwB,UAAU,GAAG,UAAU;AAC/C,wBAAwB,GAAG,GAAG,GAAG;AACjC,wBAAwB,aAAa,GAAG,aAAa;AACrD,wBAAwB,aAAa,GAAG,aAAa;AACrD,wBAAwB,OAAO,GAAG,OAAO;AACzC,wBAAwB,MAAM,GAAG,MAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0CAAI;AACpB;AACA,2BAA2B;AAC3B;AACA,QAAQ,0CAAI;AACZ;AACA,0BAA0B,GAAG;AAC7B,QAAQ,0CAAI;AACZ;AACA,0BAA0B,KAAK;AAC/B,QAAQ,0CAAI;AACZ;AACA,0BAA0B,QAAQ;AAClC,QAAQ,0CAAI;AACZ;AACA,0BAA0B,MAAM;AAChC,QAAQ,0CAAI;AACZ;AACA,0BAA0B,QAAQ;AAClC,QAAQ,0CAAI;AACZ;AACA,0BAA0B,KAAK;AAC/B,QAAQ,0CAAI;AACZ;AACA,0BAA0B,eAAe;AACzC,QAAQ,0CAAI;AACZ;AACA,0BAA0B,iBAAiB;AAC3C,QAAQ,0CAAI;AACZ;AACA,0BAA0B,MAAM;AAChC,QAAQ,0CAAI;AACZ;AACA,0BAA0B,KAAK;AAC/B,QAAQ,0CAAI;AACZ;AACA,0BAA0B,IAAI;AAC9B,QAAQ,0CAAI;AACZ;AACA,0BAA0B,KAAK;AAC/B,QAAQ,0CAAI;AACZ;AACA,0BAA0B,KAAK;AAC/B,QAAQ,0CAAI;AACZ;AACA,0BAA0B,UAAU;AACpC,QAAQ,0CAAI;AACZ;AACA,0BAA0B,GAAG;AAC7B,QAAQ,0CAAI;AACZ;AACA,0BAA0B,aAAa;AACvC,QAAQ,0CAAI;AACZ;AACA,0BAA0B,aAAa;AACvC,QAAQ,0CAAI;AACZ;AACA,0BAA0B,OAAO;AACjC,QAAQ,0CAAI;AACZ;AACA,0BAA0B,MAAM;AAChC,QAAQ,0CAAI;AACZ;;AAEA;AACA,wCAAwC,0CAAI,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D,0CAAI,qBAAqB,IAAI,0CAAI,qBAAqB;AAChH;AACA;AACA;AACA;AACA,0DAA0D,0CAAI,uBAAuB,IAAI,0CAAI,qBAAqB;AAClH;AACA;AACA;AACA;AACA,0DAA0D,0CAAI,qBAAqB,IAAI,0CAAI,mBAAmB;AAC9G;AACA;AACA;AACA,cAAc,0CAAI,kBAAkB;AACpC;AACA;AACA,qDAAqD;AACrD;AACA;AACA,+CAA+C,0CAAI,iBAAiB,MAAM;AAC1E;AACA;;AAEA;AACA,0DAA0D,0CAAI,wBAAwB,IAAI,0CAAI,sBAAsB;AACpH;AACA;AACA;;AAEA;;AAEA;AACA,0DAA0D,0CAAI,iBAAiB,IAAI,0CAAI,mBAAmB;AAC1G;AACA;;AAEA;AACA,0DAA0D,0CAAI,oBAAoB,IAAI,0CAAI,mBAAmB;AAC7G;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,0DAA0D,0CAAI,wBAAwB,IAAI,0CAAI,mBAAmB;AACjH;AACA;AACA,oCAAoC,0CAAI,sBAAsB,OAAO;AACrE;AACA;AACA,mCAAmC,0CAAI,gBAAgB,OAAO;AAC9D;AACA;AACA,6DAA6D,0CAAI,eAAe,IAAI,0CAAI,iBAAiB,OAAO;AAChH;AACA;AACA,mCAAmC,0CAAI,oBAAoB,OAAO;AAClE;;AAEA;AACA,0DAA0D,0CAAI,wBAAwB,IAAI,0CAAI,sBAAsB;AACpH;AACA,8CAA8C,0CAAI,wBAAwB,KAAK,0CAAI,eAAe;AAClG;;AAEA;AACA,wCAAwC,0CAAI,mBAAmB,2BAA2B;AAC1F;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA,0DAA0D,0CAAI,wBAAwB,IAAI,0CAAI,sBAAsB;AACpH;AACA;AACA;;AAEA;AACA,wCAAwC,0CAAI,iBAAiB;AAC7D;AACA;AACA,iCAAiC,0CAAI,eAAe;AACpD;AACA;AACA;AACA,iCAAiC,0CAAI,eAAe;AACpD;AACA;AACA;AACA;AACA,iCAAiC,0CAAI,eAAe;AACpD;AACA;;AAEA;AACA,0DAA0D,0CAAI,0BAA0B;AACxF,QAAQ,0CAAI,mBAAmB;AAC/B;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA,0DAA0D,0CAAI,uBAAuB;AACrF,QAAQ,0CAAI,oBAAoB;AAChC;AACA;AACA;AACA,kBAAkB,GAAG,0CAAI,eAAe;AACxC;AACA;AACA,8DAA8D,0CAAI,mBAAmB,IAAI,0CAAI,eAAe;AAC5G;AACA;AACA;AACA,8DAA8D,0CAAI,mBAAmB,IAAI,0CAAI,eAAe;AAC5G;AACA,iFAAiF,0CAAI,eAAe;AACpG,iFAAiF,0CAAI,eAAe;AACpG,gFAAgF,0CAAI,eAAe;AACnG;AACA;;AAEA;AACA,0DAA0D,0CAAI,sBAAsB,IAAI,0CAAI,mBAAmB;AAC/G;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,0DAA0D,0CAAI,wBAAwB;AACtF,QAAQ,0CAAI,qBAAqB;AACjC;AACA;AACA;;AAEA;AACA,wCAAwC,0CAAI,iBAAiB;;AAE7D;AACA;AACA,+BAA+B,0CAAI,kBAAkB,MAAM;AAC3D;AACA;AACA,+BAA+B,0CAAI,mBAAmB;;AAEtD;;AAEA;AACA;AACA,+BAA+B,0CAAI,eAAe,MAAM;AACxD;AACA;AACA,+BAA+B,0CAAI,gBAAgB;AACnD;;AAEA;;AAEA;AACA,0DAA0D,0CAAI,qBAAqB,IAAI,0CAAI,mBAAmB;AAC9G;AACA;AACA;;AAEA;AACA,wCAAwC,0CAAI,iBAAiB;AAC7D,2FAA2F;AAC3F,mEAAmE,0CAAI,eAAe;AACtF;AACA;AACA,cAAc,0CAAI,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,0CAAI,iBAAiB;AAC7D;AACA;AACA,4BAA4B,0CAAI,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC,0CAAI,iBAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,0CAAI,iBAAiB;AAC7D,2EAA2E,0CAAI,iBAAiB;AAChG,2EAA2E,0CAAI,iBAAiB;AAChG,0EAA0E,0CAAI,iBAAiB;AAC/F;;AAEA;AACA;AACA;AACA;AACe,uEAAQ,EAAC;;;;;;;;;;;;;ACriBxB;AAAA;AAAA;AAAA;AAAA;AAA6B;AACU;AACD;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAQ;AAC5C,iBAAiB,kDAAQ;AACzB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAQ;AAChB,QAAQ,wCAAG,MAAM,wCAAG,sBAAsB,2BAA2B;AACrE;AACA;AACA;AACA;AACA,YAAY,kDAAQ;AACpB,sCAAsC,kDAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAQ;AACpB,oCAAoC,kDAAQ;AAC5C;AACA;AACA;AACA;AACA,qBAAqB,kDAAQ,aAAa,kDAAQ;AAClD;AACA;AACA,YAAY,kDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwB;;;;;;;;;;;;;AC7QxB;AAAA;AAAA;AAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,yBAAyB,0CAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,GAAG;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmB;;;;;;;;;;;;;ACrDnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6B;AACA;AACE;AACF;AACI;AACK;AACtC;AACA;AACA;AACA,wBAAwB;AACxB,2BAA2B;AAC3B;AACA;AACA,wEAAwE,0CAAI,4CAA4C,IAAI,0CAAI,eAAe;AAC/I,sDAAsD,0CAAI,eAAe;AACzE;AACA;AACA;AACA,QAAQ,wCAAG;AACX,qBAAqB,wCAAG;AACxB,QAAQ,4CAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA,YAAY,kDAAQ;AACpB,YAAY,kDAAQ;AACpB;AACA;AACA,aAAa,kDAAQ;AACrB,YAAY,kDAAQ;AACpB;AACA;AACA,QAAQ,wCAAG,SAAS,0CAAI;AACxB;AACA;AACA,QAAQ,kDAAQ;AAChB;AACA;AACA;AACA;AACA,QAAQ,kDAAQ;AAChB,QAAQ,wCAAG,MAAM,wCAAG,sBAAsB,mCAAmC;AAC7E;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA,mBAAmB,kDAAQ;AAC3B,SAAS;AACT;AACA;AACA;AACA,uBAAuB,KAAK,kDAAQ,uBAAuB;AAC3D;AACA,2BAA2B,kDAAQ,mBAAmB;AACtD,oEAAoE,EAAE;AACtE;AACA;AACA;AACA,YAAY,kDAAQ;AACpB,uCAAuC,MAAM,MAAM,MAAM;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0B;;;;;;;;;;;;;AC/G1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6B;AACA;AACE;AACF;AACS;AACtC;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB,wCAAG,qBAAqB,kDAAQ;AACtD;AACA;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB,oBAAoB,0CAAI,4BAA4B,0CAAI;AACxD,QAAQ,wCAAG;AACX,QAAQ,wCAAG;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY,kDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACsB;;;;;;;;;;;;;AC9CtB;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA,gDAAgD;AAChD;AAC6B;AACA;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,GAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2BAA2B;AACjE;AACA,QAAQ,wCAAG;AACX;AACA;AACA,kCAAkC,wCAAG;AACrC,mBAAmB,wCAAG;AACtB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mBAAmB,wCAAG;AACtB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA;AACoB;;;;;;;;;;;;;AC/KpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6B;AACkB;AACb;AACF;AACE;AAClC;AACA;AACA;AACA,gCAAgC;AAChC,wBAAwB;AACxB,0BAA0B;AAC1B;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,SAAS,wCAAG,qBAAqB,wCAAG;AACpC;AACA;AACA,aAAa;AACb,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA,iCAAiC,0DAAQ;AACzC;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4CAAK;AACrC;AACA;AACA,gCAAgC,8CAAM;AACtC;AACA;AACA;AACA,gCAAgC,8CAAM;AACtC;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqB;;;;;;;;;;;;;AC7ErB;AAAA;AAAA;AAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,oBAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACwB;;;;;;;;;;;;;ACrDxB;AAAA;AAAA;AAAA;AAAA;AAA8C;AACjB;AACA;AAC7B;AACA;AACA;AACA;AACA,kCAAkC,0DAAY;AAC9C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wCAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY,wCAAG,MAAM,wCAAG;AACxB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wCAAG;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACkB;;;;;;;;;;;;;ACtDlB;AAAA;AAAA;AAAA;AAAA;AAA8C;AACjB;AACA;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B;AACA,aAAa;AACb;AACA,kCAAkC,0DAAY;AAC9C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wCAAG;AACrC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACiB;;;;;;;;;;;;;AChEjB;AAAA;AAAA;AAAA;AAAA;AAA8C;AACjB;AACA;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0DAAY;AAC9C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG,MAAM,wCAAG;AACxB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wCAAG;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACkB","file":"content.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/ts/content.ts\");\n","/*\r\n * project: Powerful Pixiv Downloader\r\n * author:  xuejianxianzun; 雪见仙尊\r\n * license: GPL-3.0-or-later; http://www.gnu.org/licenses/gpl-3.0.txt\r\n * Github： https://github.com/xuejianxianzun/PixivBatchDownloader\r\n * Releases: https://github.com/xuejianxianzun/PixivBatchDownloader/releases\r\n * Wiki:    https://xuejianxianzun.github.io/PBDWiki\r\n * Website: https://pixiv.download/\r\n * E-mail:  xuejianxianzun@gmail.com\r\n */\r\n// 处理和脚本版的冲突\r\n{\r\n    // 标注自己\r\n    window.sessionStorage.setItem('xz_pixiv_extension', '1');\r\n    // 把脚本版的标记设置为 0，这样脚本版就不会运行\r\n    window.sessionStorage.setItem('xz_pixiv_userscript', '0');\r\n}\r\nimport './modules/setting/Settings';\r\nimport './modules/PageType';\r\nimport './modules/DownloadButton';\r\nimport './modules/CenterPanel';\r\nimport './modules/setting/FormSettings';\r\nimport './modules/InitPage';\r\nimport './modules/DownloadControl';\r\nimport './modules/ListenPageSwitch';\r\nimport './modules/Tip';\r\nimport './modules/TitleBar';\r\nimport './modules/output/OutputPanel';\r\nimport './modules/output/PreviewFileName';\r\nimport './modules/output/ShowURLs';\r\nimport './modules/MsgBox';\r\nimport './modules/CheckNew';\r\nimport './modules/ShowWhatIsNew';\r\nimport './modules/ExportCSV';\r\nimport './modules/ExportResult';\r\nimport './modules/ExportLST';\r\n","class API {\r\n    // 根据对象某个属性的值（视为数字）排序对象。返回的结果是降序排列\r\n    static sortByProperty(key) {\r\n        return function (a, b) {\r\n            // 排序的内容有时可能是字符串，需要转换成数字排序\r\n            const value1 = typeof a[key] === 'number' ? a[key] : parseFloat(a[key]);\r\n            const value2 = typeof b[key] === 'number' ? b[key] : parseFloat(b[key]);\r\n            if (value2 < value1) {\r\n                return -1;\r\n            }\r\n            else if (value2 > value1) {\r\n                return 1;\r\n            }\r\n            else {\r\n                return 0;\r\n            }\r\n        };\r\n    }\r\n    // 用正则过滤不安全的字符，（Chrome 和 Windows 不允许做文件名的字符）\r\n    // 把一些特殊字符替换成全角字符\r\n    static replaceUnsafeStr(str) {\r\n        str = str.replace(this.unsafeStr, '');\r\n        for (let index = 0; index < this.fullWidthDict.length; index++) {\r\n            const rule = this.fullWidthDict[index];\r\n            const reg = new RegExp(rule[0], 'g');\r\n            str = str.replace(reg, rule[1]);\r\n        }\r\n        return str;\r\n    }\r\n    // 检查给定的字符串解析为数字后，是否大于 0\r\n    static checkNumberGreater0(arg) {\r\n        let num = parseInt(arg);\r\n        // 空值会是 NaN\r\n        if (!isNaN(num) && num > 0) {\r\n            // 符合条件\r\n            return {\r\n                result: true,\r\n                value: num,\r\n            };\r\n        }\r\n        // 不符合条件\r\n        return {\r\n            result: false,\r\n            value: 0,\r\n        };\r\n    }\r\n    // 从 url 中获取指定的查询字段的值\r\n    // 注意：返回值经过 encodeURIComponent 编码！\r\n    static getURLSearchField(url, query) {\r\n        const result = new URL(url).searchParams.get(query);\r\n        if (result !== null) {\r\n            return encodeURIComponent(result);\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    }\r\n    // 从 url 中获取 tag\r\n    static getTagFromURL(url = location.href) {\r\n        const nowURL = new URL(url);\r\n        // 2 用户作品列表页\r\n        if (/\\/users\\/\\d+/.test(url) && !url.includes('/bookmarks')) {\r\n            // 匹配 pathname 里用户 id 之后的字符\r\n            const test = nowURL.pathname.match(/\\/users\\/\\d+(\\/.+)/);\r\n            if (test && test.length === 2) {\r\n                const str = test[1];\r\n                // 如果用户 id 之后的字符多于一个路径，则把最后一个路径作为 tag，示例\r\n                // https://www.pixiv.net/users/2188232/illustrations/ghostblade\r\n                const array = str.split('/');\r\n                // [\"\", \"illustrations\", \"ghostblade\"]\r\n                if (array.length > 2) {\r\n                    return decodeURIComponent(array[array.length - 1]);\r\n                }\r\n            }\r\n        }\r\n        // 4 旧版收藏页面\r\n        if (nowURL.pathname === '/bookmark.php') {\r\n            if (parseInt(this.getURLSearchField(nowURL.href, 'untagged')) === 1) {\r\n                // 旧版 “未分类” tag 是个特殊标记\r\n                // https://www.pixiv.net/bookmark.php?untagged=1\r\n                return '未分類';\r\n            }\r\n        }\r\n        // 4 新版收藏页面\r\n        if (nowURL.pathname.includes('/bookmarks/')) {\r\n            // 新版收藏页 url，tag 在路径末端，如\r\n            // https://www.pixiv.net/users/9460149/bookmarks/artworks/R-18\r\n            // https://www.pixiv.net/users/9460149/bookmarks/novels/R-18\r\n            const test = /\\/bookmarks\\/\\w*\\/(.[^\\/|^\\?|^&]*)/.exec(nowURL.pathname);\r\n            if (test !== null && test.length > 1 && !!test[1]) {\r\n                return decodeURIComponent(test[1]);\r\n            }\r\n        }\r\n        // 5 搜索页面\r\n        if (nowURL.pathname.includes('/tags/')) {\r\n            return decodeURIComponent(nowURL.pathname.split('tags/')[1].split('/')[0]);\r\n        }\r\n        // 默认情况，从查询字符串里获取，如下网址\r\n        // https://www.pixiv.net/bookmark.php?tag=R-18\r\n        return decodeURIComponent(this.getURLSearchField(nowURL.href, 'tag'));\r\n    }\r\n    // 从 url 里获取 artworks id\r\n    // 可以传入 url，无参数则使用当前页面的 url\r\n    static getIllustId(url) {\r\n        const str = url || window.location.search || location.href;\r\n        if (str.includes('illust_id')) {\r\n            // 传统 url\r\n            return /illust_id=(\\d*\\d)/.exec(str)[1];\r\n        }\r\n        else if (str.includes('/artworks/')) {\r\n            // 新版 url\r\n            return /artworks\\/(\\d*\\d)/.exec(str)[1];\r\n        }\r\n        else {\r\n            // 直接取出 url 中的数字，不保证准确\r\n            return /\\d*\\d/.exec(location.href)[0];\r\n        }\r\n    }\r\n    // 从 url 里获取 novel id\r\n    // https://www.pixiv.net/novel/show.php?id=12771688\r\n    static getNovelId(url) {\r\n        const str = url || window.location.search || location.href;\r\n        const test = str.match(/\\?id=(\\d*)?/);\r\n        return test[1];\r\n    }\r\n    // 通用的请求流程\r\n    // 发送 get 请求，返回 json 数据，抛出异常\r\n    static request(url) {\r\n        return new Promise((resolve, reject) => {\r\n            fetch(url, {\r\n                method: 'get',\r\n                credentials: 'same-origin',\r\n            })\r\n                .then((response) => {\r\n                if (response.ok) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    // 第一种异常，请求成功但状态不对\r\n                    reject({\r\n                        status: response.status,\r\n                        statusText: response.statusText,\r\n                    });\r\n                }\r\n            })\r\n                .then((data) => {\r\n                resolve(data);\r\n            })\r\n                .catch((error) => {\r\n                // 第二种异常，请求失败\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n    // 获取收藏数据\r\n    // 这个 api 返回的作品列表顺序是按收藏顺序由近期到早期排列的\r\n    static async getBookmarkData(id, type = 'illusts', tag, offset, hide = false) {\r\n        const url = `https://www.pixiv.net/ajax/user/${id}/${type}/bookmarks?tag=${tag}&offset=${offset}&limit=100&rest=${hide ? 'hide' : 'show'}&rdm=${Math.random()}`;\r\n        return this.request(url);\r\n    }\r\n    // 添加收藏\r\n    static async addBookmark(type, id, tags, hide, token) {\r\n        const restrict = hide ? 1 : 0;\r\n        let body = {};\r\n        if (type === 'illusts') {\r\n            body = {\r\n                comment: '',\r\n                illust_id: id,\r\n                restrict: restrict,\r\n                tags: tags,\r\n            };\r\n        }\r\n        else {\r\n            body = {\r\n                comment: '',\r\n                novel_id: id,\r\n                restrict: restrict,\r\n                tags: tags,\r\n            };\r\n        }\r\n        return fetch(`https://www.pixiv.net/ajax/${type}/bookmarks/add`, {\r\n            method: 'POST',\r\n            credentials: 'same-origin',\r\n            headers: {\r\n                Accept: 'application/json',\r\n                'Content-Type': 'application/json; charset=utf-8',\r\n                'x-csrf-token': token,\r\n            },\r\n            body: JSON.stringify(body),\r\n        });\r\n    }\r\n    // 获取关注的用户列表\r\n    static getFollowingList(id, rest = 'show', offset = 0, limit = 100, tag = '', lang = 'zh') {\r\n        const url = `https://www.pixiv.net/ajax/user/${id}/following?offset=${offset}&limit=${limit}&rest=${rest}&tag=${tag}&lang=${lang}`;\r\n        return this.request(url);\r\n    }\r\n    // 获取用户信息\r\n    static getUserProfile(id) {\r\n        // full=1 在画师的作品列表页使用，获取详细信息\r\n        // full=0 在作品页内使用，只获取少量信息\r\n        const url = `https://www.pixiv.net/ajax/user/${id}?full=1`;\r\n        return this.request(url);\r\n    }\r\n    // 获取用户指定类型的作品列表\r\n    // 返回作品的 id 列表，不包含详细信息\r\n    static async getUserWorksByType(id, type = ['illusts', 'manga', 'novels']) {\r\n        let typeSet = new Set(type);\r\n        let result = [];\r\n        const url = `https://www.pixiv.net/ajax/user/${id}/profile/all`;\r\n        let data = await this.request(url);\r\n        for (const type of typeSet.values()) {\r\n            const idList = Object.keys(data.body[type]);\r\n            for (const id of idList) {\r\n                result.push({\r\n                    type,\r\n                    id,\r\n                });\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    // 获取用户指定类型、并且指定 tag 的作品列表\r\n    // 返回整个请求的结果，里面包含作品的详细信息\r\n    // 必须带 tag 使用。不带 tag 虽然也能获得数据，但是获得的并不全，很奇怪。\r\n    static getUserWorksByTypeWithTag(id, type, tag, offset = 0, limit = 999999) {\r\n        // https://www.pixiv.net/ajax/user/2369321/illusts/tag?tag=Fate/GrandOrder&offset=0&limit=9999999\r\n        const url = `https://www.pixiv.net/ajax/user/${id}/${type}/tag?tag=${tag}&offset=${offset}&limit=${limit}`;\r\n        return this.request(url);\r\n    }\r\n    // 获取插画 漫画 动图 的详细信息\r\n    static getArtworkData(id) {\r\n        const url = `https://www.pixiv.net/ajax/illust/${id}`;\r\n        return this.request(url);\r\n    }\r\n    // 获取动图的元数据\r\n    static getUgoiraMeta(id) {\r\n        const url = `https://www.pixiv.net/ajax/illust/${id}/ugoira_meta`;\r\n        return this.request(url);\r\n    }\r\n    // 获取小说的详细信息\r\n    static getNovelData(id) {\r\n        const url = `https://www.pixiv.net/ajax/novel/${id}`;\r\n        return this.request(url);\r\n    }\r\n    // 获取相关作品\r\n    static getRelatedData(id) {\r\n        // 最后的 18 是预加载首屏的多少个作品的信息，和下载并没有关系\r\n        const url = `https://www.pixiv.net/ajax/illust/${id}/recommend/init?limit=18`;\r\n        return this.request(url);\r\n    }\r\n    // 获取排行榜数据\r\n    // 排行榜数据基本是一批 50 条作品信息\r\n    static getRankingData(option) {\r\n        let url = `https://www.pixiv.net/ranking.php?mode=${option.mode}&p=${option.p}&format=json`;\r\n        // 把可选项添加到 url 里\r\n        let temp = new URL(url);\r\n        // 下面两项需要判断有值再添加。不可以添加了这些字段却使用空值。\r\n        if (option.worksType) {\r\n            temp.searchParams.set('content', option.worksType);\r\n        }\r\n        if (option.date) {\r\n            temp.searchParams.set('date', option.date);\r\n        }\r\n        url = temp.toString();\r\n        return this.request(url);\r\n    }\r\n    // 获取收藏后的相似作品数据\r\n    // 需要传入作品 id 和要抓取的数量。但是实际获取到的数量会比指定的数量少一些\r\n    static getRecommenderData(id, number) {\r\n        const url = `/rpc/recommender.php?type=illust&sample_illusts=${id}&num_recommendations=${number}`;\r\n        return this.request(url);\r\n    }\r\n    // 获取搜索数据\r\n    static getSearchData(word, type = 'artworks', p = 1, option = {}) {\r\n        // 基础的 url\r\n        let url = `https://www.pixiv.net/ajax/search/${type}/${encodeURIComponent(word)}?word=${encodeURIComponent(word)}&p=${p}`;\r\n        // 把可选项添加到 url 里\r\n        let temp = new URL(url);\r\n        for (const [key, value] of Object.entries(option)) {\r\n            if (value) {\r\n                temp.searchParams.set(key, value);\r\n            }\r\n        }\r\n        url = temp.toString();\r\n        return this.request(url);\r\n    }\r\n    static getNovelSearchData(word, p = 1, option = {}) {\r\n        // 基础的 url\r\n        let url = `https://www.pixiv.net/ajax/search/novels/${encodeURIComponent(word)}?word=${encodeURIComponent(word)}&p=${p}`;\r\n        // 把可选项添加到 url 里\r\n        let temp = new URL(url);\r\n        for (const [key, value] of Object.entries(option)) {\r\n            if (value) {\r\n                temp.searchParams.set(key, value);\r\n            }\r\n        }\r\n        url = temp.toString();\r\n        return this.request(url);\r\n    }\r\n    // 获取大家的新作品的数据\r\n    static getNewIllustData(option) {\r\n        let url = `https://www.pixiv.net/ajax/illust/new?lastId=${option.lastId}&limit=${option.limit}&type=${option.type}&r18=${option.r18}`;\r\n        return this.request(url);\r\n    }\r\n    // 获取大家的新作小说的数据\r\n    static getNewNovleData(option) {\r\n        let url = `https://www.pixiv.net/ajax/novel/new?lastId=${option.lastId}&limit=${option.limit}&r18=${option.r18}`;\r\n        return this.request(url);\r\n    }\r\n    // 获取关注的的新作品的数据\r\n    static getBookmarkNewIllustData(p = 1, r18 = false) {\r\n        let path = r18 ? 'bookmark_new_illust_r18' : 'bookmark_new_illust';\r\n        let url = `https://www.pixiv.net/${path}.php?p=${p}`;\r\n        return new Promise((resolve, reject) => {\r\n            fetch(url, {\r\n                method: 'get',\r\n                credentials: 'same-origin',\r\n            })\r\n                .then((response) => {\r\n                if (response.ok) {\r\n                    return response.text();\r\n                }\r\n                else {\r\n                    throw new Error(response.status.toString());\r\n                }\r\n            })\r\n                .then((data) => {\r\n                let listPageDocument = new DOMParser().parseFromString(data, 'text/html');\r\n                let worksInfoText = listPageDocument.querySelector('#js-mount-point-latest-following').dataset.items;\r\n                resolve(JSON.parse(worksInfoText));\r\n            })\r\n                .catch((error) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n    // 根据 illustType，返回作品类型的描述\r\n    // 主要用于储存进 idList\r\n    static getWorkType(illustType) {\r\n        switch (parseInt(illustType.toString())) {\r\n            case 0:\r\n                return 'illusts';\r\n            case 1:\r\n                return 'manga';\r\n            case 2:\r\n                return 'ugoira';\r\n            case 3:\r\n                return 'novels';\r\n            default:\r\n                return 'unknown';\r\n        }\r\n    }\r\n    // 从 URL 中获取指定路径名的值，适用于符合 RESTful API 风格的路径\r\n    // 如 https://www.pixiv.net/novel/series/1090654\r\n    // 把路径用 / 分割，查找 key 所在的位置，后面一项就是它的 value\r\n    static getURLPathField(query) {\r\n        const pathArr = location.pathname.split('/');\r\n        const index = pathArr.indexOf(query);\r\n        if (index > 0) {\r\n            return pathArr[index + 1];\r\n        }\r\n        throw new Error(`getURLPathField ${query} failed!`);\r\n    }\r\n    // 获取小说的系列作品信息\r\n    // 这个 api 目前一批最多只能返回 30 个作品的数据，所以可能需要多次获取\r\n    static getNovelSeriesData(series_id, limit = 30, last_order, order_by = 'asc') {\r\n        const url = `https://www.pixiv.net/ajax/novel/series_content/${series_id}?limit=${limit}&last_order=${last_order}&order_by=${order_by}`;\r\n        return this.request(url);\r\n    }\r\n    // 获取系列信息\r\n    // 这个接口的数据结构里同时有 illust （包含漫画）和 novel 系列数据\r\n    // 恍惚记得有插画系列来着，但是没找到对应的网址，难道是记错了？\r\n    static getSeriesData(series_id, pageNo) {\r\n        const url = `https://www.pixiv.net/ajax/series/${series_id}?p=${pageNo}`;\r\n        return this.request(url);\r\n    }\r\n    // 点赞\r\n    static async addLike(id, type, token) {\r\n        let data = {};\r\n        if (type === 'illusts') {\r\n            data = {\r\n                illust_id: id,\r\n            };\r\n        }\r\n        else {\r\n            data = {\r\n                novel_id: id,\r\n            };\r\n        }\r\n        const r = await fetch(`https://www.pixiv.net/ajax/${type}/like`, {\r\n            method: 'POST',\r\n            headers: {\r\n                Accept: 'application/json',\r\n                'Content-Type': 'application/json; charset=utf-8',\r\n                'x-csrf-token': token,\r\n            },\r\n            credentials: 'same-origin',\r\n            body: JSON.stringify(data),\r\n        });\r\n        const json = (await r.json());\r\n        return json;\r\n    }\r\n}\r\n// 不安全的字符，这里多数是控制字符，需要替换掉\r\nAPI.unsafeStr = new RegExp(/[\\u0001-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0605\\u061c\\u06dd\\u070f\\u08e2\\u180e\\u200b-\\u200f\\u202a-\\u202e\\u2060-\\u2064\\u2066-\\u206f\\ufdd0-\\ufdef\\ufeff\\ufff9-\\ufffb\\ufffe\\uffff]/g);\r\n// 一些需要替换成全角字符的符号，左边是正则表达式的字符\r\nAPI.fullWidthDict = [\r\n    ['\\\\\\\\', '＼'],\r\n    ['/', '／'],\r\n    [':', '：'],\r\n    ['\\\\?', '？'],\r\n    ['\"', '＂'],\r\n    ['<', '＜'],\r\n    ['>', '＞'],\r\n    ['\\\\*', '＊'],\r\n    ['\\\\|', '｜'],\r\n    ['~', '～'],\r\n];\r\nexport { API };\r\n","import { DOM } from './DOM';\r\n// 检查图片是否是黑白图片\r\nclass BlackAndWhiteImage {\r\n    constructor() {\r\n        this.latitude = 1; // 宽容度\r\n    }\r\n    async check(imgUrl) {\r\n        const img = await this.loadImg(imgUrl).catch((error) => {\r\n            console.error(error);\r\n        });\r\n        // 当加载图片失败时，无法进行判断，默认为彩色图片\r\n        if (!img) {\r\n            return false;\r\n        }\r\n        const first = this.getResult(this.getColor(img));\r\n        return first;\r\n        // 当判断结果是彩色图片的时候，基本不会是误判。但如果结果是黑白图，可能存在误判。\r\n        // 因此，如果第一次判断是黑白的，可以考虑进行第二次检测，第二次只检测局部\r\n    }\r\n    // 加载图片\r\n    async loadImg(url) {\r\n        return new Promise(async (resolve, reject) => {\r\n            // 如果传递的时 blobURL 就直接使用，不是的话先获取图片\r\n            if (url.startsWith('blob')) {\r\n                resolve(DOM.loadImg(url));\r\n            }\r\n            else {\r\n                const res = await fetch(url).catch((error) => {\r\n                    throw new Error(`Load image error! url: ${url}`);\r\n                });\r\n                const blob = await res.blob();\r\n                const blobURL = URL.createObjectURL(blob);\r\n                resolve(DOM.loadImg(blobURL));\r\n            }\r\n        });\r\n    }\r\n    // 获取图片中 rgb 三色的平均值\r\n    getColor(img) {\r\n        const width = img.width;\r\n        const height = img.height;\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        const con = canvas.getContext('2d');\r\n        con.drawImage(img, 0, 0);\r\n        const imageData = con.getImageData(0, 0, width, height);\r\n        const data = imageData.data;\r\n        let r = 0;\r\n        let g = 0;\r\n        let b = 0;\r\n        // 取所有像素的平均值\r\n        for (let row = 0; row < height; row++) {\r\n            for (let col = 0; col < width; col++) {\r\n                r += data[(width * row + col) * 4];\r\n                g += data[(width * row + col) * 4 + 1];\r\n                b += data[(width * row + col) * 4 + 2];\r\n            }\r\n        }\r\n        // 求取平均值\r\n        r /= width * height;\r\n        g /= width * height;\r\n        b /= width * height;\r\n        // 将最终的值取整\r\n        r = Math.round(r);\r\n        g = Math.round(g);\r\n        b = Math.round(b);\r\n        return [r, g, b];\r\n    }\r\n    // 根据 rgb 的值，判断是否是黑白图片\r\n    getResult(rgb) {\r\n        const [r, g, b] = rgb;\r\n        // 如果 rgb 值相同则是黑白图片\r\n        if (r === g && g === b) {\r\n            return true;\r\n        }\r\n        else {\r\n            // 如果 rgb 值不相同，则根据宽容度判断是否近似为黑白图片\r\n            // 这是因为获取 rgb 的结果时，进行了四舍五入，即使 rgb 非常接近，也可能会相差 1（未论证）\r\n            const max = Math.max(r, g, b); // 取出 rgb 中的最大值\r\n            const min = max - this.latitude; // 允许的最小值\r\n            // 如果 rgb 三个数值与最大的数值相比，差距在宽容度之内，则检查通过\r\n            return [r, g, b].every((number) => {\r\n                return number >= min;\r\n            });\r\n        }\r\n    }\r\n}\r\nconst blackAndWhiteImage = new BlackAndWhiteImage();\r\nexport { blackAndWhiteImage };\r\n","import { API } from './API';\r\nimport { token } from './Token';\r\nimport { store } from './Store';\r\nimport { settings } from './setting/Settings';\r\nimport { lang } from './Lang';\r\nimport { EVT } from './EVT';\r\n// 当文件下载成功后，收藏这个作品\r\nclass BookmarkAfterDL {\r\n    constructor(tipEl) {\r\n        // 储存接收到的 id，用于防止对一个作品重复添加收藏\r\n        // 其实重复添加收藏没什么影响，和只添加一次没区别。为了不浪费网络请求，还是尽量不要重复添加。\r\n        this.savedIds = [];\r\n        this.successCount = 0;\r\n        this.tipEl = document.createElement('span');\r\n        if (tipEl) {\r\n            this.tipEl = tipEl;\r\n        }\r\n        this.bindEvents();\r\n    }\r\n    // 可选传入一个元素，显示收藏的数量和总数\r\n    bindEvents() {\r\n        // 当有文件下载完成时，提取 id\r\n        window.addEventListener(EVT.list.downloadSuccess, (ev) => {\r\n            const successData = ev.detail.data;\r\n            this.send(Number.parseInt(successData.id));\r\n        });\r\n        // 当开始新的抓取时重置状态和提示\r\n        window.addEventListener(EVT.list.crawlStart, (ev) => {\r\n            this.reset();\r\n            this.showProgress();\r\n        });\r\n    }\r\n    showProgress() {\r\n        if (this.savedIds.length === 0) {\r\n            return (this.tipEl.textContent = '');\r\n        }\r\n        this.tipEl.textContent = `${lang.transl('_已收藏')} ${this.successCount}/${this.savedIds.length}`;\r\n    }\r\n    reset() {\r\n        this.savedIds = [];\r\n        this.successCount = 0;\r\n    }\r\n    // 接收作品 id，开始收藏\r\n    send(id) {\r\n        if (!settings.bmkAfterDL) {\r\n            return;\r\n        }\r\n        if (typeof id !== 'number') {\r\n            id = Number.parseInt(id);\r\n        }\r\n        // 检查这个 id 是否已经添加了\r\n        if (this.savedIds.includes(id)) {\r\n            return;\r\n        }\r\n        this.addBookmark(id);\r\n    }\r\n    // 给所有作品添加收藏（之前收藏过的，新 tag 将覆盖旧 tag）\r\n    async addBookmark(id) {\r\n        return new Promise(async (resolve, reject) => {\r\n            this.savedIds.push(id);\r\n            this.showProgress();\r\n            // 从 store 里查找这个作品的数据\r\n            let data = undefined;\r\n            let dataSource = store.resultMeta.length > 0 ? store.resultMeta : store.result;\r\n            for (const r of dataSource) {\r\n                if (r.idNum === id) {\r\n                    data = r;\r\n                    break;\r\n                }\r\n            }\r\n            if (data === undefined) {\r\n                return reject(new Error(`Not find ${id} in result`));\r\n            }\r\n            await API.addBookmark(data.type !== 3 ? 'illusts' : 'novels', id.toString(), settings.widthTag === '1' ? data.tags : [], settings.restrict === '1', token.token).catch((err) => {\r\n                // 如果添加收藏失败，则从 id 列表里删除它，重新开始添加收藏\r\n                console.error(err);\r\n                const len = this.savedIds.length;\r\n                for (let index = 0; index < len; index++) {\r\n                    if (this.savedIds[index] === id) {\r\n                        delete this.savedIds[index];\r\n                        break;\r\n                    }\r\n                }\r\n                return resolve(this.send(id));\r\n            });\r\n            this.successCount++;\r\n            this.showProgress();\r\n            resolve();\r\n        });\r\n    }\r\n}\r\nexport { BookmarkAfterDL };\r\n","import { API } from './API';\r\nimport { token } from './Token';\r\nimport { lang } from './Lang';\r\nimport { settings } from './setting/Settings';\r\nimport { EVT } from './EVT';\r\nclass BookmarkAllWorks {\r\n    constructor(tipWrap) {\r\n        this.idList = [];\r\n        this.bookmarKData = [];\r\n        this.tipWrap = document.createElement('button');\r\n        if (tipWrap) {\r\n            this.tipWrap = tipWrap;\r\n        }\r\n    }\r\n    // 传递 workList，这是作品列表元素的合集。代码会尝试分析每个作品元素中的超链接，提取出作品 id\r\n    // 如果传递的作品是本页面上的作品，可以省略 type。代码会根据页面 url 判断是图片还是小说。\r\n    // 如果传递的作品不是本页面上的，为防止误判，需要显式传递 type\r\n    sendWorkList(list, type) {\r\n        this.reset();\r\n        if (type === undefined) {\r\n            type = window.location.pathname.includes('/novel') ? 'novels' : 'illusts';\r\n        }\r\n        const regExp = type === 'illusts' ? /\\/artworks\\/(\\d*)/ : /\\?id=(\\d*)/;\r\n        for (const el of list) {\r\n            const a = el.querySelector('a');\r\n            if (a) {\r\n                // \"https://www.pixiv.net/artworks/82618568\"\r\n                // \"https://www.pixiv.net/novel/show.php?id=12350618\"\r\n                const test = regExp.exec(a.href);\r\n                if (test && test.length > 1) {\r\n                    this.idList.push({\r\n                        type,\r\n                        id: test[1],\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        this.startBookmark();\r\n    }\r\n    // 直接传递 id 列表\r\n    sendIdList(list) {\r\n        this.reset();\r\n        this.idList = list;\r\n        this.startBookmark();\r\n    }\r\n    reset() {\r\n        this.idList = [];\r\n        this.bookmarKData = [];\r\n    }\r\n    // 启动收藏流程\r\n    async startBookmark() {\r\n        if (this.idList.length === 0) {\r\n            EVT.sendMsg({\r\n                msg: lang.transl('_没有数据可供使用'),\r\n                type: 'error',\r\n            });\r\n            return;\r\n        }\r\n        this.tipWrap.textContent = `Checking`;\r\n        this.tipWrap.setAttribute('disabled', 'disabled');\r\n        await this.getTagData();\r\n        await this.addBookmarkAll();\r\n        this.complete();\r\n    }\r\n    // 获取每个作品的 tag 数据\r\n    async getTagData() {\r\n        return new Promise(async (resolve) => {\r\n            for (const id of this.idList) {\r\n                this.tipWrap.textContent = `Get data ${this.bookmarKData.length} / ${this.idList.length}`;\r\n                let data;\r\n                if (id.type === 'novels') {\r\n                    data = await API.getNovelData(id.id);\r\n                }\r\n                else {\r\n                    data = await API.getArtworkData(id.id);\r\n                }\r\n                const tagArr = data.body.tags.tags; // 取出 tag 信息\r\n                const tags = []; // 保存 tag 列表\r\n                for (const tagData of tagArr) {\r\n                    tags.push(tagData.tag);\r\n                }\r\n                this.bookmarKData.push({\r\n                    type: id.type,\r\n                    id: data.body.id,\r\n                    tags: tags,\r\n                    restrict: false,\r\n                });\r\n            }\r\n            resolve();\r\n        });\r\n    }\r\n    // 给所有作品添加收藏（之前收藏过的，新 tag 将覆盖旧 tag）\r\n    async addBookmarkAll() {\r\n        return new Promise(async (resolve) => {\r\n            let index = 0;\r\n            for (const data of this.bookmarKData) {\r\n                this.tipWrap.textContent = `Add bookmark ${index} / ${this.bookmarKData.length}`;\r\n                await API.addBookmark(data.type, data.id, settings.widthTag === '1' ? data.tags : [], settings.restrict === '1', token.token);\r\n                index++;\r\n            }\r\n            resolve();\r\n        });\r\n    }\r\n    complete() {\r\n        this.tipWrap.textContent = `✓ Complete`;\r\n        this.tipWrap.removeAttribute('disabled');\r\n        EVT.fire(EVT.list.bookmarkModeEnd);\r\n    }\r\n}\r\nexport { BookmarkAllWorks };\r\n","import { API } from './API';\r\nimport { DOM } from './DOM';\r\nimport { token } from './Token';\r\n// 给收藏页面里的未分类作品批量添加 tag\r\nclass BookmarksAddTag {\r\n    constructor(btn) {\r\n        this.type = 'illusts'; // 页面是图片还是小说\r\n        this.addTagList = []; // 需要添加 tag 的作品的数据\r\n        this.once = 100; // 一次请求多少个作品的数据\r\n        this.btn = btn;\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        this.btn.addEventListener('click', () => {\r\n            this.addTagList = []; // 每次点击清空结果\r\n            this.btn.setAttribute('disabled', 'disabled');\r\n            this.btn.textContent = `Checking`;\r\n            if (window.location.pathname.includes('/novel')) {\r\n                this.type = 'novels';\r\n            }\r\n            this.readyAddTag();\r\n        });\r\n    }\r\n    // 准备添加 tag。loop 表示这是第几轮循环\r\n    async readyAddTag(loop = 0) {\r\n        const offset = loop * this.once; // 一次请求只能获取一部分，所以可能有多次请求，要计算偏移量\r\n        // 发起请求\r\n        const [showData, hideData] = await Promise.all([\r\n            API.getBookmarkData(DOM.getUserId(), this.type, '未分類', offset, false),\r\n            API.getBookmarkData(DOM.getUserId(), this.type, '未分類', offset, true),\r\n        ]).catch((error) => {\r\n            if (error.status && error.status === 403) {\r\n                this.btn.textContent = `× Permission denied`;\r\n            }\r\n            throw new Error('Permission denied');\r\n        });\r\n        // 保存有用的数据\r\n        for (const data of [showData, hideData]) {\r\n            const works = data.body.works;\r\n            // 如果作品的 bookmarkData 为假说明没有实际数据，可能是在获取别人的收藏数据。\r\n            if (works.length > 0 && works[0].bookmarkData) {\r\n                works.forEach((work) => {\r\n                    this.addTagList.push({\r\n                        id: work.id,\r\n                        tags: work.tags,\r\n                        restrict: work.bookmarkData.private,\r\n                    });\r\n                });\r\n            }\r\n        }\r\n        // 已删除或无法访问的作品不会出现在请求结果里。本来一次请求 100 个，但返回的结果有可能会比 100 个少，甚至极端情况下是 0。所以实际获取到的作品可能比  total 数量少，这是正常的。\r\n        // 判断是否请求了所有未分类的作品数据\r\n        const total = offset + this.once;\r\n        if (total >= showData.body.total && total >= hideData.body.total) {\r\n            if (this.addTagList.length === 0) {\r\n                // 如果结果为空，不需要处理\r\n                this.btn.textContent = `✓ No need`;\r\n                this.btn.removeAttribute('disabled');\r\n                return;\r\n            }\r\n            else {\r\n                // 开始添加 tag\r\n                this.addTag(0, this.addTagList, token.token);\r\n            }\r\n        }\r\n        else {\r\n            // 需要继续获取\r\n            this.readyAddTag(++loop);\r\n        }\r\n    }\r\n    // 给未分类作品添加 tag\r\n    async addTag(index, addList, tt) {\r\n        const item = addList[index];\r\n        await API.addBookmark(this.type, item.id, item.tags, item.restrict, tt);\r\n        if (index < addList.length - 1) {\r\n            index++;\r\n            this.btn.textContent = `${index} / ${addList.length}`;\r\n            // 继续添加下一个\r\n            return this.addTag(index, addList, tt);\r\n        }\r\n        else {\r\n            this.btn.textContent = `✓ Complete`;\r\n            this.btn.removeAttribute('disabled');\r\n        }\r\n    }\r\n}\r\nexport { BookmarksAddTag };\r\n","import { lang } from './Lang';\r\nimport { EVT } from './EVT';\r\nimport { DOM } from './DOM';\r\nimport { states } from './States';\r\nimport { theme } from './Theme';\r\n// 中间面板\r\nclass CenterPanel {\r\n    constructor() {\r\n        this.updateActiveClass = 'updateActiveClass';\r\n        this.addCenterPanel();\r\n        theme.register(this.centerPanel);\r\n        this.bindEvents();\r\n    }\r\n    // 添加中间面板\r\n    addCenterPanel() {\r\n        const centerPanelHTML = `\n      <div class=\"centerWrap beautify_scrollbar\">\n      <div class=\"centerWrap_head\">\n      <div class=\"centerWrap_title blue\">\n      Powerful Pixiv Downloader\n      <div class=\"btns\">\n      <a class=\"has_tip centerWrap_top_btn update\" data-tip=\"${lang.transl('_newver')}\" href=\"https://github.com/xuejianxianzun/PixivBatchDownloader/releases/latest\" target=\"_blank\">\n      <svg t=\"1574401457339\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4736\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"16\" height=\"16\"><defs><style type=\"text/css\"></style></defs><path d=\"M894.72 795.477333l-85.418667-85.418667c0.128-0.170667 0.170667-0.341333 0.298667-0.512l-158.890667-158.890667c0.042667-0.597333 37.248-37.248 37.248-37.248l178.773333 0 1.706667-1.493333c-0.853333-196.736-160.426667-356.053333-357.418667-356.053333-72.704 0-140.202667 22.016-196.650667 59.306667L228.949333 129.664C307.968 71.466667 405.333333 36.650667 511.018667 36.650667c263.296 0 476.757333 213.461333 476.757333 476.714667C987.776 619.093333 952.96 716.416 894.72 795.477333zM369.493333 476.117333c-0.042667 0.597333-37.248 37.248-37.248 37.248l-178.773333 0c0 197.461333 160.085333 357.546667 357.546667 357.546667 72.192 0 139.093333-21.76 195.285333-58.538667l85.589333 85.589333c-78.848 57.685333-175.701333 92.117333-280.874667 92.117333-263.296 0-476.757333-213.461333-476.757333-476.757333 0-105.173333 34.474667-202.069333 92.16-280.874667l85.589333 85.589333C211.925333 318.208 211.882667 318.336 211.797333 318.464L369.493333 476.117333z\" p-id=\"4737\"></path></svg>\n      </a>\n      <a class=\"has_tip centerWrap_top_btn\" data-tip=\"${lang.transl('_github')}\" href=\"https://github.com/xuejianxianzun/PixivBatchDownloader\" target=\"_blank\">\n      <svg t=\"1574401005111\" class=\"icon\" widht=\"16\" height=\"16\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"2594\" xmlns:xlink=\"http://www.w3.org/1999/xlink><defs><style type=\"text/css\"></style></defs><path d=\"M0 520.886c0-69.368 13.51-135.697 40.498-199.02 26.987-63.323 63.322-117.826 109.006-163.51 45.65-45.65 100.154-81.985 163.51-109.006A502.289 502.289 0 0 1 512 8.92c69.335 0 135.663 13.477 198.986 40.497 63.356 26.988 117.86 63.323 163.51 109.007 45.684 45.65 82.02 100.154 109.006 163.51A502.289 502.289 0 0 1 1024 520.852c0 111.318-32.504 211.472-97.511 300.494-64.975 88.989-148.48 150.825-250.484 185.476-5.351 0-9.348-0.99-11.99-2.973-2.676-1.982-4.196-3.997-4.526-6.012a59.458 59.458 0 0 1-0.495-8.984 7.663 7.663 0 0 1-0.991-3.006v-128.99c0-40.63-14.336-75.314-43.008-103.986 76.667-13.345 134.011-41.819 171.999-85.487 37.987-43.669 57.013-96.52 57.013-158.522 0-58.005-18.663-108.346-56.022-150.99 13.345-42.678 11-87.668-6.97-135.003-18.697-1.322-39.011 1.85-61.01 9.513-22 7.663-38.318 14.831-49.02 21.47-10.637 6.673-20.316 13.016-28.97 19.027-38.68-10.669-81.854-16.02-129.486-16.02-47.7 0-90.509 5.351-128.529 16.02-7.333-5.35-15.855-11.164-25.5-17.507-9.68-6.342-26.493-14.005-50.507-22.99-23.982-9.018-45.65-12.85-65.008-11.495-18.663 47.996-20.645 93.646-5.979 136.984-36.665 42.678-54.998 92.986-54.998 150.99 0 62.002 18.663 114.689 55.99 157.994 37.326 43.339 94.67 72.01 171.998 86.016a142.303 142.303 0 0 0-39.969 70.029c-56.683 13.972-96.355 3.963-119.015-30.06-42.017-61.308-79.674-83.307-113.003-65.965-4.69 4.657-3.997 9.48 1.982 14.501 6.012 4.988 14.996 11.66 27.02 19.985 11.99 8.357 20.976 17.507 26.987 27.515 0.661 1.322 2.51 6.177 5.517 14.502a831.917 831.917 0 0 0 8.985 23.981c2.973 7.663 8.654 16.186 17.011 25.5 8.324 9.349 18.003 17.178 29.003 23.52 11 6.309 26.161 11 45.485 14.006 19.324 2.972 41.323 3.138 65.998 0.495v100.484c0 0.991-0.165 2.643-0.495 5.021-0.33 2.312-0.991 3.964-1.982 4.955-0.991 1.024-2.345 2.015-4.03 3.039a12.52 12.52 0 0 1-6.474 1.486c-2.676 0-6.012-0.33-10.009-0.99-101.343-35.345-183.825-97.182-247.51-185.51C31.842 731.037 0 631.577 0 520.92z\" p-id=\"2595\"></path></svg>\n      </a>\n      <a class=\"has_tip centerWrap_top_btn wiki_url\" data-tip=\"${lang.transl('_wiki')}\" href=\"https://xuejianxianzun.github.io/PBDWiki\" target=\"_blank\">\n      <svg t=\"1574400169015\" class=\"icon\" widht=\"16\" height=\"16\" viewBox=\"0 0 1088 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"1872\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"17\" height=\"16\"><defs><style type=\"text/css\"></style></defs><path d=\"M1044.286732 3.51978A1138.616836 1138.616836 0 0 0 618.841322 58.172364a198.963565 198.963565 0 0 0-26.814324 10.815324V1023.936004l0.895944-0.383976a979.52278 979.52278 0 0 1 443.236298-68.411724 47.741016 47.741016 0 0 0 51.580776-43.261296V50.172864a47.165052 47.165052 0 0 0-43.453284-46.653084z m-74.299356 632.15249h-224.369977V541.470158h224.369977v94.202112z m0-231.921504h-224.369977V309.484657h224.369977v94.266109zM469.154678 58.172364A1138.296856 1138.296856 0 0 0 43.645272 3.455784 47.421036 47.421036 0 0 0 0 50.172864V908.103244a46.653084 46.653084 0 0 0 15.35904 34.493844 48.060996 48.060996 0 0 0 36.285732 12.415224 980.610712 980.610712 0 0 1 443.300294 68.347728l0.895944 0.575964V68.7957a202.099369 202.099369 0 0 0-26.686332-10.751328zM351.146053 635.800262H126.776076V541.59815h224.369977v94.202112z m0-231.921504H126.776076V309.612649h224.369977v94.266109z\" p-id=\"1873\"></path></svg>\n      </a>\n        <div class=\"has_tip centerWrap_top_btn centerWrap_close\" data-tip=\"${lang.transl('_快捷键切换显示隐藏')}\">\n        <svg t=\"1574392276519\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"1123\" data-spm-anchor-id=\"a313x.7781069.0.i0\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"14\" height=\"14\"><defs><style type=\"text/css\"></style></defs><path d=\"M521.693867 449.297067L111.4112 39.0144a51.2 51.2 0 1 0-72.430933 72.362667l410.282666 410.3168-410.282666 410.3168a51.2 51.2 0 1 0 72.3968 72.3968l410.3168-410.282667 410.3168 410.282667a51.2 51.2 0 1 0 72.3968-72.362667l-410.282667-410.350933 410.282667-410.282667a51.2 51.2 0 1 0-72.3968-72.3968l-410.282667 410.282667z\" p-id=\"1124\"></path></svg>\n        </div>\n      </div>\n      </div>\n      </div>\n\n      <div class=\"centerWrap_con\">\n      <slot data-name=\"form\"></slot>\n      </div>\n\n      <div class=\"gray1 bottom_help_bar\"> \n      <button class=\"textButton gray1 showDownTip\" type=\"button\">${lang.transl('_常见问题')}</button>\n      <a class=\"gray1\" href=\"https://xuejianxianzun.github.io/PBDWiki\" target=\"_blank\"> ${lang.transl('_wiki')}</a>\n      <a class=\"gray1\" href=\"https://github.com/xuejianxianzun/PixivFanboxDownloader\" target=\"_blank\"> ${lang.transl('_fanboxDownloader')}</a>\n      <a id=\"zanzhu\" class=\"gray1 patronText\" href=\"https://afdian.net/@xuejianxianzun\" target=\"_blank\">在“爱发电”支持我</a>\n      <a id=\"patreon\" class=\"gray1 patronText\" href=\"https://www.patreon.com/xuejianxianzun\" target=\"_blank\">Become a patron</a>\n      <a class=\"gray1\" href=\"https://discord.gg/eW9JtTK\" target=\"_blank\">Discord</a>\n      <br>\n      <p class=\"downTip tip\"> ${lang.transl('_下载说明')}</p>\n      </div>\n\n      </div>\n      `;\r\n        document.body.insertAdjacentHTML('beforeend', centerPanelHTML);\r\n        this.centerPanel = document.querySelector('.centerWrap');\r\n        this.updateLink = this.centerPanel.querySelector('.update');\r\n        const donateId = lang.flag === 0 ? 'zanzhu' : 'patreon';\r\n        document.getElementById(donateId).style.display = 'inline-block';\r\n    }\r\n    bindEvents() {\r\n        // 监听点击扩展图标的消息，开关中间面板\r\n        chrome.runtime.onMessage.addListener((msg) => {\r\n            if (msg.msg === 'click_icon') {\r\n                this.toggle();\r\n            }\r\n        });\r\n        // 使用快捷键 Alt + x 切换中间面板显示隐藏\r\n        window.addEventListener('keydown', (ev) => {\r\n            if (ev.altKey && ev.code === 'KeyX') {\r\n                this.toggle();\r\n            }\r\n        }, false);\r\n        // 关闭按钮\r\n        document\r\n            .querySelector('.centerWrap_close')\r\n            .addEventListener('click', () => {\r\n            EVT.fire(EVT.list.closeCenterPanel);\r\n        });\r\n        // 开始抓取作品时，隐藏\r\n        window.addEventListener(EVT.list.crawlStart, () => {\r\n            EVT.fire(EVT.list.closeCenterPanel);\r\n        });\r\n        // 抓取完作品详细数据时，显示\r\n        for (const ev of [EVT.list.crawlFinish, EVT.list.resume]) {\r\n            window.addEventListener(ev, () => {\r\n                if (!states.quickDownload) {\r\n                    this.show();\r\n                }\r\n            });\r\n        }\r\n        window.addEventListener(EVT.list.openCenterPanel, () => {\r\n            this.show();\r\n        });\r\n        window.addEventListener(EVT.list.closeCenterPanel, () => {\r\n            this.close();\r\n        });\r\n        // 显示更新按钮\r\n        window.addEventListener(EVT.list.hasNewVer, () => {\r\n            this.updateLink.classList.add(this.updateActiveClass);\r\n            this.updateLink.style.display = 'inline-block';\r\n        });\r\n        // 显示常见问题\r\n        this.centerPanel\r\n            .querySelector('.showDownTip')\r\n            .addEventListener('click', () => DOM.toggleEl(this.centerPanel.querySelector('.downTip')));\r\n        this.centerPanel.addEventListener('click', (e) => {\r\n            const ev = e || window.event;\r\n            ev.stopPropagation();\r\n        });\r\n        document.addEventListener('click', () => {\r\n            if (getComputedStyle(this.centerPanel)['display'] !== 'none') {\r\n                EVT.fire(EVT.list.closeCenterPanel);\r\n            }\r\n        });\r\n    }\r\n    // 显示中间区域\r\n    show() {\r\n        this.centerPanel.style.display = 'block';\r\n        EVT.fire(EVT.list.centerPanelOpened);\r\n    }\r\n    // 隐藏中间区域\r\n    close() {\r\n        this.centerPanel.style.display = 'none';\r\n        EVT.fire(EVT.list.centerPanelClosed);\r\n    }\r\n    toggle() {\r\n        const nowDisplay = this.centerPanel.style.display;\r\n        nowDisplay === 'block' ? this.close() : this.show();\r\n        if (nowDisplay === 'block') {\r\n            EVT.fire(EVT.list.closeCenterPanel);\r\n        }\r\n        else {\r\n            EVT.fire(EVT.list.openCenterPanel);\r\n        }\r\n    }\r\n}\r\nnew CenterPanel();\r\n","import { EVT } from './EVT';\r\n// 检查新版本\r\nclass CheckNew {\r\n    constructor() {\r\n        this.checkNew();\r\n    }\r\n    async checkNew() {\r\n        // 读取上一次检查的时间，如果超过指定的时间，则检查 GitHub 上的信息\r\n        const timeName = 'xzUpdateTime';\r\n        const verName = 'xzGithubVer';\r\n        const interval = 1000 * 60 * 30; // 30 分钟检查一次\r\n        const lastTime = localStorage.getItem(timeName);\r\n        if (!lastTime || new Date().getTime() - parseInt(lastTime) > interval) {\r\n            // 获取最新的 releases 信息\r\n            const latest = await fetch('https://api.github.com/repos/xuejianxianzun/PixivBatchDownloader/releases/latest');\r\n            const latestJson = await latest.json();\r\n            const latestVer = latestJson.name;\r\n            // 保存 GitHub 上的版本信息\r\n            localStorage.setItem(verName, latestVer);\r\n            // 保存本次检查的时间戳\r\n            localStorage.setItem(timeName, new Date().getTime().toString());\r\n        }\r\n        // 获取本地扩展的版本号\r\n        const manifest = await fetch(chrome.extension.getURL('manifest.json'));\r\n        const manifestJson = await manifest.json();\r\n        const manifestVer = manifestJson.version;\r\n        // 比较大小\r\n        const latestVer = localStorage.getItem(verName);\r\n        if (latestVer && manifestVer < latestVer) {\r\n            EVT.fire(EVT.list.hasNewVer);\r\n        }\r\n    }\r\n}\r\nnew CheckNew();\r\n","const Colors = {\r\n    blue: '#0ea8ef',\r\n    green: '#14ad27',\r\n    red: '#f33939',\r\n    yellow: '#e49d00',\r\n    success: '#00ca19',\r\n    warning: '#d27e00',\r\n    error: '#f00',\r\n};\r\nexport { Colors };\r\n","// 储存一些配置。修改这些配置会影响本程序的运行。\r\nexport default {\r\n    outputMax: 5000,\r\n    downloadThreadMax: 10,\r\n    illustTypes: ['illustration', 'manga', 'ugoira', 'novel'],\r\n};\r\n","// DOM 操作类\r\n// 保存公用的 DOM 操作方法，以及从 DOM 中获取数据的 API\r\nclass DOM {\r\n    // 获取指定元素里，可见的结果\r\n    static getVisibleEl(selector) {\r\n        const list = document.querySelectorAll(selector);\r\n        return Array.from(list).filter((el) => {\r\n            return el.style.display !== 'none';\r\n        });\r\n    }\r\n    // 删除 DOM 元素\r\n    static removeEl(el) {\r\n        if (!el) {\r\n            return;\r\n        }\r\n        if (Reflect.has(el, 'length')) {\r\n            // 如果有 length 属性则循环删除。\r\n            ;\r\n            el.forEach((el) => {\r\n                if (el.parentNode) {\r\n                    el.parentNode.removeChild(el);\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            // 没有 length 属性的直接删除（querySelector 的返回值是 HTMLElement）\r\n            const parent = el.parentNode;\r\n            if (parent) {\r\n                parent.removeChild(el);\r\n            }\r\n        }\r\n    }\r\n    // 切换 DOM 元素的可见性\r\n    static toggleEl(el) {\r\n        el.style.display = el.style.display === 'block' ? 'none' : 'block';\r\n    }\r\n    // 将元素插入到页面顶部\r\n    /*\r\n    newindex-inner 是在未登录时的用户作品列表页面使用的\r\n    layout-body 是在未登录时的搜索页使用的\r\n    */\r\n    static insertToHead(el) {\r\n        if (document.body) {\r\n            document.body.insertAdjacentElement('afterbegin', el);\r\n        }\r\n        else {\r\n            ;\r\n            (document.querySelector('.newindex-inner') ||\r\n                document.querySelector('.layout-body')).insertAdjacentElement('beforebegin', el);\r\n        }\r\n        return el;\r\n    }\r\n    // 动态添加 css 样式\r\n    static addStyle(css) {\r\n        const e = document.createElement('style');\r\n        e.innerHTML = css;\r\n        document.body.append(e);\r\n    }\r\n    // 通过创建 a 标签来下载文件\r\n    static downloadFile(url, fileName) {\r\n        const a = document.createElement('a');\r\n        a.href = url;\r\n        a.download = fileName;\r\n        a.click();\r\n    }\r\n    // 获取用户 id\r\n    // 这是一个不够可靠的 api\r\n    // 测试：在 https://www.pixiv.net/artworks/79399027 获取 userid ，正确的结果应该是 13895186\r\n    static getUserId() {\r\n        const newRegExp = /\\/users\\/(\\d+)/; // 获取 /users/ 后面连续的数字部分，也就是用户的 id\r\n        // 列表页里从 url 中获取\r\n        const test4 = newRegExp.exec(location.pathname);\r\n        if (!!test4 && test4.length > 1 && !!test4[1]) {\r\n            return test4[1];\r\n        }\r\n        // 获取包含用户 id 的元素，注意这些选择器可能会变，需要进行检查\r\n        const testA = document.querySelector('.sc-LzOjP a') ||\r\n            document.querySelector('aside a') ||\r\n            document.querySelector('nav a');\r\n        // 第一个元素是作品页内，作品下方的作者头像区域的 a 标签\r\n        // 第一个元素是作品页内，页面右侧作者信息区域的 a 标签\r\n        // 第二个元素是用户主页或列表页里，“主页”按钮的 a 标签\r\n        if (testA && testA.href) {\r\n            const test5 = newRegExp.exec(testA.href);\r\n            if (!!test5 && test5.length > 1 && !!test5[1]) {\r\n                return test5[1];\r\n            }\r\n        }\r\n        // 从旧版页面的 head 元素的 script 脚本内容里匹配这一部分\r\n        // pixiv.context.user.id = \"<userid>\"\r\n        const test1 = /user.id = \"(\\d*)\"/.exec(document.head.innerHTML);\r\n        if (test1 && test1.length > 0) {\r\n            return test1[1];\r\n        }\r\n        // 从旧版页面的 head 元素的 script 脚本内容里匹配这一部分\r\n        // pixiv.context.userId = \"<userid>\"\r\n        const test2 = /userId = \"(\\d*)\"/.exec(document.head.innerHTML);\r\n        if (test2 && test2.length > 0) {\r\n            return test2[1];\r\n        }\r\n        // 最后从 body 里匹配\r\n        // Warning ：这有可能会匹配到错误的（其他）用户 id！\r\n        const test3 = newRegExp.exec(document.body.innerHTML);\r\n        if (test3) {\r\n            return test3[1];\r\n        }\r\n        // 如果都没有获取到\r\n        throw new Error('getUserId failed!');\r\n    }\r\n    // 寻找 slot，本程序使用的 slot 都要有 data-name 属性\r\n    static findSlot(name) {\r\n        const slot = document.querySelector(`slot[data-name=${name}]`);\r\n        if (!slot) {\r\n            throw new Error(`No such slot: ${name}`);\r\n        }\r\n        return slot;\r\n    }\r\n    // 使用指定的插槽\r\n    static useSlot(name, element) {\r\n        const slot = this.findSlot(name);\r\n        if (typeof element === 'string') {\r\n            // 插入字符串形式的元素\r\n            // 这里不直接使用 insertAdjacentElement 是为了可以返回生成的元素\r\n            const wrap = document.createElement('div');\r\n            wrap.innerHTML = element;\r\n            const el = wrap.children[0];\r\n            slot.appendChild(el);\r\n            return el;\r\n        }\r\n        else {\r\n            // 插入 html 元素\r\n            slot.appendChild(element);\r\n            return element;\r\n        }\r\n    }\r\n    // 清空指定的插槽\r\n    static clearSlot(name) {\r\n        this.findSlot(name).innerHTML = '';\r\n    }\r\n    static addBtn(slot, bg = '', text = '', attr = []) {\r\n        const e = document.createElement('button');\r\n        e.type = 'button';\r\n        e.style.backgroundColor = bg;\r\n        e.textContent = text;\r\n        for (const [key, value] of attr) {\r\n            e.setAttribute(key, value);\r\n        }\r\n        this.useSlot(slot, e);\r\n        return e;\r\n    }\r\n    static async loadImg(url) {\r\n        return new Promise((resolve, reject) => {\r\n            const img = new Image();\r\n            img.src = url;\r\n            img.onload = function () {\r\n                resolve(img);\r\n            };\r\n            img.onerror = () => {\r\n                reject(new Error(`Load image error! url: ${url}`));\r\n            };\r\n        });\r\n    }\r\n    static getTitle() {\r\n        // 从页面标题里删除 TitleBar 的标记，以及未读消息的计数（现在的 p 站似乎没有消息计数了）\r\n        return document.title\r\n            .replace(/\\[(↑|→|▶|↓|║|■|✓| )\\] /, '')\r\n            .replace(/^\\(\\d.*\\) /, '');\r\n    }\r\n    // 创建 input 元素选择 json 文件\r\n    static async loadJSONFile() {\r\n        return new Promise((resolve, reject) => {\r\n            const i = document.createElement('input');\r\n            i.setAttribute('type', 'file');\r\n            i.setAttribute('accept', 'application/json');\r\n            i.onchange = () => {\r\n                if (i.files && i.files.length > 0) {\r\n                    // 读取文件内容\r\n                    const file = new FileReader();\r\n                    file.readAsText(i.files[0]);\r\n                    file.onload = () => {\r\n                        const str = file.result;\r\n                        let result;\r\n                        try {\r\n                            result = JSON.parse(str);\r\n                            // if((result as any).constructor !== Object){\r\n                            // 允许是对象 {} 或者数组 []\r\n                            if (result === null || typeof result !== 'object') {\r\n                                const msg = 'Data is not an object!';\r\n                                return reject(new Error(msg));\r\n                            }\r\n                            return resolve(result);\r\n                        }\r\n                        catch (error) {\r\n                            const msg = 'JSON parse error!';\r\n                            return reject(new Error(msg));\r\n                        }\r\n                    };\r\n                }\r\n            };\r\n            i.click();\r\n        });\r\n    }\r\n}\r\nexport { DOM };\r\n","// 格式化日期（和时间）\r\nclass DateFormat {\r\n    // format 参数可以由以下格式组合：\r\n    /*\r\n    YYYY\r\n    YY\r\n    MM\r\n    MMM\r\n    MMMM\r\n    DD\r\n    hh\r\n    mm\r\n    ss\r\n    */\r\n    // 区分大小写；可以添加空格或其他符号；不要使用上面未包含的格式。\r\n    // 参考资料：\r\n    // https://www.w3.org/TR/NOTE-datetime\r\n    // https://en.wikipedia.org/wiki/Date_format_by_country\r\n    static format(date, format = 'YYYY-MM-DD') {\r\n        // 生成年、月、日、时、分、秒\r\n        const _date = new Date(date);\r\n        const YYYY = _date.getFullYear().toString();\r\n        const YY = YYYY.substring(YYYY.length - 2, YYYY.length);\r\n        const MM = (_date.getMonth() + 1).toString().padStart(2, '0');\r\n        const MMM = this.months[_date.getMonth()];\r\n        const MMMM = this.Months[_date.getMonth()];\r\n        const DD = _date.getDate().toString().padStart(2, '0');\r\n        const hh = _date.getHours().toString().padStart(2, '0');\r\n        const mm = _date.getMinutes().toString().padStart(2, '0');\r\n        const ss = _date.getSeconds().toString().padStart(2, '0');\r\n        // 对格式字符串进行替换\r\n        let r = format;\r\n        r = r.replace('YYYY', YYYY);\r\n        r = r.replace('YY', YY);\r\n        r = r.replace('MMMM', MMMM);\r\n        r = r.replace('MMM', MMM);\r\n        r = r.replace('MM', MM);\r\n        r = r.replace('DD', DD);\r\n        r = r.replace('hh', hh);\r\n        r = r.replace('mm', mm);\r\n        r = r.replace('ss', ss);\r\n        return r;\r\n    }\r\n}\r\nDateFormat.months = [\r\n    'Jan',\r\n    'Feb',\r\n    'Mar',\r\n    'Apr',\r\n    'May',\r\n    'Jun',\r\n    'Jul',\r\n    'Aug',\r\n    'Sept',\r\n    'Oct',\r\n    'Nov',\r\n    'Dec',\r\n];\r\nDateFormat.Months = [\r\n    'January',\r\n    'February',\r\n    'March',\r\n    'April',\r\n    'May',\r\n    'June',\r\n    'July',\r\n    'August',\r\n    'September',\r\n    'October',\r\n    'November',\r\n    'December',\r\n];\r\nexport { DateFormat };\r\n","import { API } from './API';\r\nimport { DOM } from './DOM';\r\nimport { EVT } from './EVT';\r\nimport { lang } from './Lang';\r\nimport { log } from './Log';\r\nimport { settings } from './setting/Settings';\r\nimport { IndexedDB } from './IndexedDB';\r\nimport { store } from './Store';\r\nimport { fileName } from './FileName';\r\n// 通过保存和查询下载记录，判断重复文件\r\nclass Deduplication {\r\n    constructor() {\r\n        this.DBName = 'DLRecord';\r\n        this.DBVer = 1;\r\n        this.storeNameList = [\r\n            'record1',\r\n            'record2',\r\n            'record3',\r\n            'record4',\r\n            'record5',\r\n            'record6',\r\n            'record7',\r\n            'record8',\r\n            'record9',\r\n        ]; // 表名的列表\r\n        this.skipIdList = []; // 被跳过下载的文件的 id。当收到下载成功事件时，根据这个 id 列表判断这个文件是不是真的被下载了。如果这个文件是被跳过的，则不保存到下载记录里。\r\n        this.existedIdList = []; // 检查文件是否重复时，会查询数据库。查询到的数据的 id 会保存到这个列表里。当向数据库添加记录时，可以先查询这个列表，如果已经有过记录就改为 put 而不是 add，因为添加主键重复的数据会报错\r\n        this.IDB = new IndexedDB();\r\n        this.init();\r\n    }\r\n    async init() {\r\n        await this.initDB();\r\n        this.bindEvents();\r\n        // this.exportTestFile(10)\r\n    }\r\n    // 初始化数据库，获取数据库对象\r\n    async initDB() {\r\n        // 在升级事件里创建表和索引\r\n        const onUpdate = (db) => {\r\n            for (const name of this.storeNameList) {\r\n                if (!db.objectStoreNames.contains(name)) {\r\n                    const store = db.createObjectStore(name, { keyPath: 'id' });\r\n                    store.createIndex('id', 'id', { unique: true });\r\n                }\r\n            }\r\n        };\r\n        return new Promise(async (resolve, reject) => {\r\n            resolve(await this.IDB.open(this.DBName, this.DBVer, onUpdate));\r\n        });\r\n    }\r\n    bindEvents() {\r\n        // 当有文件被跳过时，保存到 skipIdList\r\n        window.addEventListener(EVT.list.skipDownload, (ev) => {\r\n            const data = ev.detail.data;\r\n            this.skipIdList.push(data.id);\r\n        });\r\n        // 当有文件下载完成时，存储这个任务的记录\r\n        window.addEventListener(EVT.list.downloadSuccess, (ev) => {\r\n            const successData = ev.detail.data;\r\n            this.add(successData.id);\r\n        });\r\n        [EVT.list.crawlFinish, EVT.list.downloadComplete].forEach((val) => {\r\n            window.addEventListener(val, () => {\r\n                this.skipIdList = [];\r\n            });\r\n        });\r\n        // 导入下载记录的按钮\r\n        {\r\n            const btn = document.querySelector('#importDownloadRecord');\r\n            if (btn) {\r\n                btn.addEventListener('click', () => {\r\n                    EVT.fire(EVT.list.importDownloadRecord);\r\n                });\r\n            }\r\n        }\r\n        // 监听导入下载记录的事件\r\n        window.addEventListener(EVT.list.importDownloadRecord, () => {\r\n            this.importRecord();\r\n        });\r\n        // 导出下载记录的按钮\r\n        {\r\n            const btn = document.querySelector('#exportDownloadRecord');\r\n            if (btn) {\r\n                btn.addEventListener('click', () => {\r\n                    EVT.fire(EVT.list.exportDownloadRecord);\r\n                });\r\n            }\r\n        }\r\n        // 监听导出下载记录的事件\r\n        window.addEventListener(EVT.list.exportDownloadRecord, () => {\r\n            this.exportRecord();\r\n        });\r\n        // 清空下载记录的按钮\r\n        {\r\n            const btn = document.querySelector('#clearDownloadRecord');\r\n            if (btn) {\r\n                btn.addEventListener('click', () => {\r\n                    EVT.fire(EVT.list.clearDownloadRecord);\r\n                });\r\n            }\r\n        }\r\n        // 监听清空下载记录的事件\r\n        window.addEventListener(EVT.list.clearDownloadRecord, () => {\r\n            this.clearRecords();\r\n            this.existedIdList = [];\r\n        });\r\n    }\r\n    // 当要查找或存储一个 id 时，返回它所对应的 storeName\r\n    getStoreName(id) {\r\n        const firstNum = parseInt(id[0]);\r\n        return this.storeNameList[firstNum - 1];\r\n    }\r\n    // 生成一个下载记录\r\n    createRecord(resultId) {\r\n        let name = settings.userSetName;\r\n        // 查找这个抓取结果，获取其文件名\r\n        for (const result of store.result) {\r\n            if (result.id === resultId) {\r\n                name = fileName.getFileName(result);\r\n                break;\r\n            }\r\n        }\r\n        return {\r\n            id: resultId,\r\n            n: name,\r\n        };\r\n    }\r\n    // 添加一条下载记录\r\n    async add(resultId) {\r\n        // 不储存被跳过下载的文件\r\n        if (this.skipIdList.includes(resultId)) {\r\n            return;\r\n        }\r\n        const storeName = this.getStoreName(resultId);\r\n        const data = this.createRecord(resultId);\r\n        if (this.existedIdList.includes(resultId)) {\r\n            this.IDB.put(storeName, data);\r\n        }\r\n        else {\r\n            // 先查询有没有这个记录\r\n            const result = await this.IDB.get(storeName, data.id);\r\n            const type = result ? 'put' : 'add';\r\n            this.IDB[type](storeName, data);\r\n        }\r\n    }\r\n    // 检查一个 id 是否是重复下载\r\n    // 返回值 true 表示重复，false 表示不重复\r\n    async check(resultId) {\r\n        if (location.hostname.includes('pixivision.net')) {\r\n            return false;\r\n        }\r\n        return new Promise(async (resolve, reject) => {\r\n            // 如果未启用去重，直接返回不重复\r\n            if (!settings.deduplication) {\r\n                return resolve(false);\r\n            }\r\n            // 在数据库进行查找\r\n            const storeNmae = this.getStoreName(resultId);\r\n            const data = (await this.IDB.get(storeNmae, resultId));\r\n            // 查询结果为空，返回不重复\r\n            if (data === null) {\r\n                return resolve(false);\r\n            }\r\n            else {\r\n                this.existedIdList.push(data.id);\r\n                // 查询到了对应的记录，根据策略进行判断\r\n                if (settings.dupliStrategy === 'loose') {\r\n                    // 如果是宽松策略（只考虑 id），返回重复\r\n                    return resolve(true);\r\n                }\r\n                else {\r\n                    // 如果是严格策略（同时考虑 id 和文件名），则比较文件名\r\n                    const record = this.createRecord(resultId);\r\n                    return resolve(record.n === data.n);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    // 清空下载记录\r\n    clearRecords() {\r\n        for (const name of this.storeNameList) {\r\n            this.IDB.clear(name);\r\n        }\r\n        EVT.sendMsg({\r\n            msg: lang.transl('_下载记录已清除'),\r\n            type: 'success',\r\n        });\r\n    }\r\n    // 导出下载记录\r\n    async exportRecord() {\r\n        let record = [];\r\n        for (const name of this.storeNameList) {\r\n            const r = (await this.IDB.getAll(name));\r\n            record = record.concat(r);\r\n        }\r\n        const str = JSON.stringify(record, null, 2);\r\n        const blob = new Blob([str], { type: 'application/json' });\r\n        const url = URL.createObjectURL(blob);\r\n        DOM.downloadFile(url, `record-${API.replaceUnsafeStr(new Date().toLocaleString())}.json`);\r\n    }\r\n    // 导入下载记录\r\n    async importRecord() {\r\n        const record = (await DOM.loadJSONFile().catch((err) => {\r\n            return EVT.sendMsg({\r\n                type: 'error',\r\n                msg: err,\r\n            });\r\n        }));\r\n        if (!record) {\r\n            return;\r\n        }\r\n        // 判断格式是否符合要求\r\n        if (Array.isArray(record) === false ||\r\n            record[0].id === undefined ||\r\n            record[0].n === undefined) {\r\n            const msg = 'Format error!';\r\n            return EVT.sendMsg({\r\n                msg: msg,\r\n                type: 'error',\r\n            });\r\n        }\r\n        // 开始导入\r\n        log.warning(lang.transl('_导入下载记录'));\r\n        let stored = 0;\r\n        let total = record.length;\r\n        let t = 0;\r\n        t = window.setInterval(() => {\r\n            log.log(`${stored}/${total}`, 1, false);\r\n            if (stored >= total) {\r\n                log.success(lang.transl('_完成'));\r\n                window.clearInterval(t);\r\n            }\r\n        }, 500);\r\n        // 依次处理每个存储库\r\n        for (let index = 0; index < this.storeNameList.length; index++) {\r\n            // 提取出要存入这个存储库的数据\r\n            const data = [];\r\n            for (const r of record) {\r\n                if (parseInt(r.id[0]) - 1 === index) {\r\n                    data.push(r);\r\n                }\r\n            }\r\n            // 批量添加数据\r\n            await this.IDB.batchAddData(this.storeNameList[index], data, 'id');\r\n            stored += data.length;\r\n        }\r\n        EVT.sendMsg({\r\n            msg: `${lang.transl('_导入下载记录')}<br>${lang.transl('_完成')}`,\r\n            type: 'success',\r\n        });\r\n        // 时间参考：导入 100000 条下载记录，花费的时间在 30 秒以内。但偶尔会有例外，中途像卡住了一样，很久没动，最后花了两分钟多的时间。\r\n    }\r\n    // 创建一个文件，模拟导出的下载记录\r\n    exportTestFile(number) {\r\n        let r = [];\r\n        for (let index = 1; index <= number; index++) {\r\n            r.push({\r\n                id: index.toString(),\r\n                n: index.toString(),\r\n            });\r\n        }\r\n        const str = JSON.stringify(r, null, 2);\r\n        const blob = new Blob([str], { type: 'application/json' });\r\n        const url = URL.createObjectURL(blob);\r\n        DOM.downloadFile(url, `record-test-${number}.json`);\r\n    }\r\n}\r\nconst deduplication = new Deduplication();\r\nexport { deduplication };\r\n","// 删除页面上的作品\r\nimport { log } from './Log';\r\nimport { lang } from './Lang';\r\nimport { Colors } from './Colors';\r\nimport { DOM } from './DOM';\r\nimport { states } from './States';\r\nimport { EVT } from './EVT';\r\nclass DeleteWorks {\r\n    constructor(worksSelectors) {\r\n        this.worksSelector = ''; // 选择页面上所有作品的选择器\r\n        this.multipleSelector = ''; // 多图作品特有的元素的标识\r\n        this.ugoiraSelector = ''; // 动图作品特有的元素的标识\r\n        this.delMode = false; // 是否处于删除作品状态\r\n        this.deleteWorkCallback = () => { }; // 保存手动删除作品的回调函数，因为可能会多次绑定手动删除事件，所以需要保存传入的 callback 备用\r\n        this.worksSelector = worksSelectors;\r\n        // 作品列表更新后，需要重新给作品绑定删除事件\r\n        window.addEventListener(EVT.list.worksUpdate, () => {\r\n            if (this.delMode) {\r\n                this.bindDeleteEvent();\r\n            }\r\n        });\r\n    }\r\n    // 清除多图作品的按钮\r\n    addClearMultipleBtn(selector, callback = () => { }) {\r\n        this.multipleSelector = selector;\r\n        DOM.addBtn('crawlBtns', Colors.red, lang.transl('_清除多图作品'), [\r\n            ['title', lang.transl('_清除多图作品Title')],\r\n        ]).addEventListener('click', () => {\r\n            if (states.busy) {\r\n                EVT.sendMsg({\r\n                    msg: lang.transl('_当前任务尚未完成'),\r\n                    type: 'error',\r\n                });\r\n                return;\r\n            }\r\n            EVT.fire(EVT.list.closeCenterPanel);\r\n            this.clearMultiple();\r\n            callback();\r\n        }, false);\r\n    }\r\n    // 清除动图作品的按钮\r\n    addClearUgoiraBtn(selector, callback = () => { }) {\r\n        this.ugoiraSelector = selector;\r\n        DOM.addBtn('crawlBtns', Colors.red, lang.transl('_清除动图作品'), [\r\n            ['title', lang.transl('_清除动图作品Title')],\r\n        ]).addEventListener('click', () => {\r\n            if (states.busy) {\r\n                EVT.sendMsg({\r\n                    msg: lang.transl('_当前任务尚未完成'),\r\n                    type: 'error',\r\n                });\r\n                return;\r\n            }\r\n            EVT.fire(EVT.list.closeCenterPanel);\r\n            this.ClearUgoira();\r\n            callback();\r\n        }, false);\r\n    }\r\n    // 手动删除作品的按钮\r\n    addManuallyDeleteBtn(callback = () => { }) {\r\n        this.deleteWorkCallback = callback;\r\n        const delBtn = DOM.addBtn('crawlBtns', Colors.red, lang.transl('_手动删除作品'), [['title', lang.transl('_手动删除作品Title')]]);\r\n        delBtn.addEventListener('click', () => {\r\n            this.delMode = !this.delMode;\r\n            this.bindDeleteEvent();\r\n            if (this.delMode) {\r\n                delBtn.textContent = lang.transl('_退出手动删除');\r\n                setTimeout(() => {\r\n                    EVT.fire(EVT.list.closeCenterPanel);\r\n                }, 100);\r\n            }\r\n            else {\r\n                delBtn.textContent = lang.transl('_手动删除作品');\r\n            }\r\n        });\r\n    }\r\n    // 清除多图作品\r\n    clearMultiple() {\r\n        const allPicArea = document.querySelectorAll(this.worksSelector);\r\n        allPicArea.forEach((el) => {\r\n            if (el.querySelector(this.multipleSelector)) {\r\n                el.remove();\r\n            }\r\n        });\r\n        this.showWorksCount();\r\n    }\r\n    // 清除动图作品\r\n    ClearUgoira() {\r\n        const allPicArea = document.querySelectorAll(this.worksSelector);\r\n        allPicArea.forEach((el) => {\r\n            if (el.querySelector(this.ugoiraSelector)) {\r\n                el.remove();\r\n            }\r\n        });\r\n        this.showWorksCount();\r\n    }\r\n    // 给作品绑定手动删除事件\r\n    // 删除作品后，回调函数可以接收到被删除的元素\r\n    bindDeleteEvent() {\r\n        const listElement = document.querySelectorAll(this.worksSelector);\r\n        listElement.forEach((el) => {\r\n            el.onclick = (ev) => {\r\n                if (this.delMode) {\r\n                    ev.preventDefault();\r\n                    if (states.busy) {\r\n                        EVT.sendMsg({\r\n                            msg: lang.transl('_当前任务尚未完成'),\r\n                            type: 'error',\r\n                        });\r\n                        return;\r\n                    }\r\n                    const target = ev.currentTarget;\r\n                    DOM.removeEl(target);\r\n                    this.showWorksCount();\r\n                    this.deleteWorkCallback(target);\r\n                }\r\n            };\r\n        });\r\n    }\r\n    // 显示调整后，列表里的作品数量\r\n    showWorksCount() {\r\n        const selector = this.worksSelector;\r\n        log.success(lang.transl('_调整完毕', DOM.getVisibleEl(selector).length.toString()), 2, false);\r\n    }\r\n}\r\nexport { DeleteWorks };\r\n","// 下载文件，并发送给浏览器下载\r\nimport { EVT } from './EVT';\r\nimport { log } from './Log';\r\nimport { lang } from './Lang';\r\nimport { DOM } from './DOM';\r\nimport { fileName } from './FileName';\r\nimport { converter } from './ugoira/ConvertUgoira';\r\nimport { progressBar } from './ProgressBar';\r\nimport { filter } from './Filter';\r\nimport { deduplication } from './Deduplication';\r\nimport { settings } from './setting/Settings';\r\nclass Download {\r\n    constructor(progressBarIndex, data) {\r\n        this.fileName = '';\r\n        this.retryMax = 30;\r\n        this.retry = 0; // 重试次数\r\n        this.cancel = false; // 这个下载是否被取消（下载被停止，或者这个文件没有通过某个检查）\r\n        this.sizeChecked = false; // 是否对文件体积进行了检查\r\n        this.progressBarIndex = progressBarIndex;\r\n        this.download(data);\r\n        this.listenEvents();\r\n    }\r\n    listenEvents() {\r\n        ;\r\n        [EVT.list.downloadStop, EVT.list.downloadPause].forEach((event) => {\r\n            window.addEventListener(event, () => {\r\n                this.cancel = true;\r\n            });\r\n        });\r\n    }\r\n    // 设置进度条信息\r\n    setProgressBar(loaded, total) {\r\n        progressBar.setProgress(this.progressBarIndex, {\r\n            name: this.fileName,\r\n            loaded: loaded,\r\n            total: total,\r\n        });\r\n    }\r\n    skip(data, msg = '') {\r\n        this.cancel = true;\r\n        log.warning(msg);\r\n        EVT.fire(EVT.list.skipDownload, data);\r\n    }\r\n    // 下载文件\r\n    async download(arg) {\r\n        // 检查是否是重复文件\r\n        const duplicate = await deduplication.check(arg.id);\r\n        if (duplicate) {\r\n            return this.skip({\r\n                url: '',\r\n                id: arg.id,\r\n                tabId: 0,\r\n                uuid: false,\r\n            }, lang.transl('_跳过下载因为重复文件', arg.id));\r\n        }\r\n        // 获取文件名\r\n        this.fileName = fileName.getFileName(arg.data);\r\n        // 重设当前下载栏的信息\r\n        this.setProgressBar(0, 0);\r\n        // 下载文件\r\n        let url;\r\n        if (arg.data.type === 3) {\r\n            url = arg.data.original;\r\n        }\r\n        else {\r\n            url = arg.data[settings.imageSize] || arg.data.original;\r\n        }\r\n        let xhr = new XMLHttpRequest();\r\n        xhr.open('GET', url, true);\r\n        xhr.responseType = 'blob';\r\n        // 显示下载进度\r\n        xhr.addEventListener('progress', async (event) => {\r\n            // 检查体积设置\r\n            if (!this.sizeChecked) {\r\n                this.sizeChecked = true;\r\n                const result = await filter.check({ size: event.total });\r\n                if (!result) {\r\n                    // 当因为体积问题跳过下载时，可能这个下载进度还是 0 或者很少，所以这里直接把进度条拉满\r\n                    this.setProgressBar(1, 1);\r\n                    this.skip({\r\n                        url: '',\r\n                        id: arg.id,\r\n                        tabId: 0,\r\n                        uuid: false,\r\n                    }, lang.transl('_不保存图片因为体积', arg.id));\r\n                }\r\n            }\r\n            if (this.cancel) {\r\n                xhr.abort();\r\n                xhr = null;\r\n                return;\r\n            }\r\n            this.setProgressBar(event.loaded, event.total);\r\n        });\r\n        // 图片获取完毕（出错时也会进入 loadend）\r\n        xhr.addEventListener('loadend', async () => {\r\n            if (this.cancel) {\r\n                xhr = null;\r\n                return;\r\n            }\r\n            let file = xhr.response; // 要下载的文件\r\n            // 错误处理\r\n            const downloadError = () => {\r\n                let msg = '';\r\n                if (xhr.status === 404) {\r\n                    // 404 错误时\r\n                    msg = lang.transl('_file404', arg.id);\r\n                }\r\n                else {\r\n                    // 无法处理的错误状态\r\n                    msg = lang.transl('_文件下载失败', arg.id);\r\n                }\r\n                // 超过重试次数的话，这个下载会被暂时跳过。但最后还是会尝试重新下载它，所以这里不输出错误信息。\r\n                // log.error(msg, 1)\r\n                this.cancel = true;\r\n                EVT.fire(EVT.list.downloadError, arg.id);\r\n            };\r\n            if (xhr.status !== 200) {\r\n                // 状态码错误\r\n                // 正常下载完毕的状态码是 200\r\n                // 处理小说恢复后下载出错的问题，重新生成小说的 url\r\n                if (arg.data.type === 3 && xhr.status === 0) {\r\n                    arg.data.original = URL.createObjectURL(arg.data.novelBlob);\r\n                    return this.download(arg);\r\n                }\r\n                // 进入重试环节\r\n                progressBar.showErrorColor(this.progressBarIndex, true);\r\n                this.retry++;\r\n                if (this.retry >= this.retryMax) {\r\n                    // 重试 retryMax 次依然错误\r\n                    // console.log(arg.data.id + ' retryMax')\r\n                    downloadError();\r\n                }\r\n                else {\r\n                    return this.download(arg);\r\n                }\r\n            }\r\n            else {\r\n                // 状态码正常\r\n                progressBar.showErrorColor(this.progressBarIndex, false);\r\n                // 需要转换动图的情况\r\n                const convertExt = ['webm', 'gif', 'png'];\r\n                if (convertExt.includes(arg.data.ext) && arg.data.ugoiraInfo) {\r\n                    try {\r\n                        if (arg.data.ext === 'webm') {\r\n                            file = await converter.webm(file, arg.data.ugoiraInfo);\r\n                        }\r\n                        if (arg.data.ext === 'gif') {\r\n                            file = await converter.gif(file, arg.data.ugoiraInfo);\r\n                        }\r\n                        if (arg.data.ext === 'png') {\r\n                            file = await converter.apng(file, arg.data.ugoiraInfo);\r\n                        }\r\n                    }\r\n                    catch (error) {\r\n                        const msg = `Convert ugoira error, id ${arg.data.idNum}.`;\r\n                        // 因为会重试所以不再日志上显示\r\n                        // log.error(msg, 1)\r\n                        console.error(msg);\r\n                        this.cancel = true;\r\n                        EVT.fire(EVT.list.downloadError, arg.id);\r\n                    }\r\n                }\r\n            }\r\n            if (this.cancel) {\r\n                return;\r\n            }\r\n            // 生成下载链接\r\n            const blobUrl = URL.createObjectURL(file);\r\n            // 对插画、漫画进行颜色检查\r\n            // 在这里进行检查的主要原因：抓取时只能检测第一张的缩略图，并没有检查后面的图片。所以这里需要对后面的图片进行检查。\r\n            // 另一个原因：如果抓取时没有设置不下载某种颜色的图片，下载时又开启了设置，那么就在这里进行检查\r\n            if (arg.data.type === 0 || arg.data.type === 1) {\r\n                const result = await filter.check({\r\n                    mini: blobUrl,\r\n                });\r\n                if (!result) {\r\n                    return this.skip({\r\n                        url: blobUrl,\r\n                        id: arg.id,\r\n                        tabId: 0,\r\n                        uuid: false,\r\n                    }, lang.transl('_不保存图片因为颜色', arg.id));\r\n                }\r\n            }\r\n            // 检查图片的宽高设置\r\n            // 因为抓取时只能检查每个作品第一张图片的宽高，所以可能会出现作品的第一张图片符合要求，但后面的图片不符合要求的情况。这里针对第一张之后的其他图片也进行检查，提高准确率。\r\n            if ((arg.data.type === 0 || arg.data.type === 1) &&\r\n                !arg.data.id.includes('p0')) {\r\n                const img = await DOM.loadImg(blobUrl);\r\n                const result = await filter.check({\r\n                    width: img.naturalWidth,\r\n                    height: img.naturalHeight,\r\n                });\r\n                if (!result) {\r\n                    return this.skip({\r\n                        url: blobUrl,\r\n                        id: arg.id,\r\n                        tabId: 0,\r\n                        uuid: false,\r\n                    }, lang.transl('_不保存图片因为宽高', arg.id));\r\n                }\r\n            }\r\n            // 向浏览器发送下载任务\r\n            this.browserDownload(blobUrl, this.fileName, arg.id, arg.taskBatch);\r\n            xhr = null;\r\n            file = null;\r\n        });\r\n        xhr.send();\r\n    }\r\n    // 向浏览器发送下载任务\r\n    browserDownload(blobUrl, fileName, id, taskBatch) {\r\n        // 如果任务已停止，不会向浏览器发送下载任务\r\n        if (this.cancel) {\r\n            // 释放 bloburl\r\n            URL.revokeObjectURL(blobUrl);\r\n            return;\r\n        }\r\n        const sendData = {\r\n            msg: 'send_download',\r\n            fileUrl: blobUrl,\r\n            fileName: fileName,\r\n            id,\r\n            taskBatch,\r\n        };\r\n        chrome.runtime.sendMessage(sendData);\r\n    }\r\n}\r\nexport { Download };\r\n","import { EVT } from './EVT';\r\nimport { lang } from './Lang';\r\n// 右侧的下载按钮\r\nclass DownloadButton {\r\n    constructor() {\r\n        this.btn = document.createElement('button');\r\n        this.addBtn();\r\n        this.bindEvents();\r\n    }\r\n    addBtn() {\r\n        this.btn = document.createElement('button');\r\n        this.btn.id = 'rightButton';\r\n        this.btn.textContent = '↓';\r\n        this.btn.setAttribute('title', lang.transl('_显示下载面板') + ' (Alt + X)');\r\n        document.body.insertAdjacentElement('afterbegin', this.btn);\r\n    }\r\n    bindEvents() {\r\n        // 这里阻止事件冒泡是为了配合 CenterPanel 的“点击页面其他部分隐藏 CenterPanel”的效果\r\n        this.btn.addEventListener('click', (e) => {\r\n            const ev = e || window.event;\r\n            ev.stopPropagation();\r\n            EVT.fire(EVT.list.openCenterPanel);\r\n        });\r\n        window.addEventListener(EVT.list.centerPanelClosed, () => {\r\n            this.show();\r\n        });\r\n        window.addEventListener(EVT.list.centerPanelOpened, () => {\r\n            this.hide();\r\n        });\r\n    }\r\n    show() {\r\n        this.btn.style.display = 'block';\r\n    }\r\n    hide() {\r\n        this.btn.style.display = 'none';\r\n    }\r\n}\r\nnew DownloadButton();\r\n","// 下载控制\r\nimport { EVT } from './EVT';\r\nimport { DOM } from './DOM';\r\nimport { store } from './Store';\r\nimport { log } from './Log';\r\nimport { lang } from './Lang';\r\nimport { Colors } from './Colors';\r\nimport { settings } from './setting/Settings';\r\nimport { Download } from './Download';\r\nimport { progressBar } from './ProgressBar';\r\nimport { downloadStates } from './DownloadStates';\r\nimport { ShowSkipCount } from './ShowSkipCount';\r\nimport { ShowConvertCount } from './ShowConvertCount';\r\nimport { BookmarkAfterDL } from './BookmarkAfterDL';\r\nimport { resume } from './Resume';\r\nimport { states } from './States';\r\nimport Config from './Config';\r\nclass DownloadControl {\r\n    constructor() {\r\n        this.thread = 5; // 同时下载的线程数的默认值\r\n        // 这里默认设置为 5，是因为国内一些用户的下载速度比较慢，所以不应该同时下载很多文件。\r\n        // 最大值由 Config.downloadThreadMax 定义\r\n        this.taskBatch = 0; // 标记任务批次，每次重新下载时改变它的值，传递给后台使其知道这是一次新的下载\r\n        this.taskList = {}; // 下载任务列表，使用下载的文件的 id 做 key，保存下载栏编号和它在下载状态列表中的索引\r\n        this.errorIdList = []; // 有任务下载失败时，保存 id\r\n        this.downloaded = 0; // 已下载的任务数量\r\n        this.wrapper = document.createElement('div');\r\n        this.totalNumberEl = document.createElement('span');\r\n        this.statesEl = document.createElement('span');\r\n        this.stop = false; // 是否停止下载\r\n        this.pause = false; // 是否暂停下载\r\n        this.createDownloadArea();\r\n        this.listenEvents();\r\n        const skipTipWrap = this.wrapper.querySelector('.skip_tip');\r\n        new ShowSkipCount(skipTipWrap);\r\n        const convertTipWrap = this.wrapper.querySelector('.convert_tip');\r\n        new ShowConvertCount(convertTipWrap);\r\n        // 只在 p 站内启用下载后收藏的功能（因为要区分 pixivision）\r\n        if (location.hostname.endsWith('.pixiv.net')) {\r\n            const bmkAfterDLTipWrap = this.wrapper.querySelector('.bmkAfterDL_tip');\r\n            new BookmarkAfterDL(bmkAfterDLTipWrap);\r\n        }\r\n    }\r\n    listenEvents() {\r\n        window.addEventListener(EVT.list.crawlStart, () => {\r\n            this.hideDownloadArea();\r\n            this.reset();\r\n        });\r\n        for (const ev of [\r\n            EVT.list.crawlFinish,\r\n            EVT.list.resultChange,\r\n            EVT.list.resume,\r\n        ]) {\r\n            window.addEventListener(ev, () => {\r\n                window.setTimeout(() => {\r\n                    this.readyDownload();\r\n                }, 0);\r\n            });\r\n        }\r\n        window.addEventListener(EVT.list.skipDownload, (ev) => {\r\n            const data = ev.detail.data;\r\n            this.downloadSuccess(data);\r\n        });\r\n        window.addEventListener(EVT.list.downloadError, (ev) => {\r\n            const id = ev.detail.data;\r\n            this.downloadError(id);\r\n        });\r\n        // 监听浏览器返回的消息\r\n        chrome.runtime.onMessage.addListener((msg) => {\r\n            if (!this.taskBatch) {\r\n                return;\r\n            }\r\n            // 文件下载成功\r\n            if (msg.msg === 'downloaded') {\r\n                // 释放 BLOBURL\r\n                URL.revokeObjectURL(msg.data.url);\r\n                this.downloadSuccess(msg.data);\r\n            }\r\n            else if (msg.msg === 'download_err') {\r\n                // 浏览器把文件保存到本地时出错\r\n                log.error(`${msg.data.id} download error! code: ${msg.err}. The downloader will try to download the file again `);\r\n                EVT.fire(EVT.list.saveFileError);\r\n                // 重新下载这个文件\r\n                // 但并不确定能否如预期一样重新下载这个文件\r\n                this.saveFileError(msg.data);\r\n            }\r\n            // UUID 的情况\r\n            if (msg.data && msg.data.uuid) {\r\n                log.error(lang.transl('_uuid'));\r\n            }\r\n        });\r\n    }\r\n    createDownloadArea() {\r\n        const html = `<div class=\"download_area\">\n    <p> ${lang.transl('_共抓取到n个文件', '<span class=\"fwb blue imgNum\">0</span>')}</p>\n    \n    <div class=\"centerWrap_btns\">\n    <button class=\"startDownload\" type=\"button\" style=\"background:${Colors.blue};\"> ${lang.transl('_下载按钮1')}</button>\n    <button class=\"pauseDownload\" type=\"button\" style=\"background:${Colors.yellow};\"> ${lang.transl('_下载按钮2')}</button>\n    <button class=\"stopDownload\" type=\"button\" style=\"background:${Colors.red};\"> ${lang.transl('_下载按钮3')}</button>\n    <button class=\"copyUrl\" type=\"button\" style=\"background:${Colors.green};\"> ${lang.transl('_复制url')}</button>\n    </div>\n    <div class=\"download_status_text_wrap\">\n    <span>${lang.transl('_当前状态')}</span>\n    <span class=\"down_status\">${lang.transl('_未开始下载')}</span>\n    <span class=\"skip_tip warn\"></span>\n    <span class=\"convert_tip warn\"></span>\n    <span class=\"bmkAfterDL_tip green\"></span>\n    </div>\n    </div>`;\r\n        this.wrapper = DOM.useSlot('downloadArea', html);\r\n        this.statesEl = this.wrapper.querySelector('.down_status');\r\n        this.totalNumberEl = this.wrapper.querySelector('.imgNum');\r\n        this.wrapper\r\n            .querySelector('.startDownload')\r\n            .addEventListener('click', () => {\r\n            this.startDownload();\r\n        });\r\n        this.wrapper\r\n            .querySelector('.pauseDownload')\r\n            .addEventListener('click', () => {\r\n            this.pauseDownload();\r\n        });\r\n        this.wrapper\r\n            .querySelector('.stopDownload')\r\n            .addEventListener('click', () => {\r\n            this.stopDownload();\r\n        });\r\n        this.wrapper.querySelector('.copyUrl').addEventListener('click', () => {\r\n            EVT.fire(EVT.list.showURLs);\r\n        });\r\n    }\r\n    // 抓取完毕之后，已经可以开始下载时，显示必要的信息，并决定是否立即开始下载\r\n    readyDownload() {\r\n        if (states.busy) {\r\n            return;\r\n        }\r\n        if (store.result.length === 0) {\r\n            return progressBar.reset(0);\r\n        }\r\n        this.showDownloadArea();\r\n        this.totalNumberEl.textContent = store.result.length.toString();\r\n        this.setDownloaded();\r\n        this.setDownloadThread();\r\n        // 检查 不自动开始下载 的标记\r\n        if (states.notAutoDownload) {\r\n            return;\r\n        }\r\n        // 视情况自动开始下载\r\n        if (settings.quietDownload || states.quickDownload) {\r\n            this.startDownload();\r\n        }\r\n    }\r\n    // 开始下载\r\n    startDownload() {\r\n        if (!this.pause && !resume.flag) {\r\n            // 如果之前没有暂停任务，也没有进入恢复模式，则重新下载\r\n            // 初始化下载状态列表\r\n            downloadStates.init();\r\n        }\r\n        else {\r\n            // 从上次中断的位置继续下载\r\n            // 把“使用中”的下载状态重置为“未使用”\r\n            downloadStates.resume();\r\n        }\r\n        this.reset();\r\n        this.setDownloaded();\r\n        this.taskBatch = new Date().getTime(); // 修改本批下载任务的标记\r\n        this.setDownloadThread();\r\n        EVT.fire(EVT.list.downloadStart);\r\n        // 建立并发下载线程\r\n        for (let i = 0; i < this.thread; i++) {\r\n            this.createDownload(i);\r\n        }\r\n        this.setDownStateText(lang.transl('_正在下载中'));\r\n        log.success(lang.transl('_正在下载中'));\r\n    }\r\n    // 暂停下载\r\n    pauseDownload() {\r\n        if (store.result.length === 0) {\r\n            return;\r\n        }\r\n        // 停止的优先级高于暂停。点击停止可以取消暂停状态，但点击暂停不能取消停止状态\r\n        if (this.stop === true) {\r\n            return;\r\n        }\r\n        if (this.pause === false) {\r\n            // 如果正在下载中\r\n            if (states.busy) {\r\n                this.pause = true;\r\n                this.setDownStateText(lang.transl('_已暂停'), '#f00');\r\n                log.warning(lang.transl('_已暂停'), 2);\r\n                EVT.fire(EVT.list.downloadPause);\r\n            }\r\n            else {\r\n                // 不在下载中的话不允许启用暂停功能\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    // 停止下载\r\n    stopDownload() {\r\n        if (store.result.length === 0 || this.stop) {\r\n            return;\r\n        }\r\n        this.stop = true;\r\n        this.setDownStateText(lang.transl('_已停止'), '#f00');\r\n        log.error(lang.transl('_已停止'), 2);\r\n        this.pause = false;\r\n        EVT.fire(EVT.list.downloadStop);\r\n    }\r\n    downloadError(id) {\r\n        this.errorIdList.push(id);\r\n        // 是否继续下载\r\n        const task = this.taskList[id];\r\n        const no = task.progressBarIndex;\r\n        if (this.checkContinueDownload()) {\r\n            this.createDownload(no);\r\n        }\r\n    }\r\n    saveFileError(data) {\r\n        if (this.pause || this.stop) {\r\n            return false;\r\n        }\r\n        const task = this.taskList[data.id];\r\n        // 复位这个任务的状态\r\n        downloadStates.setState(task.index, -1);\r\n        // 建立下载任务，再次下载它\r\n        this.createDownload(task.progressBarIndex);\r\n    }\r\n    downloadSuccess(data) {\r\n        const task = this.taskList[data.id];\r\n        // 更改这个任务状态为“已完成”\r\n        downloadStates.setState(task.index, 1);\r\n        // 发送下载成功的事件\r\n        EVT.fire(EVT.list.downloadSuccess, data);\r\n        // 统计已下载数量\r\n        this.setDownloaded();\r\n        // 是否继续下载\r\n        const no = task.progressBarIndex;\r\n        if (this.checkContinueDownload()) {\r\n            this.createDownload(no);\r\n        }\r\n    }\r\n    // 当一个文件下载成功或失败之后，检查是否还有后续下载任务\r\n    checkContinueDownload() {\r\n        // 如果没有全部下载完毕\r\n        if (this.downloaded < store.result.length) {\r\n            // 如果任务已停止\r\n            if (this.pause || this.stop) {\r\n                return false;\r\n            }\r\n            // 如果已完成的数量 加上 线程中未完成的数量，仍然没有达到文件总数，继续添加任务\r\n            if (this.downloaded + this.thread - 1 < store.result.length) {\r\n                return true;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    // 设置下载线程数量\r\n    setDownloadThread() {\r\n        const setThread = parseInt(settings.downloadThread);\r\n        if (setThread < 1 ||\r\n            setThread > Config.downloadThreadMax ||\r\n            isNaN(setThread)) {\r\n            // 如果数值非法，则重设为默认值\r\n            this.thread = Config.downloadThreadMax;\r\n        }\r\n        else {\r\n            this.thread = setThread; // 设置为用户输入的值\r\n        }\r\n        // 如果剩余任务数量少于下载线程数\r\n        if (store.result.length - this.downloaded < this.thread) {\r\n            this.thread = store.result.length - this.downloaded;\r\n        }\r\n        // 重设下载进度条\r\n        progressBar.reset(this.thread, this.downloaded);\r\n    }\r\n    // 查找需要进行下载的作品，建立下载\r\n    createDownload(progressBarIndex) {\r\n        const index = downloadStates.getFirstDownloadItem();\r\n        if (index === undefined) {\r\n            // 当已经没有需要下载的作品时，检查是否带着错误完成了下载\r\n            // 如果下载过程中没有出错，就不会执行到这个分支\r\n            return this.checkCompleteWithError();\r\n        }\r\n        else {\r\n            const workData = store.result[index];\r\n            const data = {\r\n                id: workData.id,\r\n                data: workData,\r\n                index: index,\r\n                progressBarIndex: progressBarIndex,\r\n                taskBatch: this.taskBatch,\r\n            };\r\n            // 保存任务信息\r\n            this.taskList[workData.id] = {\r\n                index,\r\n                progressBarIndex: progressBarIndex,\r\n            };\r\n            // 建立下载\r\n            new Download(progressBarIndex, data);\r\n        }\r\n    }\r\n    setDownloaded() {\r\n        this.downloaded = downloadStates.downloadedCount();\r\n        const text = `${this.downloaded} / ${store.result.length}`;\r\n        log.log(text, 2, false);\r\n        // 设置下载进度条\r\n        progressBar.setTotalProgress(this.downloaded);\r\n        if (this.downloaded === 0) {\r\n            this.setDownStateText(lang.transl('_未开始下载'));\r\n        }\r\n        // 所有文件正常下载完毕（跳过下载的文件也算正常下载）\r\n        if (this.downloaded === store.result.length) {\r\n            window.setTimeout(() => {\r\n                // 延后触发下载完成的事件。因为下载完成事件是由上游事件（跳过下载，或下载成功事件）派生的，如果这里不延迟触发，可能导致其他模块先接收到下载完成事件，后接收到上游事件。\r\n                EVT.fire(EVT.list.downloadComplete);\r\n            }, 0);\r\n            this.reset();\r\n            this.setDownStateText(lang.transl('_下载完毕'), Colors.green);\r\n            log.success(lang.transl('_下载完毕'), 2);\r\n        }\r\n        this.checkCompleteWithError();\r\n    }\r\n    // 在有下载出错的任务的情况下，是否已经完成了下载\r\n    checkCompleteWithError() {\r\n        if (this.errorIdList.length > 0 &&\r\n            this.downloaded + this.errorIdList.length === store.result.length) {\r\n            // 进入暂停状态，一定时间后自动开始下载，重试下载出错的文件\r\n            this.pauseDownload();\r\n            setTimeout(() => {\r\n                this.startDownload();\r\n            }, 5000);\r\n        }\r\n    }\r\n    // 设置下载状态文本，默认颜色为主题蓝色\r\n    setDownStateText(text, color = Colors.blue) {\r\n        this.statesEl.textContent = text;\r\n        this.statesEl.style.color = color;\r\n    }\r\n    reset() {\r\n        this.pause = false;\r\n        this.stop = false;\r\n        this.errorIdList = [];\r\n    }\r\n    showDownloadArea() {\r\n        this.wrapper.style.display = 'block';\r\n    }\r\n    hideDownloadArea() {\r\n        this.wrapper.style.display = 'none';\r\n    }\r\n}\r\nnew DownloadControl();\r\n","import { EVT } from './EVT';\r\nimport { store } from './Store';\r\n// 下载状态列表\r\nclass DownloadStates {\r\n    constructor() {\r\n        this.states = [];\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        // 初始化下载状态\r\n        const evs = [EVT.list.crawlFinish, EVT.list.resultChange];\r\n        for (const ev of evs) {\r\n            window.addEventListener(ev, () => {\r\n                this.init();\r\n            });\r\n        }\r\n    }\r\n    // 创建新的状态列表\r\n    init() {\r\n        this.states = new Array(store.result.length).fill(-1);\r\n    }\r\n    // 统计下载完成的数量\r\n    downloadedCount() {\r\n        let count = 0;\r\n        const length = this.states.length;\r\n        for (let i = 0; i < length; i++) {\r\n            if (this.states[i] === 1) {\r\n                count++;\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n    // 接受传入的状态数据\r\n    // 目前只有在恢复下载的时候使用\r\n    replace(states) {\r\n        this.states = states;\r\n    }\r\n    // 恢复之前的下载任务\r\n    // 这会把之前的“下载中”标记复位到“未开始下载”，以便再次下载\r\n    resume() {\r\n        const length = this.states.length;\r\n        for (let i = 0; i < length; i++) {\r\n            if (this.states[i] === 0) {\r\n                this.setState(i, -1);\r\n            }\r\n        }\r\n    }\r\n    // 获取第一个“未开始下载”标记的索引\r\n    getFirstDownloadItem() {\r\n        const length = this.states.length;\r\n        for (let i = 0; i < length; i++) {\r\n            if (this.states[i] === -1) {\r\n                this.setState(i, 0);\r\n                return i;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    // 设置已下载列表中的标记\r\n    setState(index, value) {\r\n        this.states[index] = value;\r\n    }\r\n    clear() {\r\n        this.states = [];\r\n    }\r\n}\r\nconst downloadStates = new DownloadStates();\r\nexport { downloadStates };\r\n","// 触发自定义事件\r\nclass EVT {\r\n    // 触发事件，可以携带数据\r\n    static fire(type, data = {}) {\r\n        const event = new CustomEvent(type, {\r\n            detail: { data: data },\r\n        });\r\n        window.dispatchEvent(event);\r\n    }\r\n    static sendMsg(data) {\r\n        this.fire(this.list.showMsg, data);\r\n    }\r\n}\r\nEVT.list = {\r\n    // 当抓取开始时触发\r\n    crawlStart: 'crawlStart',\r\n    // 当检查到错误的设置时触发\r\n    wrongSetting: 'wrongSetting',\r\n    // 当获取作品的 id 列表完成时触发\r\n    getIdListFinished: 'getIdListFinished',\r\n    // 当抓取完成时触发。不管结果是否为空都会触发\r\n    crawlFinish: 'crawlFinish',\r\n    // 当抓取结果为空时触发。触发时机晚于 crawlFinish\r\n    crawlEmpty: 'crawlEmpty',\r\n    // store 里每存储一个作品的元数据，就触发一次。如果一个元数据产生了多个结果（多图作品），只触发一次\r\n    addResult: 'addResult',\r\n    // 当抓取完毕之后，抓取结果又发生变化时触发（比如进行多次筛选、改变设置项等，导致结果变化）\r\n    resultChange: 'resultChange',\r\n    // 当进行快速下载时触发\r\n    QuickDownload: 'QuickDownload',\r\n    // 开始下载时触发\r\n    downloadStart: 'downloadStart',\r\n    // 下载状态变成暂停时触发\r\n    downloadPause: 'downloadPause',\r\n    // 下载状态变成停止时触发\r\n    downloadStop: 'downloadStop',\r\n    // 当文件在下载阶段下载失败时触发\r\n    // 当动图转换出错时触发\r\n    downloadError: 'downloadError',\r\n    // 当一个文件在下载阶段被跳过时触发\r\n    skipDownload: 'skipDownload',\r\n    // 当浏览器把一个文件保存到本地失败时触发\r\n    saveFileError: 'saveFileError',\r\n    // 当下载的文件传递给浏览器进行保存，并且成功保存之后触发\r\n    // skipDownload 也会触发这个事件\r\n    downloadSuccess: 'downloadSuccess',\r\n    // 下载队列里的所有文件都已经下载并保存完毕，并且没有出错的。如果有出错的，就不会触发这个事件\r\n    downloadComplete: 'downloadComplete',\r\n    // 页面切换\r\n    pageSwitch: 'pageSwitch',\r\n    // 页面切换，并且页面类型变化\r\n    pageSwitchedTypeChange: 'pageSwitchedTypeChange',\r\n    // 页面切换，并且页面类型不变\r\n    pageSwitchedTypeNotChange: 'pageSwitchedTypeNotChange',\r\n    // 请求重置所有设置\r\n    resetSettings: 'resetSettings',\r\n    // 重置所有设置执行完毕\r\n    resetSettingsEnd: 'resetSettingsEnd',\r\n    // 请求导出设置\r\n    exportSettings: 'exportSettings',\r\n    // 请求导入设置\r\n    importSettings: 'importSettings',\r\n    // 当动图转换数量发生变化时触发\r\n    convertChange: 'convertChange',\r\n    // 当读取/解压 zip 文件出错时触发\r\n    readZipError: 'readZipError',\r\n    // 当动图转换成功时触发\r\n    convertSuccess: 'convertSuccess',\r\n    // 指示打开中间面板\r\n    openCenterPanel: 'openCenterPanel',\r\n    // 指示关闭中间面板\r\n    closeCenterPanel: 'closeCenterPanel',\r\n    // 中间面板已打开\r\n    centerPanelOpened: 'centerPanelOpened',\r\n    // 中间面板已关闭\r\n    centerPanelClosed: 'centerPanelClosed',\r\n    // 当清除多图作品时触发\r\n    clearMultiple: 'clearMultiple',\r\n    // 当清除动图作品时触发\r\n    clearUgoira: 'clearUgoira',\r\n    // 当手动删除作品时触发\r\n    deleteWork: 'deleteWork',\r\n    // 当下载器在页面上创建的作品列表全部完成时触发\r\n    worksUpdate: 'worksUpdate',\r\n    // 当需要清空下载记录时触发（指用于检测重复文件的下载记录）\r\n    clearDownloadRecord: 'clearDownloadRecord',\r\n    // 当需要导出下载记录时触发\r\n    exportDownloadRecord: 'exportDownloadRecord',\r\n    // 当需要导入下载记录时触发\r\n    importDownloadRecord: 'importDownloadRecord',\r\n    // 当需要清空断点续传的数据时触发\r\n    clearSavedCrawl: 'clearSavedCrawl',\r\n    // 当从断点续传数据恢复了下载时触发\r\n    resume: 'resume',\r\n    // 当需要导出 csv 文件时触发\r\n    outputCSV: 'outputCSV',\r\n    // 当需要导出抓取结果时触发\r\n    outputResult: 'outputResult',\r\n    // 当需要保存用户头像为图标时触发\r\n    saveAvatarIcon: 'saveAvatarIcon',\r\n    // 当需要预览文件名时触发\r\n    previewFileName: 'previewFileName',\r\n    // 当需要预览 url 时触发\r\n    showURLs: 'showURLs',\r\n    // 当需要输出面板输出内容时触发\r\n    output: 'output',\r\n    // 当设置表单里的设置项发生变化时触发\r\n    settingChange: 'settingChange',\r\n    // 当下载器检测到有新版本时触发\r\n    hasNewVer: 'hasNewVer',\r\n    // 进入批量收藏模式时触发\r\n    bookmarkModeStart: 'bookmarkModeStart',\r\n    // 批量收藏完成时触发\r\n    bookmarkModeEnd: 'bookmarkModeEnd',\r\n    // 需要单独显示信息时触发\r\n    showMsg: 'showMsg',\r\n};\r\nexport { EVT };\r\n","import { EVT } from './EVT';\r\nimport { DOM } from './DOM';\r\nimport { API } from './API';\r\nimport { lang } from './Lang';\r\nimport config from './Config';\r\nimport { store } from './Store';\r\nimport { fileName } from './FileName';\r\n// name 这个字段在 csv 里显示的名字。\r\n// index 这个字段在数据里的索引名\r\n// toString 输入这个字段的原始数据，将其转换为字符串。\r\n// q 指 quotation ，指示 toString 的结果是否需要使用双引号包裹\r\n// 需要双引号包裹的情况：值含有逗号、换行符、空格、双引号\r\n// 导出 csv 文件\r\n// 参考 https://www.jianshu.com/p/54b3afc06126\r\nclass ExportCSV {\r\n    constructor() {\r\n        this.separate = ','; // 分隔符\r\n        this.CRLF = '\\r\\n'; // 换行符\r\n        this.number2String = (arg) => {\r\n            return arg.toString();\r\n        };\r\n        this.array2String = (arg) => {\r\n            return arg.join(',');\r\n        };\r\n        this.string2String = (arg) => {\r\n            return arg;\r\n        };\r\n        this.getFileName = (arg) => {\r\n            return fileName.getFileName(arg);\r\n        };\r\n        // 定义要保存的字段\r\n        this.fieldCfg = [\r\n            {\r\n                name: 'id',\r\n                index: 'idNum',\r\n                q: false,\r\n                toString: this.number2String,\r\n            },\r\n            {\r\n                name: 'tags',\r\n                index: 'tags',\r\n                q: true,\r\n                toString: this.array2String,\r\n            },\r\n            {\r\n                name: 'tags_transl',\r\n                index: 'tagsTranslOnly',\r\n                q: true,\r\n                toString: this.array2String,\r\n            },\r\n            {\r\n                name: 'user',\r\n                index: 'user',\r\n                q: true,\r\n                toString: this.string2String,\r\n            },\r\n            {\r\n                name: 'userid',\r\n                index: 'userId',\r\n                q: false,\r\n                toString: this.string2String,\r\n            },\r\n            {\r\n                name: 'title',\r\n                index: 'title',\r\n                q: true,\r\n                toString: this.string2String,\r\n            },\r\n            {\r\n                name: 'type',\r\n                index: 'type',\r\n                q: false,\r\n                toString: (arg) => {\r\n                    return config.illustTypes[arg];\r\n                },\r\n            },\r\n            {\r\n                name: 'page',\r\n                index: 'pageCount',\r\n                q: false,\r\n                toString: this.number2String,\r\n            },\r\n            {\r\n                name: 'bookmark',\r\n                index: 'bmk',\r\n                q: false,\r\n                toString: this.number2String,\r\n            },\r\n            {\r\n                name: 'bookmarked',\r\n                index: 'bookmarked',\r\n                q: false,\r\n                toString: (arg) => {\r\n                    return arg ? 'yes' : 'no';\r\n                },\r\n            },\r\n            {\r\n                name: 'width',\r\n                index: 'fullWidth',\r\n                q: false,\r\n                toString: this.number2String,\r\n            },\r\n            {\r\n                name: 'height',\r\n                index: 'fullHeight',\r\n                q: false,\r\n                toString: this.number2String,\r\n            },\r\n            {\r\n                name: 'date',\r\n                index: 'date',\r\n                q: false,\r\n                toString: this.string2String,\r\n            },\r\n            {\r\n                name: 'original',\r\n                index: 'original',\r\n                q: false,\r\n                toString: this.string2String,\r\n            },\r\n            {\r\n                name: 'fileName',\r\n                index: 'title',\r\n                q: true,\r\n                toString: this.getFileName,\r\n            },\r\n        ];\r\n        this.utf8BOM = this.UTF8BOM();\r\n        window.addEventListener(EVT.list.outputCSV, () => {\r\n            this.beforeCreate();\r\n        });\r\n    }\r\n    // fileName 字段的 index 属性可以随便写，因为没有影响。\r\n    beforeCreate() {\r\n        // 如果没有数据则不执行\r\n        if (store.result.length === 0) {\r\n            EVT.sendMsg({\r\n                msg: lang.transl('_没有数据可供使用'),\r\n                type: 'error',\r\n            });\r\n            return;\r\n        }\r\n        // 使用 result 而不使用 resultMeta。主要是因为断点续传时只会恢复 result，不会恢复 resultMeta，所以 result 最可靠。考虑如下情况：\r\n        // 1：刷新页面后，断点续传恢复了保存的数据，此时只有 result 里有数据，resultMeta 没有数据。\r\n        // 2: 如果在页面 A 进行了下载，resultMeta 保存的是页面 A 的数据。此时进入页面 B，恢复了 B 页面保存的任务，此时 resultMeta 里还是页面 A 的数据。\r\n        // 所以还是使用 result 比较可靠，不易出问题。\r\n        this.create(store.result);\r\n    }\r\n    create(data) {\r\n        const result = []; // 储存结果。每行的结果合并为一个字符串。不带换行符\r\n        // 首先添加字段一栏\r\n        const head = [];\r\n        for (const field of this.fieldCfg) {\r\n            head.push(field.name);\r\n        }\r\n        const headResult = head.join(this.separate);\r\n        result.push(headResult);\r\n        // 循环每个作品的数据，生成结果\r\n        for (const d of data) {\r\n            // 如果是多图作品，并且不是第一张图，则跳过\r\n            // 这是因为多图作品可能有多个数据。在生成 csv 时只使用第一张图的数据\r\n            // 多图作品 && id 不以 p0 结尾（说明不是第一张图）\r\n            if (d.pageCount > 1 && !d.id.endsWith('p0')) {\r\n                continue;\r\n            }\r\n            const temp = []; // 储存这个作品的数据\r\n            // 生成每个字段的结果\r\n            for (const field of this.fieldCfg) {\r\n                // 设置生成结果所使用的数据。fileName 需要使用整个作品数据。其他字段则取出对应的属性\r\n                let originalData = field.name === 'fileName' ? d : d[field.index];\r\n                if (originalData === undefined) {\r\n                    // 如果某个字段使用的属性在旧版本的数据里不存在性，就会是 undefined\r\n                    // 例如 original 属性在 7.6.0 版本以前不存在，现在使用了这个字段。如果下载器有保存旧版本的断点续传数据，那么获取 original 就是 undefined，需要进行处理。\r\n                    originalData = '';\r\n                }\r\n                // 求值并替换双引号。值原本就有的双引号，要替换成两个双引号\r\n                let value = field.toString(originalData).replace(/\\\"/g, '\"\"');\r\n                // 根据 q 标记决定是否用双引号包裹这个值\r\n                if (field.q) {\r\n                    value = this.addQuotation(value);\r\n                }\r\n                temp.push(value);\r\n            }\r\n            // 把这个作品的数据添加到结果里\r\n            result.push(temp.join(this.separate));\r\n        }\r\n        // 生成文件的 url\r\n        const csvData = result.join(this.CRLF);\r\n        const csvBlob = new Blob([this.utf8BOM, csvData]);\r\n        const url = URL.createObjectURL(csvBlob);\r\n        // 设置文件名\r\n        let name = '';\r\n        const ogTitle = document.querySelector('meta[property=\"og:title\"]');\r\n        if (ogTitle) {\r\n            name = ogTitle.content;\r\n        }\r\n        else {\r\n            name = DOM.getTitle();\r\n        }\r\n        // 下载文件\r\n        DOM.downloadFile(url, API.replaceUnsafeStr(name) + '.csv');\r\n    }\r\n    UTF8BOM() {\r\n        const buff = new ArrayBuffer(3);\r\n        const data = new DataView(buff);\r\n        data.setInt8(0, 0xef);\r\n        data.setInt8(1, 0xbb);\r\n        data.setInt8(2, 0xbf);\r\n        return buff;\r\n    }\r\n    // 在字符串的两端添加双引号\r\n    addQuotation(data) {\r\n        return '\"' + data + '\"';\r\n    }\r\n}\r\nnew ExportCSV();\r\n","import { DOM } from './DOM';\r\nimport { EVT } from './EVT';\r\nimport { store } from './Store';\r\nimport { fileName } from './FileName';\r\n// 输出 lst 文件\r\nclass ExportLST {\r\n    constructor() {\r\n        this.separate = '?/'; // 分隔符\r\n        this.CRLF = '\\r\\n'; // 换行符\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        window.addEventListener('keydown', (ev) => {\r\n            if (ev.altKey && ev.code === 'KeyL') {\r\n                this.createLst();\r\n            }\r\n        }, false);\r\n    }\r\n    createLst() {\r\n        if (store.result.length === 0) {\r\n            EVT.sendMsg({\r\n                msg: '现在没有抓取结果可以输出',\r\n                type: 'error',\r\n            });\r\n            return;\r\n        }\r\n        const array = [];\r\n        for (const data of store.result) {\r\n            array.push(data.original + this.separate + fileName.getFileName(data));\r\n        }\r\n        const result = array.join(this.CRLF);\r\n        const blob = new Blob([result]);\r\n        const url = URL.createObjectURL(blob);\r\n        const name = DOM.getTitle() + '.lst';\r\n        DOM.downloadFile(url, name);\r\n    }\r\n}\r\nnew ExportLST();\r\n","import { API } from './API';\r\nimport { EVT } from './EVT';\r\nimport { DOM } from './DOM';\r\nimport { store } from './Store';\r\nclass ExportResult {\r\n    constructor() {\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        window.addEventListener(EVT.list.outputResult, () => {\r\n            this.output();\r\n        });\r\n    }\r\n    output() {\r\n        const str = JSON.stringify(store.result, null, 2);\r\n        const blob = new Blob([str], { type: 'application/json' });\r\n        const url = URL.createObjectURL(blob);\r\n        DOM.downloadFile(url, `result-${API.replaceUnsafeStr(DOM.getTitle())}-${store.crawlCompleteTime.getTime()}.json`);\r\n    }\r\n}\r\nnew ExportResult();\r\n","import { API } from './API';\r\nimport { EVT } from './EVT';\r\nimport { DOM } from './DOM';\r\nimport { theme } from './Theme';\r\n// 在搜索页面按收藏数快速筛选\r\nclass FastScreen {\r\n    constructor() {\r\n        this.favNums = [\r\n            '100users入り',\r\n            '500users入り',\r\n            '1000users入り',\r\n            '3000users入り',\r\n            '5000users入り',\r\n            '10000users入り',\r\n            '20000users入り',\r\n            '30000users入り',\r\n            '50000users入り',\r\n        ]; // 200 和 2000 的因为数量太少，不添加。40000 的也少\r\n        this.create();\r\n        window.addEventListener(EVT.list.pageSwitchedTypeChange, () => {\r\n            this.destroy();\r\n        });\r\n    }\r\n    // 添加快速筛选功能\r\n    create() {\r\n        // 判断插入点的元素有没有加载出来\r\n        const target = document.querySelector('#root>div');\r\n        if (!target) {\r\n            setTimeout(() => {\r\n                this.create();\r\n            }, 300);\r\n            return;\r\n        }\r\n        const fastScreenArea = document.createElement('div');\r\n        fastScreenArea.className = 'fastScreenArea';\r\n        this.favNums.forEach((secondTag) => {\r\n            const a = document.createElement('a');\r\n            a.innerText = secondTag;\r\n            a.href = 'javascript:viod(0)';\r\n            a.onclick = () => {\r\n                this.openFastScreenLink(secondTag);\r\n            };\r\n            fastScreenArea.appendChild(a);\r\n        });\r\n        theme.register(fastScreenArea);\r\n        target.insertAdjacentElement('afterend', fastScreenArea);\r\n    }\r\n    // 打开快速筛选链接\r\n    openFastScreenLink(secondTag) {\r\n        // 拼接两个 tag。因为搜索页面可以无刷新切换搜索的 tag，所以从这里动态获取\r\n        const nowTag = API.getTagFromURL();\r\n        const firstTag = nowTag.split(' ')[0];\r\n        const fullTag = encodeURIComponent(firstTag + ' ' + secondTag);\r\n        // 用新的 tag 替换掉当前网址里的 tag\r\n        const newURL = location.href.replace(encodeURIComponent(nowTag), fullTag);\r\n        // 添加 s_mode=s_tag 宽松匹配标签\r\n        const u = new URL(newURL);\r\n        u.searchParams.set('s_mode', 's_tag');\r\n        location.href = u.toString();\r\n    }\r\n    destroy() {\r\n        // 删除快速筛选元素\r\n        const fastScreen = document.querySelector('.fastScreenArea');\r\n        DOM.removeEl(fastScreen);\r\n    }\r\n}\r\nexport { FastScreen };\r\n","import { API } from './API';\r\nimport { settings } from './setting/Settings';\r\nimport { store } from './Store';\r\nimport config from './Config';\r\nimport { states } from './States';\r\nimport { DateFormat } from './DateFormat';\r\n// 生成文件名\r\nclass FileName {\r\n    constructor() { }\r\n    // 生成文件名\r\n    getFileName(data) {\r\n        // 为空时使用 {id}\r\n        let result = settings.userSetName || '{id}';\r\n        // 配置所有命名标记\r\n        const cfg = {\r\n            '{p_title}': {\r\n                value: store.title,\r\n                prefix: '',\r\n                safe: false,\r\n            },\r\n            '{p_tag}': {\r\n                value: store.tag,\r\n                prefix: '',\r\n                safe: false,\r\n            },\r\n            '{id}': {\r\n                value: data.id,\r\n                prefix: '',\r\n                safe: true,\r\n            },\r\n            '{id_num}': {\r\n                value: data.idNum || parseInt(data.id),\r\n                prefix: '',\r\n                safe: true,\r\n            },\r\n            '{p_num}': {\r\n                value: parseInt(/\\d*$/.exec(data.id)[0]),\r\n                prefix: '',\r\n                safe: true,\r\n            },\r\n            '{rank}': {\r\n                value: data.rank,\r\n                prefix: '',\r\n                safe: true,\r\n            },\r\n            '{title}': {\r\n                value: data.title,\r\n                prefix: 'title_',\r\n                safe: false,\r\n            },\r\n            '{user}': {\r\n                value: data.user,\r\n                prefix: 'user_',\r\n                safe: false,\r\n            },\r\n            '{userid}': {\r\n                value: data.userId,\r\n                prefix: 'uid_',\r\n                safe: true,\r\n            },\r\n            '{user_id}': {\r\n                value: data.userId,\r\n                prefix: 'uid_',\r\n                safe: true,\r\n            },\r\n            '{px}': {\r\n                value: (function () {\r\n                    if (result.includes('{px}') && data.fullWidth !== undefined) {\r\n                        return data.fullWidth + 'x' + data.fullHeight;\r\n                    }\r\n                    else {\r\n                        return '';\r\n                    }\r\n                })(),\r\n                prefix: '',\r\n                safe: true,\r\n            },\r\n            '{tags}': {\r\n                value: data.tags.join(','),\r\n                prefix: 'tags_',\r\n                safe: false,\r\n            },\r\n            '{tags_translate}': {\r\n                value: data.tagsWithTransl.join(','),\r\n                prefix: 'tags_',\r\n                safe: false,\r\n            },\r\n            '{tags_transl_only}': {\r\n                value: data.tagsTranslOnly.join(','),\r\n                prefix: 'tags_',\r\n                safe: false,\r\n            },\r\n            '{bmk}': {\r\n                value: data.bmk,\r\n                prefix: 'bmk_',\r\n                safe: true,\r\n            },\r\n            '{date}': {\r\n                value: DateFormat.format(data.date, settings.dateFormat),\r\n                prefix: '',\r\n                safe: false,\r\n            },\r\n            '{task_date}': {\r\n                value: DateFormat.format(store.crawlCompleteTime, settings.dateFormat),\r\n                prefix: '',\r\n                safe: false,\r\n            },\r\n            '{type}': {\r\n                value: config.illustTypes[data.type],\r\n                prefix: '',\r\n                safe: true,\r\n            },\r\n            '{series_title}': {\r\n                value: data.seriesTitle || '',\r\n                prefix: '',\r\n                safe: false,\r\n            },\r\n            '{series_order}': {\r\n                value: data.seriesOrder || '',\r\n                prefix: '',\r\n                safe: true,\r\n            },\r\n        };\r\n        // 替换命名规则里的特殊字符\r\n        result = API.replaceUnsafeStr(result);\r\n        // 上一步会把斜线 / 替换成全角的斜线 ／，这里再替换回来，否则就不能建立文件夹了\r\n        result = result.replace(/／/g, '/');\r\n        // 判断这个作品是否要去掉序号\r\n        const noSerialNo = cfg['{p_num}'].value === 0 && settings.noSerialNo;\r\n        // 把命名规则的标记替换成实际值\r\n        for (const [key, val] of Object.entries(cfg)) {\r\n            if (result.includes(key)) {\r\n                // 处理去掉序号的情况\r\n                if (noSerialNo) {\r\n                    // 把 p_num 设为空字符串\r\n                    key === '{p_num}' && (val.value = '');\r\n                    // 去掉 id 后面的序号。因为 idNum 不带序号，所以直接拿来用了\r\n                    key === '{id}' && (val.value = cfg['{id_num}'].value);\r\n                }\r\n                let once = String(val.value);\r\n                // 处理标记值中的特殊字符\r\n                if (!val.safe) {\r\n                    once = API.replaceUnsafeStr(once);\r\n                }\r\n                // 添加标记名称\r\n                if (settings.tagNameToFileName) {\r\n                    once = val.prefix + once;\r\n                }\r\n                result = result.replace(new RegExp(key, 'g'), once); // 将标记替换成最终值，如果有重复的标记，全部替换\r\n            }\r\n        }\r\n        // 处理空值，连续的 '//'。 有时候两个斜线中间的字段是空值，最后就变成两个斜线挨在一起了\r\n        result = result.replace(/undefined/g, '').replace(/\\/{2,9}/, '/');\r\n        // 对每一层路径进行处理\r\n        let tempArr = result.split('/');\r\n        tempArr.forEach((str, index, arr) => {\r\n            // 替换路径首尾的空格\r\n            // 把每层路径头尾的 . 变成全角的．因为 Chrome 不允许头尾使用 .\r\n            arr[index] = str.trim().replace(/^\\./g, '．').replace(/\\.$/g, '．');\r\n        });\r\n        result = tempArr.join('/');\r\n        // 去掉头尾的 /\r\n        if (result.startsWith('/')) {\r\n            result = result.replace('/', '');\r\n        }\r\n        if (result.endsWith('/')) {\r\n            result = result.substr(0, result.length - 1);\r\n        }\r\n        // 如果快速下载时只有一个文件，根据“始终建立文件夹”选项，决定是否去掉文件夹部分\r\n        if (states.quickDownload &&\r\n            store.result.length === 1 &&\r\n            !settings.alwaysFolder) {\r\n            const index = result.lastIndexOf('/');\r\n            result = result.substr(index + 1, result.length);\r\n        }\r\n        // 处理为多图作品自动建立文件夹的情况\r\n        // 多图作品如果只下载前 1 张，不会为它自动建立文件夹。大于 1 张才会自动建立文件夹\r\n        if (settings.multipleImageDir && data.dlCount > 1) {\r\n            // 操作路径中最后一项（即文件名），在它前面添加一层文件夹\r\n            const allPart = result.split('/');\r\n            const lastPartIndex = allPart.length - 1;\r\n            let lastPart = allPart[lastPartIndex];\r\n            let addString = '';\r\n            if (settings.multipleImageFolderName === '1') {\r\n                // 使用作品 id 作为文件夹名\r\n                addString = data.idNum.toString();\r\n            }\r\n            else if (settings.multipleImageFolderName === '2') {\r\n                // 遵从命名规则，使用文件名做文件夹名\r\n                // 这里进行了一个替换，因为多图每个图片的名字都不同，这主要是因为 id 后面的序号不同。这会导致文件夹名也不同，有多少个文件就会建立多少个文件夹，而不是统一建立一个文件夹。为了只建立一个文件夹，需要把 id 后面的序号部分去掉。\r\n                // 但是如果一些特殊的命名规则并没有包含 {id} 部分，文件名的区别得不到处理，依然会每个文件建立一个文件夹。\r\n                addString = lastPart.replace(data.id, data.idNum.toString());\r\n            }\r\n            lastPart = addString + '/' + lastPart;\r\n            allPart[lastPartIndex] = lastPart;\r\n            result = allPart.join('/');\r\n        }\r\n        // 生成后缀名\r\n        const ugoiraFormat = ['webm', 'gif', 'png'];\r\n        if (ugoiraFormat.includes(data.ext) && data.ugoiraInfo) {\r\n            // 如果是动图，那么此时根据用户设置的动图保存格式，更新其后缀名\r\n            // 例如，抓取时动图保存格式是 webm，下载开始前，用户改成了 gif，在这里可以响应用户的修改\r\n            data.ext = settings.ugoiraSaveAs;\r\n        }\r\n        const extResult = '.' + data.ext;\r\n        // 处理文件名长度限制\r\n        // 去掉文件夹部分，只处理 文件名+后缀名 部分\r\n        // 理论上文件夹部分也可能会超长，但是实际使用中几乎不会有人这么设置，所以不处理\r\n        if (settings.fileNameLengthLimitSwitch) {\r\n            let limit = Number.parseInt(settings.fileNameLengthLimit);\r\n            if (limit < 1 || isNaN(limit)) {\r\n                limit = 200; // 如果设置的值不合法，则设置为 200\r\n            }\r\n            const allPart = result.split('/');\r\n            const lastIndex = allPart.length - 1;\r\n            if (allPart[lastIndex].length + extResult.length > limit) {\r\n                allPart[lastIndex] = allPart[lastIndex].substr(0, limit - extResult.length);\r\n            }\r\n            result = allPart.join('/');\r\n        }\r\n        // 添加后缀名\r\n        result += extResult;\r\n        return result;\r\n    }\r\n}\r\nconst fileName = new FileName();\r\nexport { fileName };\r\n","import { lang } from './Lang';\r\nimport { log } from './Log';\r\nimport { API } from './API';\r\nimport { EVT } from './EVT';\r\nimport { states } from './States';\r\nimport { settings } from './setting/Settings';\r\nimport { blackAndWhiteImage } from './BlackandWhiteImage';\r\n// 检查作品是否符合过滤条件\r\nclass Filter {\r\n    constructor() {\r\n        this.BMKNumMinDef = 0;\r\n        this.BMKNumMaxDef = 9999999;\r\n        this.MiB = 1024 * 1024;\r\n        // 缓存部分开始\r\n        // 为了减少不必要的重复计算，缓存一些计算后的值。当有设置改变时，重新计算缓存的值，所以这些值也是会动态更新的。\r\n        // 可以直接使用的选项不需要缓存;只有需要进行处理后才可以使用的选项需要缓存\r\n        this._BMKNumMin = this.BMKNumMinDef; // 最小收藏数量\r\n        this._BMKNumMax = this.BMKNumMaxDef; // 最大收藏数量\r\n        this._sizeMin = 0;\r\n        this._sizeMax = 100 * this.MiB;\r\n        this._setWidth = 0;\r\n        this._setHeight = 0;\r\n        this._postDateStart = 0;\r\n        this._postDateEnd = 0;\r\n        this._needTag = '';\r\n        this._notNeedTag = '';\r\n        this.blockList = [];\r\n        // 缓存部分结束\r\n        this.showTip = false; // 是否在日志区域输出提示\r\n        this.bindEvents();\r\n    }\r\n    // 检查设置项，获取设置的值\r\n    // 如果 showTip 为 true，表示允许在日志区域输出提示\r\n    init(showTip = false) {\r\n        this.showTip = showTip;\r\n        // 获取作品类型的设置\r\n        this.getDownType();\r\n        this.getDownTypeByImgCount();\r\n        this.getDownTypeByColor();\r\n        // 获取收藏数设置\r\n        this.getBMKNum();\r\n        // 获取只下载已收藏设置\r\n        this.getOnlyBmk();\r\n        // 获取宽高条件设置\r\n        this.getSetWh();\r\n        // 获取宽高比设置\r\n        this.getRatio();\r\n        // 获取 id 范围设置\r\n        this.getIdRange();\r\n        // 获取投稿时间设置\r\n        this.getPostDate();\r\n        // 获取必须包含的tag\r\n        this.getIncludeTag();\r\n        // 获取要排除的tag\r\n        this.getExcludeTag();\r\n        // 获取只下载首次登场设置\r\n        if (states.debut) {\r\n            this.logTip(lang.transl('_抓取首次登场的作品Title'));\r\n        }\r\n        // 获取用户阻止名单\r\n        this.getBlockList();\r\n        // 获取文件体积设置\r\n        this.getSize();\r\n    }\r\n    // 检查作品是否符合过滤器的要求\r\n    // 想要检查哪些数据就传递哪些数据，不需要传递 FilterOption 的所有选项\r\n    // 所有过滤器里，都必须要检查参数为 undefined 的情况\r\n    // 注意：这是一个异步函数，所以要记得使用 await 获取检查结果\r\n    async check(option) {\r\n        // 检查下载的作品类型设置\r\n        if (!this.checkDownType(option.illustType)) {\r\n            return false;\r\n        }\r\n        // 检查单图、多图的下载\r\n        if (!this.checkPageCount(option.illustType, option.pageCount)) {\r\n            return false;\r\n        }\r\n        // 检查收藏数要求\r\n        if (!this.checkBMK(option.bookmarkCount)) {\r\n            return false;\r\n        }\r\n        // 检查只下载已收藏的要求\r\n        if (!this.checkOnlyBmk(option.bookmarkData)) {\r\n            return false;\r\n        }\r\n        // 检查要排除的 tag\r\n        if (!this.checkExcludeTag(option.tags)) {\r\n            return false;\r\n        }\r\n        // 检查必须包含的 tag\r\n        if (!this.checkIncludeTag(option.tags)) {\r\n            return false;\r\n        }\r\n        // 检查宽高设置\r\n        if (!this.checkSetWh(option.width, option.height)) {\r\n            return false;\r\n        }\r\n        // 检查宽高比设置\r\n        if (!this.checkRatio(option.width, option.height)) {\r\n            return false;\r\n        }\r\n        // 检查 id 范围设置\r\n        if (!this.checkIdRange(option.id)) {\r\n            return false;\r\n        }\r\n        // 检查投稿时间设置\r\n        if (!this.checkPostDate(option.createDate)) {\r\n            return false;\r\n        }\r\n        // 检查用户阻止名单\r\n        if (!this.checkBlockList(option.userid)) {\r\n            return false;\r\n        }\r\n        // 检查首次登场设置\r\n        if (!this.checkDebut(option.yes_rank)) {\r\n            return false;\r\n        }\r\n        // 检查文件体积设置\r\n        if (!this.checkSize(option.size)) {\r\n            return false;\r\n        }\r\n        // 检查黑白图片\r\n        // 这一步需要加载图片，需要较长的时间，较躲的资源占用，放到最后检查，以避免无谓的执行\r\n        const blackAndWhiteResult = await this.checkBlackWhite(option.mini);\r\n        if (!blackAndWhiteResult) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // ---------------- get ----------------\r\n    // 获取下载的作品类型设置\r\n    getDownType() {\r\n        // 如果全部排除则取消任务\r\n        if (!settings.downType0 &&\r\n            !settings.downType1 &&\r\n            !settings.downType2 &&\r\n            !settings.downType3) {\r\n            this.throwError(lang.transl('_排除了所有作品类型'));\r\n        }\r\n        let notDownTip = '';\r\n        notDownTip += settings.downType0 ? '' : lang.transl('_插画');\r\n        notDownTip += settings.downType1 ? '' : lang.transl('_漫画');\r\n        notDownTip += settings.downType2 ? '' : lang.transl('_动图');\r\n        notDownTip += settings.downType3 ? '' : lang.transl('_小说');\r\n        if (notDownTip) {\r\n            this.logTip(lang.transl('_排除作品类型') + notDownTip);\r\n        }\r\n    }\r\n    getDownTypeByImgCount() {\r\n        let notDownTip = '';\r\n        notDownTip += settings.downSingleImg ? '' : lang.transl('_单图作品');\r\n        notDownTip += settings.downMultiImg ? '' : lang.transl('_多图作品');\r\n        if (notDownTip) {\r\n            this.logTip(lang.transl('_排除作品类型') + notDownTip);\r\n        }\r\n    }\r\n    // 获取图像颜色设置\r\n    getDownTypeByColor() {\r\n        // 如果全部排除则取消任务\r\n        if (!settings.downColorImg && !settings.downBlackWhiteImg) {\r\n            this.throwError(lang.transl('_排除了所有作品类型'));\r\n        }\r\n        let notDownTip = '';\r\n        notDownTip += settings.downColorImg ? '' : lang.transl('_彩色图片');\r\n        notDownTip += settings.downBlackWhiteImg ? '' : lang.transl('_黑白图片');\r\n        if (notDownTip) {\r\n            this.logTip(lang.transl('_排除作品类型') + notDownTip);\r\n        }\r\n    }\r\n    // 获取用户输入的 tag 内容\r\n    getTagString(str) {\r\n        let result = '';\r\n        if (str) {\r\n            let tempArr = str.split(',');\r\n            // 如果用户在末尾也输入了逗号，则会产生一个空值，去掉它\r\n            if (tempArr[tempArr.length - 1] === '') {\r\n                tempArr.pop();\r\n            }\r\n            result = tempArr.join(',');\r\n        }\r\n        return result;\r\n    }\r\n    // 获取必须包含的tag\r\n    getIncludeTag() {\r\n        if (!settings.needTagSwitch) {\r\n            return;\r\n        }\r\n        this._needTag = this.getTagString(settings.needTag);\r\n        if (this._needTag) {\r\n            this.logTip(lang.transl('_设置了必须tag之后的提示') + this._needTag);\r\n        }\r\n    }\r\n    // 获取要排除的tag\r\n    getExcludeTag() {\r\n        if (!settings.notNeedTagSwitch) {\r\n            return;\r\n        }\r\n        this._notNeedTag = this.getTagString(settings.notNeedTag);\r\n        if (this._notNeedTag) {\r\n            this.logTip(lang.transl('_设置了排除tag之后的提示') + this._notNeedTag);\r\n        }\r\n    }\r\n    // 获取宽高设置\r\n    getSetWh() {\r\n        if (!settings.setWHSwitch) {\r\n            return;\r\n        }\r\n        const width = API.checkNumberGreater0(settings.setWidth);\r\n        const height = API.checkNumberGreater0(settings.setHeight);\r\n        this._setWidth = width.result ? width.value : 0;\r\n        this._setHeight = height.result ? height.value : 0;\r\n        if (this._setWidth || this._setHeight) {\r\n            const andOr = settings.setWidthAndOr\r\n                .replace('|', lang.transl('_或者'))\r\n                .replace('&', lang.transl('_并且'));\r\n            const text = `${lang.transl('_宽度')} ${settings.widthHeightLimit} ${this._setWidth} ${andOr} ${lang.transl('_高度')} ${settings.widthHeightLimit} ${this._setHeight}`;\r\n            this.logTip(text);\r\n        }\r\n    }\r\n    // 获取输入的收藏数\r\n    getBMKNum() {\r\n        if (!settings.BMKNumSwitch) {\r\n            return;\r\n        }\r\n        this._BMKNumMin = this.BMKNumMinDef;\r\n        this._BMKNumMax = this.BMKNumMaxDef;\r\n        const min = API.checkNumberGreater0(settings.BMKNumMin);\r\n        const max = API.checkNumberGreater0(settings.BMKNumMax);\r\n        if (min.result) {\r\n            this._BMKNumMin = min.value;\r\n            this.logTip(lang.transl('_收藏数大于') + min.value);\r\n        }\r\n        if (max.result) {\r\n            this._BMKNumMax = max.value;\r\n            this.logTip(lang.transl('_收藏数小于') + max.value);\r\n        }\r\n    }\r\n    // 获取只下载已收藏的设置\r\n    getOnlyBmk() {\r\n        if (settings.setOnlyBmk) {\r\n            this.logTip(lang.transl('_只下载已收藏的提示'));\r\n        }\r\n    }\r\n    // 获取宽高比设置\r\n    getRatio() {\r\n        if (!settings.ratioSwitch) {\r\n            return '0';\r\n        }\r\n        let result = settings.ratio;\r\n        if (result === '1') {\r\n            this.logTip(lang.transl('_设置了宽高比之后的提示', lang.transl('_横图')));\r\n        }\r\n        else if (result === '2') {\r\n            this.logTip(lang.transl('_设置了宽高比之后的提示', lang.transl('_竖图')));\r\n        }\r\n        else if (result === '3') {\r\n            // 由用户输入\r\n            const typeNum = parseFloat(settings.userRatio);\r\n            if (isNaN(typeNum)) {\r\n                const msg = lang.transl('_宽高比必须是数字');\r\n                this.throwError(msg);\r\n            }\r\n            else {\r\n                this.logTip(lang.transl('_输入宽高比') + settings.userRatio);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    // 获取 id 范围设置\r\n    getIdRange() {\r\n        if (!settings.idRangeSwitch) {\r\n            return;\r\n        }\r\n        const result = settings.idRange;\r\n        if (result === '1' || result === '2') {\r\n            let id = parseInt(settings.idRangeInput);\r\n            if (isNaN(id)) {\r\n                const msg = 'Error: id range is not a number!';\r\n                this.throwError(msg);\r\n            }\r\n        }\r\n        if (result === '1') {\r\n            this.logTip(`id > ${settings.idRangeInput}`);\r\n        }\r\n        if (result === '2') {\r\n            this.logTip(`id < ${settings.idRangeInput}`);\r\n        }\r\n        return result;\r\n    }\r\n    // 获取投稿时间设置\r\n    getPostDate() {\r\n        if (!settings.postDate ||\r\n            settings.postDateStart === '' ||\r\n            settings.postDateEnd === '') {\r\n            return;\r\n        }\r\n        // 判断是否是有效的时间格式\r\n        const postDateStart = new Date(settings.postDateStart);\r\n        const postDateEnd = new Date(settings.postDateEnd);\r\n        // 如果输入的时间可以被转换成有效的时间，则启用\r\n        // 转换时间失败时，值是 Invalid Date，不能转换成数字\r\n        if (isNaN(postDateStart.getTime()) || isNaN(postDateEnd.getTime())) {\r\n            const msg = 'Date format error!';\r\n            this.throwError(msg);\r\n        }\r\n        else {\r\n            // 转换时间成功\r\n            this._postDateStart = postDateStart.getTime();\r\n            this._postDateEnd = postDateEnd.getTime();\r\n            this.logTip(`${lang.transl('_时间范围')}: ${settings.postDateStart} - ${settings.postDateEnd}`);\r\n        }\r\n    }\r\n    // 获取文件体积设置\r\n    getSize() {\r\n        if (settings.sizeSwitch) {\r\n            let min = parseFloat(settings.sizeMin);\r\n            isNaN(min) && (min = 0);\r\n            let max = parseFloat(settings.sizeMax);\r\n            isNaN(max) && (min = 100);\r\n            // 如果输入的最小值比最大值还要大，则交换它们的值\r\n            if (min > max) {\r\n                ;\r\n                [min, max] = [max, min];\r\n            }\r\n            this._sizeMin = min * this.MiB;\r\n            this._sizeMax = max * this.MiB;\r\n            this.logTip(`Size: ${min}MiB - ${max}MiB`);\r\n        }\r\n    }\r\n    getBlockList() {\r\n        if (!settings.userBlockList) {\r\n            this.blockList = [];\r\n            return;\r\n        }\r\n        const temp = settings.blockList.trim().split(',');\r\n        // 因为输入的值只用来比较，没有其他用途，所以不必严格检查 id 的有效性\r\n        this.blockList = temp.filter((val) => {\r\n            return val !== '';\r\n        });\r\n        if (this.blockList.length > 0) {\r\n            this.logTip(lang.transl('_用户阻止名单') + ': ' + this.blockList.join(','));\r\n        }\r\n    }\r\n    // ---------------- check ----------------\r\n    // 检查下载的作品类型设置\r\n    checkDownType(illustType) {\r\n        if (illustType === undefined) {\r\n            return true;\r\n        }\r\n        const name = ('downType' + illustType);\r\n        return settings[name];\r\n    }\r\n    // 依据图片数量，检查下载的作品类型\r\n    checkPageCount(illustType, pageCount) {\r\n        if (illustType === undefined || pageCount === undefined) {\r\n            return true;\r\n        }\r\n        // 将动图视为单图\r\n        if (illustType === 2) {\r\n            pageCount = 1;\r\n        }\r\n        if (pageCount === 1) {\r\n            return settings.downSingleImg;\r\n        }\r\n        if (pageCount > 1) {\r\n            return settings.downMultiImg;\r\n        }\r\n        return false;\r\n    }\r\n    // 检查过滤黑白图像设置\r\n    async checkBlackWhite(imgUrl) {\r\n        // 如果没有图片网址，或者没有排除任何一个选项，则不检查\r\n        if (!imgUrl || (settings.downColorImg && settings.downBlackWhiteImg)) {\r\n            return true;\r\n        }\r\n        // result 为 true，表示它是黑白图片，false 是彩色图片\r\n        const result = await blackAndWhiteImage.check(imgUrl);\r\n        return ((result && settings.downBlackWhiteImg) ||\r\n            (!result && settings.downColorImg));\r\n    }\r\n    // 检查收藏数要求\r\n    checkBMK(bmk) {\r\n        if (bmk === undefined || !settings.BMKNumSwitch) {\r\n            return true;\r\n        }\r\n        return bmk >= this._BMKNumMin && bmk <= this._BMKNumMax;\r\n    }\r\n    // 检查作品是否符合【只下载已收藏】的条件,返回值 true 表示包含这个作品\r\n    checkOnlyBmk(bookmarked) {\r\n        if (bookmarked === undefined || !settings.setOnlyBmk) {\r\n            return true;\r\n        }\r\n        return !!bookmarked;\r\n    }\r\n    // 检查作品是否符合包含 tag 的条件。返回值表示是否保留这个作品。\r\n    checkIncludeTag(tags) {\r\n        if (!settings.needTagSwitch || !this._needTag || tags === undefined) {\r\n            return true;\r\n        }\r\n        let result = false;\r\n        // 把设置的包含的 tag 转换成小写，生成数组\r\n        const needTags = this._needTag.split(',').map((val) => {\r\n            return val.toLowerCase();\r\n        });\r\n        // 如果设置了必须的 tag\r\n        if (needTags.length > 0) {\r\n            // 把处理的 tag 变成小写，并且去重\r\n            // 如果不区分大小写的话，Fate/grandorder 和 Fate/GrandOrder 会被算作符合两个 tag，所以用 Set 结构去重。测试 id 51811780\r\n            const workTags = new Set();\r\n            for (const tag of tags) {\r\n                workTags.add(tag.toLowerCase());\r\n            }\r\n            // 全部包含\r\n            if (settings.needTagMode === 'all') {\r\n                let tagNeedMatched = 0;\r\n                for (const tag of workTags) {\r\n                    for (const need of needTags) {\r\n                        if (tag === need) {\r\n                            tagNeedMatched++;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                // 如果全部匹配\r\n                if (tagNeedMatched >= needTags.length) {\r\n                    result = true;\r\n                }\r\n            }\r\n            else {\r\n                // 包含任意一个\r\n                for (const tag of workTags.values()) {\r\n                    if (needTags.includes(tag)) {\r\n                        result = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            result = true;\r\n        }\r\n        return result;\r\n    }\r\n    // 检查作品是否符合排除 tag 的条件, 只要作品包含其中一个就排除。返回值表示是否保留这个作品。\r\n    checkExcludeTag(tags) {\r\n        if (!settings.notNeedTagSwitch || !this._notNeedTag || tags === undefined) {\r\n            return true;\r\n        }\r\n        let result = true;\r\n        const notNeedTags = this._notNeedTag.split(',').map((val) => {\r\n            return val.toLowerCase();\r\n        });\r\n        // 如果设置了排除 tag\r\n        if (notNeedTags.length > 0) {\r\n            for (const tag of tags) {\r\n                for (const notNeed of notNeedTags) {\r\n                    if (tag.toLowerCase() === notNeed) {\r\n                        result = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    // 检查作品是否符合过滤宽高的条件\r\n    checkSetWh(width, height) {\r\n        if (!settings.setWHSwitch) {\r\n            return true;\r\n        }\r\n        // 缺少必要的参数\r\n        if (width === undefined || height === undefined) {\r\n            return true;\r\n        }\r\n        // 未设置宽高，或者设置的宽高都不合法\r\n        if (this._setWidth === 0 && this._setHeight === 0) {\r\n            return true;\r\n        }\r\n        if (settings.widthHeightLimit === '>=') {\r\n            // 大于等于\r\n            if (settings.setWidthAndOr === '&') {\r\n                return width >= this._setWidth && height >= this._setHeight;\r\n            }\r\n            else {\r\n                return width >= this._setWidth || height >= this._setHeight;\r\n            }\r\n        }\r\n        else if (settings.widthHeightLimit === '<=') {\r\n            // 小于等于\r\n            if (settings.setWidthAndOr === '&') {\r\n                return width <= this._setWidth && height <= this._setHeight;\r\n            }\r\n            else {\r\n                return width <= this._setWidth || height <= this._setHeight;\r\n            }\r\n        }\r\n        else {\r\n            // 精确等于\r\n            if (settings.setWidthAndOr === '&') {\r\n                return width === this._setWidth && height === this._setHeight;\r\n            }\r\n            else {\r\n                return width === this._setWidth || height === this._setHeight;\r\n            }\r\n        }\r\n    }\r\n    // 检查作品是否符合宽高比条件\r\n    checkRatio(width, height) {\r\n        if (!settings.ratioSwitch) {\r\n            return true;\r\n        }\r\n        if (width === undefined || height === undefined) {\r\n            return true;\r\n        }\r\n        if (settings.ratio === '1') {\r\n            return width / height > 1;\r\n        }\r\n        else if (settings.ratio === '2') {\r\n            return width / height < 1;\r\n        }\r\n        else {\r\n            return width / height >= parseFloat(settings.userRatio);\r\n        }\r\n    }\r\n    // 检查 id 范围设置\r\n    checkIdRange(id) {\r\n        if (id === undefined || !settings.idRangeSwitch) {\r\n            return true;\r\n        }\r\n        const nowId = parseInt(id.toString());\r\n        const setId = parseInt(settings.idRangeInput);\r\n        if (settings.idRange === '1') {\r\n            // 大于\r\n            return nowId > setId;\r\n        }\r\n        else if (settings.idRange === '2') {\r\n            // 小于\r\n            return nowId < setId;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n    // 检查投稿时间设置\r\n    checkPostDate(date) {\r\n        if (!settings.postDate ||\r\n            date === undefined ||\r\n            !this._postDateStart ||\r\n            !this._postDateEnd) {\r\n            return true;\r\n        }\r\n        const nowDate = new Date(date);\r\n        return (nowDate.getTime() >= this._postDateStart &&\r\n            nowDate.getTime() <= this._postDateEnd);\r\n    }\r\n    // 检查首次登场设置\r\n    // yes_rank 是昨日排名，如果为 0，则此作品是“首次登场”的作品\r\n    checkDebut(yes_rank) {\r\n        if (!states.debut || yes_rank === undefined) {\r\n            return true;\r\n        }\r\n        return yes_rank === 0;\r\n    }\r\n    checkBlockList(userid) {\r\n        if (!settings.userBlockList || userid === undefined) {\r\n            return true;\r\n        }\r\n        // 如果阻止名单里有这个用户 id，则返回 false 表示阻止这个作品\r\n        return !this.blockList.includes(userid);\r\n    }\r\n    // 检查文件体积\r\n    checkSize(size) {\r\n        if (!settings.sizeSwitch || size === undefined) {\r\n            return true;\r\n        }\r\n        return size >= this._sizeMin && size <= this._sizeMax;\r\n    }\r\n    // 在日志区域输出提示\r\n    logTip(str) {\r\n        if (!this.showTip) {\r\n            return;\r\n        }\r\n        log.warning(str);\r\n    }\r\n    // 如果设置项的值不合法，则抛出错误\r\n    throwError(msg) {\r\n        EVT.fire(EVT.list.wrongSetting);\r\n        log.error(msg, 2);\r\n        EVT.sendMsg({\r\n            msg: msg,\r\n            type: 'error',\r\n        });\r\n        throw new Error(msg);\r\n    }\r\n    bindEvents() {\r\n        window.addEventListener(EVT.list.crawlStart, () => {\r\n            this.init(true);\r\n        });\r\n        for (const ev of [EVT.list.settingChange, EVT.list.resume]) {\r\n            window.addEventListener(ev, () => {\r\n                this.init();\r\n            });\r\n        }\r\n    }\r\n}\r\nconst filter = new Filter();\r\nexport { filter };\r\n","// 把图片转换成 icon 文件\r\n// icon 文件结构 https://www.cnblogs.com/cswuyg/p/3603707.html\r\n// 输入选项\r\n// source 图片的 url，或者一个图片文件（如果使用了图片 url，请注意跨域策略的影响）\r\n// size 尺寸，可以同时使用多个尺寸。你也可以使用自定义尺寸。\r\n// shape 指定图标的形状。square 正方形，circle 圆形，fillet 带有圆角的正方形\r\n// bleed 留白，仅当形状是圆角正方形时生效，可以使图片周围有一些留白。\r\n// 输出\r\n// 转换成功后，返回 icon 文件的 Blob 对象\r\n// 生成的 icon 总是正方形（长和宽相等）。如果图片的长度和宽度不相等，则会以窄边作为基准，从窄边开始裁剪出一个正方形\r\n// 生成的 icon 可以包含多种尺寸的图标。图标都是 32 位 png 图像。\r\nclass ImageToIcon {\r\n    async convert(opt) {\r\n        return new Promise(async (resolve, reject) => {\r\n            // 加载图片\r\n            const img = await this.loadImage(opt.source);\r\n            // 生成各尺寸的 png 图像的数据\r\n            const pngDataArray = await this.createPngBuffer(img, opt.size, opt.shape, opt.bleed);\r\n            // 创建 ico 文件\r\n            const blob = this.createIcon(pngDataArray);\r\n            resolve(blob);\r\n        });\r\n    }\r\n    async convertImageURL(source) {\r\n        return new Promise(async (resolve, reject) => {\r\n            if (typeof source === 'string') {\r\n                // 请求图片，并为其生成 BlobURL，解决图片跨域导致 canvas 污染的问题\r\n                const res = await fetch(source, {\r\n                    method: 'get',\r\n                    credentials: 'same-origin',\r\n                });\r\n                const blob = await res.blob();\r\n                resolve(URL.createObjectURL(blob));\r\n            }\r\n            else if (source instanceof File) {\r\n                resolve(URL.createObjectURL(source));\r\n            }\r\n            else {\r\n                reject('Unrecognized opt.source');\r\n            }\r\n        });\r\n    }\r\n    async loadImage(source) {\r\n        return new Promise(async (resolve, reject) => {\r\n            let imgURL = await this.convertImageURL(source);\r\n            const i = document.createElement('img');\r\n            i.src = imgURL;\r\n            i.onload = function () {\r\n                resolve(i);\r\n            };\r\n        });\r\n    }\r\n    async createPngBuffer(img, size = [16, 48, 96, 256], shape = 'square', bleed = true) {\r\n        return new Promise(async (resolve, reject) => {\r\n            const buffer = [];\r\n            let length = size.length;\r\n            while (length > 0) {\r\n                const sizeNumber = size[size.length - length];\r\n                const canvas = this.createCanvas(sizeNumber, img);\r\n                // 绘制图像\r\n                this.drawImage(canvas, img, shape, bleed);\r\n                // 把图像转换为 png 图像\r\n                const pngBlob = await this.getPngBlob(canvas);\r\n                // 获取 png 图像的 buffer\r\n                const buf = await pngBlob.arrayBuffer();\r\n                buffer.push({\r\n                    size: sizeNumber,\r\n                    buffer: buf,\r\n                });\r\n                length--;\r\n                if (length === 0) {\r\n                    resolve(buffer);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    createCanvas(size, img) {\r\n        const c = document.createElement('canvas');\r\n        c.width = size;\r\n        c.height = size;\r\n        return c;\r\n    }\r\n    drawImage(canvas, img, shape, bleed = true) {\r\n        const ctx = canvas.getContext('2d');\r\n        if (!ctx) {\r\n            console.error('draw error: ctx is null');\r\n            return;\r\n        }\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n        // 计算图像被绘制的宽高。比较短的一边占满画布，比较长的一边则根据比例计算绘制的部分\r\n        let dw = 0;\r\n        let dh = 0;\r\n        // 竖图\r\n        if (img.naturalWidth < img.naturalHeight) {\r\n            dw = canvas.width;\r\n            dh = (dw / img.naturalWidth) * img.naturalHeight;\r\n        }\r\n        else {\r\n            // 横图\r\n            dh = canvas.height;\r\n            dw = (dh / img.naturalHeight) * img.naturalWidth;\r\n        }\r\n        // 绘制方形\r\n        if (shape === 'square') {\r\n            ctx.drawImage(img, 0, 0, dw, dh);\r\n        }\r\n        // 绘制圆形\r\n        if (shape === 'circle') {\r\n            let circle = {\r\n                x: canvas.width / 2,\r\n                y: canvas.width / 2,\r\n                r: canvas.width / 2,\r\n            };\r\n            ctx.save();\r\n            ctx.beginPath();\r\n            ctx.arc(circle.x, circle.y, circle.r, 0, Math.PI * 2, false);\r\n            ctx.clip();\r\n            ctx.drawImage(img, 0, 0, dw, dh);\r\n            ctx.restore();\r\n        }\r\n        // 绘制圆角矩形\r\n        if (shape === 'fillet') {\r\n            let x = 0;\r\n            let y = 0;\r\n            // 当图标尺寸大于 16 时，设置留白距离\r\n            if (bleed && canvas.width > 16) {\r\n                let num = 10 / 256; // 规定留白的比例，即尺寸为 256 时四周留白均为 10 px\r\n                x = Math.ceil(num * canvas.width);\r\n                y = Math.ceil(num * canvas.width);\r\n            }\r\n            // 去掉留白后，最后要保存的图片区域的宽高\r\n            const w = canvas.width - x * 2;\r\n            const h = canvas.height - y * 2;\r\n            // 圆角的半径，设置为保留区域宽高的 1/8\r\n            const r = Math.floor(w / 8);\r\n            ctx.beginPath();\r\n            ctx.moveTo(x + r, y);\r\n            ctx.arcTo(x + w, y, x + w, y + h, r);\r\n            ctx.arcTo(x + w, y + h, x, y + h, r);\r\n            ctx.arcTo(x, y + h, x, y, r);\r\n            ctx.arcTo(x, y, x + w, y, r);\r\n            ctx.closePath();\r\n            ctx.clip();\r\n            ctx.drawImage(img, 0, 0, dw, dh);\r\n        }\r\n        return ctx;\r\n    }\r\n    async getPngBlob(canvas) {\r\n        return new Promise((resolve, reject) => {\r\n            canvas.toBlob((blob) => {\r\n                if (!blob) {\r\n                    reject('blob is null');\r\n                }\r\n                else {\r\n                    resolve(blob);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    createIcon(pngData) {\r\n        const fileData = [];\r\n        const fileHeadSize = 6;\r\n        // icon 文件头\r\n        const fileHead = new ArrayBuffer(fileHeadSize);\r\n        const v1 = new DataView(fileHead);\r\n        v1.setInt16(0, 0, true); // idReserved\r\n        v1.setInt16(2, 1, true); // idType\r\n        v1.setInt16(4, pngData.length, true); // idCount\r\n        fileData.push(fileHead);\r\n        // 添加 icon 文件入口\r\n        const entrySize = 16;\r\n        const entryTotalSize = entrySize * pngData.length;\r\n        let fileOffset = fileHeadSize + entryTotalSize;\r\n        let fileLength = 0;\r\n        for (const d of pngData) {\r\n            fileOffset += fileLength;\r\n            const entry = new ArrayBuffer(entrySize);\r\n            const v2 = new DataView(entry);\r\n            v2.setInt8(0, d.size); // Width, in pixels, of the image\r\n            v2.setInt8(1, d.size); // Height, in pixels, of the image\r\n            v2.setInt8(2, 0); // Number of colors in image (0 if >=8bpp)\r\n            v2.setInt8(3, 0); // Reserved ( must be 0)\r\n            v2.setInt16(4, 1, true); // Color Planes\r\n            v2.setInt16(6, 32, true); // Bits per pixel\r\n            v2.setInt32(8, d.buffer.byteLength, true); // How many bytes in this resource?\r\n            v2.setInt32(12, fileOffset, true); // Where in the file is this image?\r\n            fileData.push(entry);\r\n            fileLength = d.buffer.byteLength;\r\n        }\r\n        // 添加 png 数据\r\n        for (const d of pngData) {\r\n            fileData.push(d.buffer);\r\n        }\r\n        // 生成 blob 对象\r\n        return new Blob(fileData, {\r\n            type: 'image/vnd.microsoft.icon',\r\n        });\r\n    }\r\n}\r\nconst img2ico = new ImageToIcon();\r\nexport { img2ico };\r\n","// 图片查看器\r\n/// <reference path = \"./Viewer.d.ts\" />\r\nimport { API } from './API';\r\nimport { theme } from './Theme';\r\nclass ImgViewer {\r\n    constructor() {\r\n        this.viewerWarpper = document.createElement('div'); // 图片列表的容器\r\n        this.viewerUl = document.createElement('ul'); // 图片列表的 ul 元素\r\n        this.init();\r\n    }\r\n    // 初始化图片查看器\r\n    newViewer(pageCount, firsturl) {\r\n        // 因为选项里的 size 是枚举类型，所以在这里也要定义一个枚举\r\n        let ToolbarButtonSize;\r\n        (function (ToolbarButtonSize) {\r\n            ToolbarButtonSize[\"Small\"] = \"small\";\r\n            ToolbarButtonSize[\"Medium\"] = \"medium\";\r\n            ToolbarButtonSize[\"Large\"] = \"large\";\r\n        })(ToolbarButtonSize || (ToolbarButtonSize = {}));\r\n        this.myViewer = new Viewer(this.viewerUl, {\r\n            toolbar: {\r\n                zoomIn: 0,\r\n                zoomOut: 0,\r\n                oneToOne: 1,\r\n                reset: 0,\r\n                prev: 1,\r\n                play: {\r\n                    show: 0,\r\n                    size: ToolbarButtonSize.Large,\r\n                },\r\n                next: 1,\r\n                rotateLeft: 0,\r\n                rotateRight: 0,\r\n                flipHorizontal: 0,\r\n                flipVertical: 0,\r\n            },\r\n            url(image) {\r\n                return image.dataset.src;\r\n            },\r\n            viewed(ev) {\r\n                // 当图片显示完成（加载完成）后，预加载下一张图片\r\n                let index = ev.detail.index;\r\n                if (index < pageCount - 1) {\r\n                    index++;\r\n                }\r\n                const nextImg = firsturl.replace('p0', 'p' + index);\r\n                const img = new Image();\r\n                img.src = nextImg;\r\n            },\r\n            // 取消一些动画，比如切换图片时，图片从小变大出现的动画\r\n            transition: false,\r\n            // 取消键盘支持，主要是用键盘左右方向键切换的话，会和 pixiv 页面产生冲突。（pixiv 页面上，左右方向键会切换作品）\r\n            keyboard: false,\r\n            // 不显示 title（图片名和宽高信息）\r\n            title: false,\r\n            // 不显示缩放比例\r\n            tooltip: false,\r\n        });\r\n    }\r\n    init() {\r\n        // 如果之前已经存在图片查看器的元素，则删除重新创建\r\n        // 最好不要重复使用之前的元素。在页面无刷新切换之后，如果复用了之前的元素，只是修改一些内容，那么 Viewer 还是会使用之前的数据，导致出错。\r\n        const test = document.querySelector('main #viewerWarpper');\r\n        test && test.remove();\r\n        // 每次创建新的图片查看器时，删除之前查看器的元素，否则会存在多个\r\n        const test2 = document.querySelector('.viewer-container');\r\n        test2 && test2.remove();\r\n        this.createViewer();\r\n    }\r\n    // 创建图片查看器 html 元素，并绑定一些事件，这个函数只会在初始化时执行一次\r\n    createViewer() {\r\n        if (!document.querySelector('main figcaption')) {\r\n            // 等到作品主体部分的元素生成之后再创建查看器\r\n            setTimeout(() => {\r\n                this.createViewer();\r\n            }, 300);\r\n            return;\r\n        }\r\n        // 查看器图片列表元素的结构： div#viewerWarpper > ul > li > img\r\n        this.viewerWarpper = document.createElement('div');\r\n        this.viewerWarpper.id = 'viewerWarpper';\r\n        this.viewerUl = document.createElement('ul');\r\n        this.viewerWarpper.appendChild(this.viewerUl);\r\n        theme.register(this.viewerWarpper);\r\n        document\r\n            .querySelector('main figcaption')\r\n            .insertAdjacentElement('beforebegin', this.viewerWarpper);\r\n        // 图片查看器显示之后\r\n        this.viewerUl.addEventListener('shown', () => {\r\n            // 显示相关元素\r\n            this.showViewerOther();\r\n            // 点击 1：1 按钮时，全屏查看\r\n            document\r\n                .querySelector('.viewer-one-to-one')\r\n                .addEventListener('click', () => {\r\n                this.hideViewerOther(); // 隐藏查看器的其他元素\r\n                // 进入全屏\r\n                document.body.requestFullscreen();\r\n                // 使图片居中显示，必须加延迟\r\n                setTimeout(() => {\r\n                    this.setViewerCenter();\r\n                }, 100);\r\n                setInterval(() => {\r\n                    this.zoomToMax();\r\n                }, 100);\r\n            });\r\n        });\r\n        // 全屏状态下，查看和切换图片时，显示比例始终为 100%\r\n        this.viewerUl.addEventListener('view', () => {\r\n            if (this.isFullscreen()) {\r\n                setTimeout(() => {\r\n                    // 通过点击 1:1 按钮，调整为100%并居中。这里必须要加延时，否则点击的时候图片还是旧的\r\n                    ;\r\n                    document.querySelector('.viewer-one-to-one').click();\r\n                }, 50);\r\n            }\r\n        });\r\n        // 隐藏查看器时，如果还处于全屏，则退出全屏\r\n        this.viewerUl.addEventListener('hidden', () => {\r\n            if (this.isFullscreen()) {\r\n                document.exitFullscreen();\r\n            }\r\n        });\r\n        // esc 退出图片查看器\r\n        document.addEventListener('keyup', (event) => {\r\n            if (event.code === 'Escape') {\r\n                this.myViewer && this.myViewer.hide();\r\n            }\r\n        });\r\n        void [\r\n            'fullscreenchange',\r\n            'webkitfullscreenchange',\r\n            'mozfullscreenchange',\r\n        ].forEach((arg) => {\r\n            // 检测全屏状态变化，目前有兼容性问题（这里也相当于绑定了按 esc 退出的事件）\r\n            document.addEventListener(arg, () => {\r\n                // 退出全屏\r\n                if (!this.isFullscreen()) {\r\n                    this.showViewerOther();\r\n                }\r\n            });\r\n        });\r\n        this.updateViewer();\r\n    }\r\n    // 根据作品信息，更新图片查看器配置。每当页面更新时执行一次\r\n    async updateViewer() {\r\n        this.viewerWarpper.style.display = 'none'; // 先隐藏 viewerWarpper\r\n        // 获取作品信息\r\n        const data = await API.getArtworkData(API.getIllustId());\r\n        const body = data.body;\r\n        // 处理插画或漫画作品，不处理动图作品\r\n        if (body.illustType === 0 || body.illustType === 1) {\r\n            // 有多张图片时，创建缩略图\r\n            if (body.pageCount > 1) {\r\n                const { thumb, original } = body.urls;\r\n                // 生成缩略图列表\r\n                let html = [];\r\n                for (let index = 0; index < body.pageCount; index++) {\r\n                    const str = `<li><img src=\"${thumb.replace('p0', 'p' + index)}\" data-src=\"${original.replace('p0', 'p' + index)}\"></li>`;\r\n                    html.push(str);\r\n                }\r\n                this.viewerUl.innerHTML = html.join('');\r\n                // 数据更新后，显示 viewerWarpper\r\n                this.viewerWarpper.style.display = 'block';\r\n                // 销毁看图组件\r\n                if (this.myViewer) {\r\n                    this.myViewer.destroy();\r\n                }\r\n                // 配置看图组件\r\n                this.newViewer(body.pageCount, original);\r\n                // 预加载第一张图片\r\n                const img = new Image();\r\n                img.src = original;\r\n            }\r\n        }\r\n    }\r\n    // 隐藏查看器的其他元素\r\n    hideViewerOther() {\r\n        document\r\n            .querySelector('.viewer-container')\r\n            .classList.add('black-background');\r\n        // 隐藏底部的其他元素，仍然显示左右切换按钮\r\n        const close = document.querySelector('.viewer-close');\r\n        const oneToOne = document.querySelector('.viewer-one-to-one');\r\n        const navbar = document.querySelector('.viewer-navbar');\r\n        for (const element of [close, oneToOne, navbar]) {\r\n            element.style.display = 'none';\r\n        }\r\n    }\r\n    // 显示查看器的其他元素\r\n    showViewerOther() {\r\n        document\r\n            .querySelector('.viewer-container')\r\n            .classList.remove('black-background');\r\n        // 显示底部隐藏的元素\r\n        const close = document.querySelector('.viewer-close');\r\n        const oneToOne = document.querySelector('.viewer-one-to-one');\r\n        const navbar = document.querySelector('.viewer-navbar');\r\n        for (const element of [close, oneToOne, navbar]) {\r\n            element.style.display = 'block';\r\n        }\r\n    }\r\n    zoomToMax() {\r\n        const img = document.querySelector('.viewer-move');\r\n        if (this.isFullscreen() && parseInt(img.style.width) < img.naturalWidth) {\r\n            // img.style.width=img.naturalWidth+'px'\r\n            // img.style.height = img.naturalHeight+'px'\r\n            this.myViewer.zoomTo(1);\r\n        }\r\n    }\r\n    // 在图片100%显示时，使其居中\r\n    setViewerCenter() {\r\n        // 获取图片宽高\r\n        const imgInfo = document.querySelector('.viewer-title').textContent;\r\n        // 如果图片尚未加载出来的话，就没有内容，就过一会儿再执行\r\n        if (!imgInfo) {\r\n            setTimeout(() => {\r\n                this.setViewerCenter();\r\n            }, 200);\r\n            return;\r\n        }\r\n        const [imgWidth, imgHeight] = /\\d{1,5} × \\d{1,5}/\r\n            .exec(imgInfo)[0]\r\n            .split(' × ');\r\n        // > '66360324_p5_master1200.jpg (919 × 1300)'\r\n        // < [\"919\", \"1300\"]\r\n        // 获取网页宽高\r\n        const htmlWidth = document.documentElement.clientWidth;\r\n        const htmlHeight = document.documentElement.clientHeight;\r\n        // 设置边距\r\n        const setWidth = (htmlWidth - parseInt(imgWidth)) / 2;\r\n        let setHeight = (htmlHeight - parseInt(imgHeight)) / 2;\r\n        // 当图片高度大于浏览器窗口高度时，居顶显示而不是居中\r\n        // if (setHeight < 0) {\r\n        //   setHeight = 0\r\n        // }\r\n        this.myViewer.zoomTo(1);\r\n        this.myViewer.moveTo(setWidth, setHeight);\r\n    }\r\n    // 判断是否处于全屏状态\r\n    isFullscreen() {\r\n        return !!document.fullscreenElement;\r\n    }\r\n    // 判断看图器是否处于显示状态\r\n    viewerIsShow() {\r\n        const viewerContainer = document.querySelector('.viewer-container');\r\n        if (viewerContainer) {\r\n            return viewerContainer.classList.contains('viewer-in');\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\nexport { ImgViewer };\r\n","// 封装操作 IndexedDB 的一些公共方法，仅满足本程序使用，并不完善\r\nclass IndexedDB {\r\n    async open(DBName, DBVer, onUpgrade) {\r\n        return new Promise((resolve, reject) => {\r\n            const request = indexedDB.open(DBName, DBVer);\r\n            request.onupgradeneeded = (ev) => {\r\n                if (onUpgrade) {\r\n                    onUpgrade(request.result);\r\n                }\r\n            };\r\n            request.onsuccess = (ev) => {\r\n                this.db = request.result;\r\n                resolve(request.result);\r\n            };\r\n            request.onerror = (ev) => {\r\n                console.error('open indexDB failed');\r\n                console.trace();\r\n                reject(ev);\r\n            };\r\n        });\r\n    }\r\n    async add(storeNames, data) {\r\n        return new Promise((resolve, reject) => {\r\n            if (this.db === undefined) {\r\n                reject('Database is not defined');\r\n                return;\r\n            }\r\n            const r = this.db\r\n                .transaction(storeNames, 'readwrite')\r\n                .objectStore(storeNames)\r\n                .add(data);\r\n            r.onsuccess = (ev) => {\r\n                resolve(ev);\r\n            };\r\n            r.onerror = (ev) => {\r\n                console.error('add failed');\r\n                console.trace();\r\n                reject(ev);\r\n            };\r\n        });\r\n    }\r\n    async put(storeNames, data) {\r\n        return new Promise((resolve, reject) => {\r\n            if (this.db === undefined) {\r\n                reject('Database is not defined');\r\n                return;\r\n            }\r\n            const r = this.db\r\n                .transaction(storeNames, 'readwrite')\r\n                .objectStore(storeNames)\r\n                .put(data);\r\n            r.onsuccess = (ev) => {\r\n                resolve(ev);\r\n            };\r\n            r.onerror = (ev) => {\r\n                console.error('put failed');\r\n                console.trace();\r\n                reject(ev);\r\n            };\r\n        });\r\n    }\r\n    // 向一个存储库中批量添加数据\r\n    async batchAddData(storeName, dataList, key) {\r\n        return new Promise(async (resolve, reject) => {\r\n            var _a;\r\n            if (dataList.length === 0) {\r\n                resolve();\r\n            }\r\n            // 获取已存在的 key\r\n            let existedKeys = (await this.getAllKeys(storeName));\r\n            // 使用事务\r\n            const tr = (_a = this.db) === null || _a === void 0 ? void 0 : _a.transaction(storeName, 'readwrite');\r\n            if (!tr) {\r\n                throw new Error(`transaction ${storeName} is undefined`);\r\n            }\r\n            const store = tr.objectStore(storeName);\r\n            tr.oncomplete = () => {\r\n                resolve();\r\n            };\r\n            tr.onerror = (err) => {\r\n                console.error(err);\r\n                console.trace();\r\n                reject(err);\r\n            };\r\n            for (const data of dataList) {\r\n                await insert(data);\r\n            }\r\n            async function insert(data) {\r\n                return new Promise((resolve, reject) => {\r\n                    // 如果 key 已存在，则使用 put\r\n                    const type = existedKeys.includes(data[key])\r\n                        ? 'put'\r\n                        : 'add';\r\n                    const request = store[type](data);\r\n                    request.onsuccess = () => {\r\n                        resolve();\r\n                    };\r\n                    request.onerror = (err) => {\r\n                        reject(err);\r\n                    };\r\n                });\r\n            }\r\n        });\r\n    }\r\n    // 如果没有找到对应的记录，则返回 null\r\n    async get(storeNames, key, index) {\r\n        return new Promise((resolve, reject) => {\r\n            if (this.db === undefined) {\r\n                reject('Database is not defined');\r\n                return;\r\n            }\r\n            const store = this.db\r\n                .transaction(storeNames, 'readonly')\r\n                .objectStore(storeNames);\r\n            let r;\r\n            if (index !== undefined) {\r\n                const i = store.index(index);\r\n                r = i.get(key);\r\n            }\r\n            else {\r\n                r = store.get(key);\r\n            }\r\n            r.onsuccess = (ev) => {\r\n                const data = r.result;\r\n                resolve(data ? data : null);\r\n            };\r\n            r.onerror = (ev) => {\r\n                console.error('get failed');\r\n                console.trace();\r\n                reject(ev);\r\n            };\r\n        });\r\n    }\r\n    async getAll(storeNames) {\r\n        return new Promise((resolve, reject) => {\r\n            if (this.db === undefined) {\r\n                reject('Database is not defined');\r\n                return;\r\n            }\r\n            const r = this.db\r\n                .transaction(storeNames, 'readwrite')\r\n                .objectStore(storeNames)\r\n                .getAll();\r\n            r.onsuccess = (ev) => {\r\n                const data = r.result;\r\n                if (data) {\r\n                    resolve(data);\r\n                }\r\n                resolve(data ? data : null);\r\n            };\r\n            r.onerror = (ev) => {\r\n                console.error('getAll failed');\r\n                console.trace();\r\n                reject(ev);\r\n            };\r\n        });\r\n    }\r\n    async getAllKeys(storeNames) {\r\n        return new Promise((resolve, reject) => {\r\n            if (this.db === undefined) {\r\n                reject('Database is not defined');\r\n                return;\r\n            }\r\n            const r = this.db\r\n                .transaction(storeNames, 'readonly')\r\n                .objectStore(storeNames)\r\n                .getAllKeys();\r\n            r.onsuccess = (ev) => {\r\n                const data = r.result;\r\n                resolve(data ? data : null);\r\n            };\r\n            r.onerror = (ev) => {\r\n                console.error('getAllKeys failed');\r\n                console.trace();\r\n                reject(ev);\r\n            };\r\n        });\r\n    }\r\n    async delete(storeNames, key) {\r\n        return new Promise((resolve, reject) => {\r\n            if (this.db === undefined) {\r\n                reject('Database is not defined');\r\n                return;\r\n            }\r\n            const r = this.db\r\n                .transaction(storeNames, 'readwrite')\r\n                .objectStore(storeNames)\r\n                .delete(key);\r\n            r.onsuccess = (ev) => {\r\n                resolve(ev);\r\n            };\r\n            r.onerror = (ev) => {\r\n                console.error('delete failed');\r\n                console.trace();\r\n                reject(ev);\r\n            };\r\n        });\r\n    }\r\n    async clear(storeNames) {\r\n        return new Promise((resolve, reject) => {\r\n            if (this.db === undefined) {\r\n                reject('Database is not defined');\r\n                return;\r\n            }\r\n            const r = this.db\r\n                .transaction(storeNames, 'readwrite')\r\n                .objectStore(storeNames)\r\n                .clear();\r\n            r.onsuccess = (ev) => {\r\n                resolve();\r\n            };\r\n            r.onerror = (ev) => {\r\n                console.error('clear failed');\r\n                console.trace();\r\n                reject(ev);\r\n            };\r\n        });\r\n    }\r\n    async openCursor(storeNames, CB) {\r\n        return new Promise((resolve, reject) => {\r\n            if (this.db === undefined) {\r\n                reject('Database is not defined');\r\n                return;\r\n            }\r\n            const r = this.db\r\n                .transaction(storeNames)\r\n                .objectStore(storeNames)\r\n                .openCursor();\r\n            r.onsuccess = (ev) => {\r\n                CB(r.result);\r\n                resolve(); // 这个 resolve 会在 cb 执行一次之后就触发\r\n            };\r\n            r.onerror = (ev) => {\r\n                console.error('openCursor failed');\r\n                console.trace();\r\n                reject(ev);\r\n            };\r\n        });\r\n    }\r\n}\r\nexport { IndexedDB };\r\n","// 初始化旧版收藏页面\r\nimport { InitPageBase } from './InitPageBase';\r\nimport { API } from './API';\r\nimport { Colors } from './Colors';\r\nimport { token } from './Token';\r\nimport { lang } from './Lang';\r\nimport { options } from './setting/Options';\r\nimport { BookmarksAddTag } from './BookmarksAddTag';\r\nimport { store } from './Store';\r\nimport { log } from './Log';\r\nimport { DOM } from './DOM';\r\nclass InitBookmarkLegacyPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.idList = []; // 储存从列表页获取到的 id\r\n        this.type = 'illusts'; // 页面是图片还是小说\r\n        this.isHide = false; // 当前页面是否显示的是非公开收藏\r\n        this.requsetNumber = 0; // 根据页数，计算要抓取的作品个数\r\n        this.onceRequest = 100; // 每次请求多少个数量\r\n        this.offset = 0; // 要去掉的作品数量\r\n        this.crawlRecommended = false; // 是否抓取推荐作品（收藏页面下方）\r\n        this.init();\r\n    }\r\n    addCrawlBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_开始抓取') + lang.transl('_默认下载多页')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n        // 添加下载推荐作品的按钮\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_抓取推荐作品'), [\r\n            ['title', lang.transl('_抓取推荐作品Title')],\r\n        ]).addEventListener('click', () => {\r\n            this.crawlRecommended = true;\r\n            this.readyCrawl();\r\n        }, false);\r\n    }\r\n    addAnyElement() {\r\n        // 如果存在 token，则添加“添加 tag”按钮\r\n        if (token.token) {\r\n            const btn = DOM.addBtn('otherBtns', Colors.green, lang.transl('_给未分类作品添加添加tag'), [['title', lang.transl('_给未分类作品添加添加tag')]]);\r\n            new BookmarksAddTag(btn);\r\n        }\r\n    }\r\n    setFormOption() {\r\n        // 个数/页数选项的提示\r\n        options.setWantPageTip({\r\n            text: lang.transl('_页数'),\r\n            tip: lang.transl('_从本页开始下载提示'),\r\n            rangTip: lang.transl('_数字提示1'),\r\n        });\r\n        // 在书签页面隐藏只要书签选项\r\n        options.hideOption([6]);\r\n    }\r\n    getWantPage() {\r\n        let pageTip = '';\r\n        if (this.crawlRecommended) {\r\n            pageTip = lang.transl('_下载推荐作品');\r\n        }\r\n        else {\r\n            pageTip = lang.transl('_下载所有页面');\r\n        }\r\n        this.crawlNumber = this.checkWantPageInput(lang.transl('_从本页开始下载x页'), pageTip);\r\n    }\r\n    nextStep() {\r\n        if (window.location.pathname.includes('/novel')) {\r\n            this.type = 'novels';\r\n        }\r\n        if (this.crawlRecommended) {\r\n            // 下载推荐作品\r\n            this.getRecommendedList();\r\n        }\r\n        else {\r\n            this.readyGetIdList();\r\n            this.getIdList();\r\n        }\r\n    }\r\n    readyGetIdList() {\r\n        // 每页个数\r\n        const onceNumber = 20;\r\n        // 如果前面有页数，就去掉前面页数的作品数量。即：从本页开始下载\r\n        const nowPage = API.getURLSearchField(location.href, 'p'); // 判断当前处于第几页，页码从 1 开始。也可能没有页码\r\n        if (nowPage) {\r\n            this.offset = (parseInt(nowPage) - 1) * onceNumber;\r\n        }\r\n        if (this.offset < 0) {\r\n            this.offset = 0;\r\n        }\r\n        // 根据页数设置，计算要下载的个数\r\n        this.requsetNumber = 0;\r\n        if (this.crawlNumber === -1) {\r\n            this.requsetNumber = 9999999;\r\n        }\r\n        else {\r\n            this.requsetNumber = onceNumber * this.crawlNumber;\r\n        }\r\n        // 判断是公开收藏还是非公开收藏\r\n        // 在新旧版 url 里，rest 都是在查询字符串里的\r\n        this.isHide = API.getURLSearchField(location.href, 'rest') === 'hide';\r\n        log.log(lang.transl('_正在抓取'));\r\n        if (this.crawlNumber === -1) {\r\n            log.log(lang.transl('_获取全部书签作品'));\r\n        }\r\n    }\r\n    // 获取用户的收藏作品列表\r\n    async getIdList() {\r\n        let data;\r\n        try {\r\n            data = await API.getBookmarkData(DOM.getUserId(), this.type, store.tag, this.offset, this.isHide);\r\n        }\r\n        catch (error) {\r\n            this.getIdList();\r\n            return;\r\n        }\r\n        if (data.body.works.length === 0 ||\r\n            this.idList.length >= this.requsetNumber) {\r\n            // 书签页获取完毕\r\n            return this.afterGetIdList();\r\n        }\r\n        else {\r\n            // 没有抓取完毕时，添加数据\r\n            const idType = this.type === 'illusts' ? 'unknown' : 'novels';\r\n            data.body.works.forEach((data) => this.idList.push({\r\n                type: idType,\r\n                id: data.id,\r\n            }));\r\n            this.offset += this.onceRequest; // 每次增加偏移量\r\n            // 重复抓取过程\r\n            this.getIdList();\r\n        }\r\n    }\r\n    // 获取作品 id 列表完毕之后\r\n    afterGetIdList() {\r\n        // 因为书签页面一次获取 100 个作品，大于一页的数量。所以可能会抓取多了，需要删除多余的作品\r\n        if (this.idList.length > this.requsetNumber) {\r\n            // 删除后面部分（较早收藏的），留下近期收藏的\r\n            this.idList.splice(this.requsetNumber, this.idList.length);\r\n            // 书签页面的 api 没有考虑页面上的排序顺序，获取到的 id 列表始终是按收藏顺序由近期到早期排列的\r\n        }\r\n        store.idList = store.idList.concat(this.idList);\r\n        this.getIdListFinished();\r\n    }\r\n    // 获取书签页面下方的推荐作品列表\r\n    getRecommendedList() {\r\n        const selector = this.type === 'illusts'\r\n            ? '#illust-recommend .image-item'\r\n            : '.novel-items>li';\r\n        const idType = this.type === 'illusts' ? 'unknown' : 'novels';\r\n        const getId = this.type === 'illusts' ? API.getIllustId : API.getNovelId;\r\n        // 获取下方已经加载出来的作品\r\n        const elements = document.querySelectorAll(selector);\r\n        if (elements.length === 0) {\r\n            this.crawlRecommended = false;\r\n            return this.noResult();\r\n        }\r\n        // 添加作品列表\r\n        for (const li of elements) {\r\n            const a = li.querySelector('a');\r\n            if (store.idList.length === this.crawlNumber) {\r\n                break;\r\n            }\r\n            store.idList.push({\r\n                type: idType,\r\n                id: getId(a.href),\r\n            });\r\n        }\r\n        this.getIdListFinished();\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.type = 'illusts';\r\n        this.idList = [];\r\n        this.offset = 0;\r\n        this.crawlRecommended = false; // 解除下载推荐作品的标记\r\n    }\r\n    sortResult() {\r\n        // 把作品数据反转，这样可以先下载收藏时间早的，后下载收藏时间近的\r\n        !this.crawlRecommended && store.result.reverse();\r\n    }\r\n}\r\nexport { InitBookmarkLegacyPage };\r\n","// 初始化新版收藏页面\r\nimport { InitPageBase } from './InitPageBase';\r\nimport { API } from './API';\r\nimport { Colors } from './Colors';\r\nimport { lang } from './Lang';\r\nimport { options } from './setting/Options';\r\nimport { store } from './Store';\r\nimport { log } from './Log';\r\nimport { DOM } from './DOM';\r\nclass InitBookmarkPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.idList = []; // 储存从列表页获取到的 id\r\n        this.type = 'illusts'; // 页面是图片还是小说\r\n        this.isHide = false; // 当前页面是否显示的是非公开收藏\r\n        this.requsetNumber = 0; // 根据页数，计算要抓取的作品个数\r\n        this.onceRequest = 100; // 每次请求多少个数量\r\n        this.offset = 0; // 要去掉的作品数量\r\n        this.init();\r\n    }\r\n    addCrawlBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_开始抓取') + lang.transl('_默认下载多页')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    setFormOption() {\r\n        // 个数/页数选项的提示\r\n        options.setWantPageTip({\r\n            text: lang.transl('_页数'),\r\n            tip: lang.transl('_从本页开始下载提示'),\r\n            rangTip: lang.transl('_数字提示1'),\r\n        });\r\n        // 在书签页面隐藏只要书签选项\r\n        options.hideOption([6]);\r\n    }\r\n    getWantPage() {\r\n        this.crawlNumber = this.checkWantPageInput(lang.transl('_从本页开始下载x页'), lang.transl('_下载所有页面'));\r\n    }\r\n    nextStep() {\r\n        if (window.location.pathname.includes('/novel')) {\r\n            this.type = 'novels';\r\n        }\r\n        this.readyGetIdList();\r\n        this.getIdList();\r\n    }\r\n    readyGetIdList() {\r\n        // 每页个数\r\n        const onceNumber = 48;\r\n        // 如果前面有页数，就去掉前面页数的作品数量。即：从本页开始下载\r\n        const nowPage = API.getURLSearchField(location.href, 'p'); // 判断当前处于第几页，页码从 1 开始。也可能没有页码\r\n        if (nowPage) {\r\n            this.offset = (parseInt(nowPage) - 1) * onceNumber;\r\n        }\r\n        if (this.offset < 0) {\r\n            this.offset = 0;\r\n        }\r\n        // 根据页数设置，计算要下载的个数\r\n        this.requsetNumber = 0;\r\n        if (this.crawlNumber === -1) {\r\n            this.requsetNumber = 9999999;\r\n        }\r\n        else {\r\n            this.requsetNumber = onceNumber * this.crawlNumber;\r\n        }\r\n        // 判断是公开收藏还是非公开收藏\r\n        // 在新旧版 url 里，rest 都是在查询字符串里的\r\n        this.isHide = API.getURLSearchField(location.href, 'rest') === 'hide';\r\n        log.log(lang.transl('_正在抓取'));\r\n        if (this.crawlNumber === -1) {\r\n            log.log(lang.transl('_获取全部书签作品'));\r\n        }\r\n    }\r\n    // 获取用户的收藏作品列表\r\n    async getIdList() {\r\n        let data;\r\n        try {\r\n            data = await API.getBookmarkData(DOM.getUserId(), this.type, store.tag, this.offset, this.isHide);\r\n        }\r\n        catch (error) {\r\n            this.getIdList();\r\n            return;\r\n        }\r\n        if (data.body.works.length === 0 ||\r\n            this.idList.length >= this.requsetNumber) {\r\n            // 书签页获取完毕\r\n            return this.afterGetIdList();\r\n        }\r\n        else {\r\n            // 没有抓取完毕时，添加数据\r\n            const idType = this.type === 'illusts' ? 'unknown' : 'novels';\r\n            data.body.works.forEach((data) => this.idList.push({\r\n                type: idType,\r\n                id: data.id,\r\n            }));\r\n            this.offset += this.onceRequest; // 每次增加偏移量\r\n            // 重复抓取过程\r\n            this.getIdList();\r\n        }\r\n    }\r\n    // 获取作品 id 列表完毕之后\r\n    afterGetIdList() {\r\n        // 因为书签页面一次获取 100 个作品，大于一页的数量。所以可能会抓取多了，需要删除多余的作品\r\n        if (this.idList.length > this.requsetNumber) {\r\n            // 删除后面部分（较早收藏的），留下近期收藏的\r\n            this.idList.splice(this.requsetNumber, this.idList.length);\r\n            // 书签页面的 api 没有考虑页面上的排序顺序，获取到的 id 列表始终是按收藏顺序由近期到早期排列的\r\n        }\r\n        store.idList = store.idList.concat(this.idList);\r\n        this.getIdListFinished();\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.type = 'illusts';\r\n        this.idList = [];\r\n        this.offset = 0;\r\n    }\r\n}\r\nexport { InitBookmarkPage };\r\n","// 初始化关注列表页面\r\nimport { InitPageBase } from './InitPageBase';\r\nimport { Colors } from './Colors';\r\nimport { lang } from './Lang';\r\nimport { options } from './setting/Options';\r\nimport { API } from './API';\r\nimport { store } from './Store';\r\nimport { log } from './Log';\r\nimport { DOM } from './DOM';\r\nimport { EVT } from './EVT';\r\nclass InitFollowingPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.baseOffset = 0; // 开始抓取时，记录初始的偏移量\r\n        this.onceNumber = 24; // 每页 24 个画师\r\n        this.getUserListNo = 0; // 获取用户列表时，记录请求的次数\r\n        this.limit = 100; // 每次请求多少个画师的数据\r\n        this.totalNeed = Number.MAX_SAFE_INTEGER;\r\n        this.myId = '';\r\n        this.rest = 'show';\r\n        this.userList = [];\r\n        this.index = 0; // getIdList 时，对 userList 的索引\r\n        this.init();\r\n    }\r\n    addCrawlBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_开始抓取') + lang.transl('_默认下载多页')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    setFormOption() {\r\n        // 个数/页数选项的提示\r\n        options.setWantPageTip({\r\n            text: lang.transl('_页数'),\r\n            tip: lang.transl('_从本页开始下载提示'),\r\n            rangTip: lang.transl('_数字提示1'),\r\n        });\r\n    }\r\n    getWantPage() {\r\n        this.crawlNumber = this.checkWantPageInput(lang.transl('_从本页开始下载x页'), lang.transl('_下载所有页面'));\r\n    }\r\n    nextStep() {\r\n        this.readyGet();\r\n        log.log(lang.transl('_正在抓取'));\r\n        this.getUserList();\r\n    }\r\n    readyGet() {\r\n        this.rest = location.href.includes('rest=hide') ? 'hide' : 'show';\r\n        // 获取抓取开始时的页码\r\n        const nowPage = API.getURLSearchField(location.href, 'p');\r\n        // 计算开始抓取时的偏移量\r\n        if (nowPage !== '') {\r\n            this.baseOffset = (parseInt(nowPage) - 1) * this.onceNumber;\r\n        }\r\n        else {\r\n            this.baseOffset = 0;\r\n        }\r\n        // 要抓取多少个用户\r\n        this.totalNeed = Number.MAX_SAFE_INTEGER;\r\n        if (this.crawlNumber !== -1) {\r\n            this.totalNeed = this.onceNumber * this.crawlNumber;\r\n        }\r\n        // 获取用户自己的 id\r\n        const test = /users\\/(\\d*)\\//.exec(location.href);\r\n        if (test && test.length > 1) {\r\n            this.myId = test[1];\r\n        }\r\n        else {\r\n            const msg = `Get the user's own id failed`;\r\n            log.error(msg, 2);\r\n            throw new Error(msg);\r\n        }\r\n    }\r\n    // 获取关注用户列表，保存用户 id\r\n    async getUserList() {\r\n        const offset = this.baseOffset + this.getUserListNo * this.limit;\r\n        let res;\r\n        try {\r\n            res = await API.getFollowingList(this.myId, this.rest, offset);\r\n        }\r\n        catch (_a) {\r\n            this.getUserList();\r\n            return;\r\n        }\r\n        const users = res.body.users;\r\n        if (users.length === 0) {\r\n            // 用户列表抓取完毕\r\n            return this.getUserListComplete();\r\n        }\r\n        for (const userData of users) {\r\n            this.userList.push(userData.userId);\r\n            if (this.userList.length >= this.totalNeed) {\r\n                // 抓取到了指定数量的用户\r\n                return this.getUserListComplete();\r\n            }\r\n        }\r\n        log.log(lang.transl('_当前有x个用户', this.userList.length.toString()), 1, false);\r\n        this.getUserListNo++;\r\n        this.getUserList();\r\n    }\r\n    getUserListComplete() {\r\n        log.log(lang.transl('_当前有x个用户', this.userList.length.toString()));\r\n        if (this.userList.length === 0) {\r\n            return this.getIdListFinished();\r\n        }\r\n        EVT.fire(EVT.list.output, {\r\n            content: this.userList.join('<br />'),\r\n            title: 'Following user id list',\r\n        });\r\n        this.getIdList();\r\n    }\r\n    // 获取用户的 id 列表\r\n    async getIdList() {\r\n        let idList = [];\r\n        try {\r\n            idList = await API.getUserWorksByType(this.userList[this.index]);\r\n        }\r\n        catch (_a) {\r\n            this.getIdList();\r\n            return;\r\n        }\r\n        store.idList = store.idList.concat(idList);\r\n        this.index++;\r\n        if (this.index >= this.userList.length) {\r\n            return this.getIdListFinished();\r\n        }\r\n        log.log(lang.transl('_当前作品个数', store.idList.length.toString()), 1, false);\r\n        this.getIdList();\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.userList = [];\r\n        this.getUserListNo = 0;\r\n        this.index = 0;\r\n    }\r\n    sortResult() {\r\n        // 把作品数据按 id 倒序排列，id 大的在前面，这样可以先下载最新作品，后下载早期作品\r\n        store.result.sort(API.sortByProperty('id'));\r\n    }\r\n}\r\nexport { InitFollowingPage };\r\n","// 初始化首页\r\nimport { InitPageBase } from './InitPageBase';\r\nimport { Colors } from './Colors';\r\nimport { lang } from './Lang';\r\nimport { options } from './setting/Options';\r\nimport { DOM } from './DOM';\r\nimport { store } from './Store';\r\nimport { log } from './Log';\r\nimport { EVT } from './EVT';\r\nclass InitIndexPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.downIdButton = document.createElement('button');\r\n        this.downIdInput = document.createElement('textarea');\r\n        this.ready = false;\r\n        this.init();\r\n    }\r\n    addCrawlBtns() {\r\n        this.downIdButton = DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_输入id进行抓取'), [['id', 'down_id_button']]);\r\n    }\r\n    addAnyElement() {\r\n        // 用于输入id的输入框\r\n        this.downIdInput.id = 'down_id_input';\r\n        this.downIdInput.style.display = 'none';\r\n        this.downIdInput.setAttribute('placeholder', lang.transl('_输入id进行抓取的提示文字'));\r\n        DOM.insertToHead(this.downIdInput);\r\n        DOM.addBtn('otherBtns', Colors.green, lang.transl('_清空已保存的抓取结果')).addEventListener('click', () => {\r\n            EVT.fire(EVT.list.clearSavedCrawl);\r\n        });\r\n    }\r\n    setFormOption() {\r\n        options.hideOption([1]);\r\n    }\r\n    initAny() {\r\n        this.downIdButton.addEventListener('click', () => {\r\n            if (!this.ready) {\r\n                // 还没准备好\r\n                EVT.fire(EVT.list.closeCenterPanel);\r\n                this.downIdInput.style.display = 'block';\r\n                this.downIdInput.focus();\r\n                document.documentElement.scrollTop = 0;\r\n            }\r\n            else {\r\n                this.readyCrawl();\r\n            }\r\n        }, false);\r\n        // 当输入框内容改变时检测，非空值时显示下载区域\r\n        this.downIdInput.addEventListener('change', () => {\r\n            if (this.downIdInput.value !== '') {\r\n                this.ready = true;\r\n                window.setTimeout(() => {\r\n                    EVT.fire(EVT.list.openCenterPanel);\r\n                }, 300);\r\n                this.downIdButton.textContent = lang.transl('_开始抓取');\r\n            }\r\n            else {\r\n                this.ready = false;\r\n                EVT.fire(EVT.list.closeCenterPanel);\r\n                this.downIdButton.textContent = lang.transl('_输入id进行抓取');\r\n            }\r\n        });\r\n    }\r\n    getWantPage() { }\r\n    getIdList() {\r\n        // 检查页面类型，设置输入的 id 的作品类型\r\n        const type = window.location.pathname === '/novel/' ? 'novels' : 'unknown';\r\n        // 检测 id 是否合法\r\n        const array = this.downIdInput.value.split('\\n');\r\n        const idSet = new Set();\r\n        for (const str of array) {\r\n            const id = parseInt(str);\r\n            if (isNaN(id) || id < 22 || id > 99999999) {\r\n                // 对不符合要求的 id 显示提示。如果 id 是空字符串则不显示提示\r\n                str !== '' && log.error(lang.transl('_id不合法') + ': ' + str);\r\n            }\r\n            else {\r\n                idSet.add(id);\r\n            }\r\n        }\r\n        // 添加 id\r\n        for (const id of idSet.values()) {\r\n            store.idList.push({\r\n                type: type,\r\n                id: id.toString(),\r\n            });\r\n        }\r\n        this.getIdListFinished();\r\n    }\r\n    resetGetIdListStatus() { }\r\n    destroy() {\r\n        DOM.clearSlot('crawlBtns');\r\n        DOM.clearSlot('otherBtns');\r\n        DOM.removeEl(this.downIdInput);\r\n    }\r\n}\r\nexport { InitIndexPage };\r\n","// 根据不同的页面，初始化下载器的功能\r\nimport { EVT } from './EVT';\r\nimport { pageType } from './PageType';\r\nimport { InitIndexPage } from './InitIndexPage';\r\nimport { InitArtworkPage } from './artwork/InitArtworkPage';\r\nimport { InitUserPage } from './InitUserPage';\r\nimport { InitBookmarkLegacyPage } from './InitBookmarkLegacyPage';\r\nimport { InitBookmarkPage } from './InitBookmarkPage';\r\nimport { InitSearchArtworkPage } from './artwork/InitSearchArtworkPage';\r\nimport { InitAreaRankingPage } from './artwork/InitAreaRankingPage';\r\nimport { InitRankingArtworkPage } from './artwork/InitRankingArtworkPage';\r\nimport { InitPixivisionPage } from './InitPixivisionPage';\r\nimport { InitBookmarkDetailPage } from './artwork/InitBookmarkDetailPage';\r\nimport { InitBookmarkNewArtworkPage } from './artwork/InitBookmarkNewArtworkPage';\r\nimport { InitDiscoverPage } from './artwork/InitDiscoverPage';\r\nimport { InitNewArtworkPage } from './artwork/InitNewArtworkPage';\r\nimport { InitNovelPage } from './novel/InitNovelPage';\r\nimport { InitNovelSeriesPage } from './novel/InitNovelSeriesPage';\r\nimport { InitSearchNovelPage } from './novel/InitSearchNovelPage';\r\nimport { InitRankingNovelPage } from './novel/InitRankingNovelPage';\r\nimport { InitBookmarkNewNovelPage } from './novel/InitBookmarkNewNovelPage';\r\nimport { InitNewNovelPage } from './novel/InitNewNovelPage';\r\nimport { InitSeriesPage } from './artwork/InitSeriesPage';\r\nimport { InitFollowingPage } from './InitFollowingPage';\r\nclass InitPage {\r\n    constructor() {\r\n        this.initPage();\r\n        // 页面类型变化时，初始化抓取流程\r\n        window.addEventListener(EVT.list.pageSwitchedTypeChange, () => {\r\n            setTimeout(() => {\r\n                this.initPage();\r\n            }, 0);\r\n        });\r\n    }\r\n    initPage() {\r\n        switch (pageType.type) {\r\n            case 0:\r\n                return new InitIndexPage();\r\n            case 1:\r\n                return new InitArtworkPage();\r\n            case 2:\r\n                return new InitUserPage();\r\n            case 3:\r\n                return new InitBookmarkLegacyPage();\r\n            case 4:\r\n                return new InitBookmarkPage();\r\n            case 5:\r\n                return new InitSearchArtworkPage();\r\n            case 6:\r\n                return new InitAreaRankingPage();\r\n            case 7:\r\n                return new InitRankingArtworkPage();\r\n            case 8:\r\n                return new InitPixivisionPage();\r\n            case 9:\r\n                return new InitBookmarkDetailPage();\r\n            case 10:\r\n                return new InitBookmarkNewArtworkPage();\r\n            case 11:\r\n                return new InitDiscoverPage();\r\n            case 12:\r\n                return new InitNewArtworkPage();\r\n            case 13:\r\n                return new InitNovelPage();\r\n            case 14:\r\n                return new InitNovelSeriesPage();\r\n            case 15:\r\n                return new InitSearchNovelPage();\r\n            case 16:\r\n                return new InitRankingNovelPage();\r\n            case 17:\r\n                return new InitBookmarkNewNovelPage();\r\n            case 18:\r\n                return new InitNewNovelPage();\r\n            case 19:\r\n                return new InitSeriesPage();\r\n            case 20:\r\n                return new InitFollowingPage();\r\n            default:\r\n                throw new Error('InitPage error: Illegal pageType.');\r\n        }\r\n    }\r\n}\r\nnew InitPage();\r\n","// 初始化所有页面抓取流程的基类\r\nimport { lang } from './Lang';\r\nimport { Colors } from './Colors';\r\nimport { DOM } from './DOM';\r\nimport { API } from './API';\r\nimport { store } from './Store';\r\nimport { log } from './Log';\r\nimport { EVT } from './EVT';\r\nimport { options } from './setting/Options';\r\nimport { settings } from './setting/Settings';\r\nimport { settingAPI } from './setting/SettingAPI';\r\nimport { states } from './States';\r\nimport { saveArtworkData } from './artwork/SaveArtworkData';\r\nimport { saveNovelData } from './novel/SaveNovelData';\r\nclass InitPageBase {\r\n    constructor() {\r\n        this.crawlNumber = 0; // 要抓取的个数/页数\r\n        this.maxCount = 1000; // 当前页面类型最多有多少个页面/作品\r\n        this.startpageNo = 1; // 列表页开始抓取时的页码，只在 api 需要页码时使用。目前有搜索页、排行榜页、新作品页、系列页面使用。\r\n        this.listPageFinished = 0; // 记录一共抓取了多少个列表页。使用范围同上。\r\n        this.ajaxThreadsDefault = 10; // 抓取时的并发连接数默认值，也是最大值\r\n        this.ajaxThreads = this.ajaxThreadsDefault; // 抓取时的并发连接数\r\n        this.ajaxThreadsFinished = 0; // 统计有几个并发线程完成所有请求。统计的是并发线程（ ajaxThreads ）而非请求数\r\n    }\r\n    // 子组件不应该重载 init 方法\r\n    init() {\r\n        options.showAllOption();\r\n        this.setFormOption();\r\n        this.addCrawlBtns();\r\n        this.addAnyElement();\r\n        this.initAny();\r\n        window.addEventListener(EVT.list.pageSwitchedTypeChange, () => {\r\n            this.destroy();\r\n        });\r\n    }\r\n    // 设置表单里的选项。主要是设置页数，隐藏不需要的选项。\r\n    setFormOption() {\r\n        // 个数/页数选项的提示\r\n        options.setWantPageTip({\r\n            text: lang.transl('_页数'),\r\n            tip: lang.transl('_从本页开始下载提示'),\r\n            rangTip: lang.transl('_数字提示1'),\r\n        });\r\n    }\r\n    // 添加抓取区域的按钮\r\n    addCrawlBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_开始抓取') + lang.transl('_默认下载多页')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    // 添加其他任意元素（如果有）\r\n    addAnyElement() { }\r\n    // 初始化任意内容\r\n    // 如果有一些代码不能归纳到 init 方法的前面几个方法里，那就放在这里\r\n    // 通常用来初始化特有的组件、功能、事件、状态等\r\n    initAny() { }\r\n    // 销毁初始化页面时添加的元素和事件，恢复设置项等\r\n    destroy() {\r\n        DOM.clearSlot('crawlBtns');\r\n        DOM.clearSlot('otherBtns');\r\n    }\r\n    // 作品个数/页数的输入不合法\r\n    getWantPageError() {\r\n        EVT.fire(EVT.list.wrongSetting);\r\n        const msg = lang.transl('_参数不合法');\r\n        EVT.sendMsg({\r\n            msg: msg,\r\n            type: 'error',\r\n        });\r\n        throw new Error(msg);\r\n    }\r\n    // 检查用户输入的页数/个数设置\r\n    // 可以为 -1，或者大于 0\r\n    checkWantPageInput(crawlPartTip, crawlAllTip) {\r\n        const temp = parseInt(settings.setWantPage);\r\n        // 如果比 1 小，并且不是 -1，则不通过\r\n        if ((temp < 1 && temp !== -1) || isNaN(temp)) {\r\n            // 比 1 小的数里，只允许 -1 , 0 也不行\r\n            throw this.getWantPageError();\r\n        }\r\n        if (temp >= 1) {\r\n            log.warning(crawlPartTip.replace('{}', temp.toString()));\r\n        }\r\n        else if (temp === -1) {\r\n            log.warning(crawlAllTip);\r\n        }\r\n        return temp;\r\n    }\r\n    // 检查用户输入的页数/个数设置\r\n    // 要求必须大于 0\r\n    // 参数 max 为最大值\r\n    // 参数 page 指示单位是“页”（页面）还是“个”（作品个数）\r\n    checkWantPageInputGreater0(max, page) {\r\n        const result = API.checkNumberGreater0(settings.setWantPage);\r\n        if (result.result) {\r\n            const r = result.value > max ? max : result.value;\r\n            if (page) {\r\n                log.warning(lang.transl('_从本页开始下载x页', r.toString()));\r\n            }\r\n            else {\r\n                log.warning(lang.transl('_从本页开始下载x个', r.toString()));\r\n            }\r\n            return r;\r\n        }\r\n        else {\r\n            throw this.getWantPageError();\r\n        }\r\n    }\r\n    // 设置要获取的作品数或页数。有些页面使用，有些页面不使用。使用时再具体定义\r\n    getWantPage() { }\r\n    // 获取多图作品设置。因为这个不属于过滤器 filter，所以在这里直接获取\r\n    getMultipleSetting() {\r\n        // 获取作品张数设置\r\n        if (settings.firstFewImagesSwitch) {\r\n            log.warning(lang.transl('_多图作品下载前n张图片', settingAPI.getFirstFewImages().toString()));\r\n        }\r\n    }\r\n    // 准备抓取，进行抓取之前的一些检查工作。必要时可以在子类中改写\r\n    async readyCrawl() {\r\n        // 检查是否可以开始抓取\r\n        if (states.busy) {\r\n            EVT.sendMsg({\r\n                msg: lang.transl('_当前任务尚未完成2'),\r\n                type: 'error',\r\n            });\r\n            return;\r\n        }\r\n        log.clear();\r\n        log.success(lang.transl('_任务开始0'));\r\n        this.getWantPage();\r\n        this.getMultipleSetting();\r\n        EVT.fire(EVT.list.crawlStart);\r\n        // 进入第一个抓取方法\r\n        this.nextStep();\r\n    }\r\n    // 当可以开始抓取时，进入下一个流程。默认情况下，开始获取作品列表。如有不同，由子类具体定义\r\n    nextStep() {\r\n        this.getIdList();\r\n    }\r\n    // id 列表获取完毕，开始抓取作品内容页\r\n    getIdListFinished() {\r\n        this.resetGetIdListStatus();\r\n        EVT.fire(EVT.list.getIdListFinished);\r\n        if (states.bookmarkMode) {\r\n            return;\r\n        }\r\n        if (store.idList.length === 0) {\r\n            return this.noResult();\r\n        }\r\n        log.log(lang.transl('_当前作品个数', store.idList.length.toString()));\r\n        // 这个 return 在这里重置任务状态，不继续抓取作品的详情了，用于调试时反复进行抓取\r\n        // return states.allWork = false\r\n        if (store.idList.length <= this.ajaxThreadsDefault) {\r\n            this.ajaxThreads = store.idList.length;\r\n        }\r\n        else {\r\n            this.ajaxThreads = this.ajaxThreadsDefault;\r\n        }\r\n        for (let i = 0; i < this.ajaxThreads; i++) {\r\n            this.getWorksData();\r\n        }\r\n    }\r\n    // 获取作品的数据\r\n    async getWorksData(idData) {\r\n        idData = idData || store.idList.shift();\r\n        const id = idData.id;\r\n        if (!id) {\r\n            const msg = 'Error: work id is invalid!';\r\n            EVT.sendMsg({\r\n                msg: msg,\r\n                type: 'error',\r\n            });\r\n            throw new Error(msg);\r\n        }\r\n        let failed = false; // 请求失败的标记\r\n        try {\r\n            if (idData.type === 'novels') {\r\n                const data = await API.getNovelData(id);\r\n                await saveNovelData.save(data);\r\n            }\r\n            else {\r\n                const data = await API.getArtworkData(id);\r\n                await saveArtworkData.save(data);\r\n            }\r\n        }\r\n        catch (error) {\r\n            if (error.status) {\r\n                // 请求成功，但状态码不正常，不会重试\r\n                this.logErrorStatus(error.status, id);\r\n            }\r\n            else {\r\n                // 请求失败，没有获得服务器的返回数据，会重试\r\n                // 这里也会捕获到 save 作品数据时的错误\r\n                failed = true;\r\n                console.error(error);\r\n            }\r\n        }\r\n        if (failed) {\r\n            // 再次发送这个请求\r\n            setTimeout(() => {\r\n                this.getWorksData(idData);\r\n            }, 2000);\r\n        }\r\n        else {\r\n            this.afterGetWorksData();\r\n        }\r\n    }\r\n    // 每当获取完一个作品的信息\r\n    afterGetWorksData() {\r\n        this.logResultTotal();\r\n        if (store.idList.length > 0) {\r\n            // 如果存在下一个作品，则\r\n            this.getWorksData();\r\n        }\r\n        else {\r\n            // 没有剩余作品\r\n            this.ajaxThreadsFinished++;\r\n            if (this.ajaxThreadsFinished === this.ajaxThreads) {\r\n                // 如果所有并发请求都执行完毕，复位\r\n                this.ajaxThreadsFinished = 0;\r\n                this.crawlFinished();\r\n            }\r\n        }\r\n    }\r\n    // 抓取完毕\r\n    crawlFinished() {\r\n        if (store.result.length === 0) {\r\n            return this.noResult();\r\n        }\r\n        store.crawlCompleteTime = new Date();\r\n        this.sortResult();\r\n        log.log(lang.transl('_共抓取到n个文件', store.result.length.toString()));\r\n        log.log(lang.transl('_抓取完毕'), 2);\r\n        // 发出抓取完毕的信号\r\n        EVT.fire(EVT.list.crawlFinish);\r\n    }\r\n    // 网络请求状态异常时输出提示\r\n    logErrorStatus(status, id) {\r\n        switch (status) {\r\n            case 0:\r\n                log.error(id + ': ' + lang.transl('_作品页状态码0'));\r\n                break;\r\n            case 400:\r\n                log.error(id + ': ' + lang.transl('_作品页状态码400'));\r\n                break;\r\n            case 403:\r\n                log.error(id + ': ' + lang.transl('_作品页状态码403'));\r\n                break;\r\n            case 404:\r\n                log.error(id + ': ' + lang.transl('_作品页状态码404'));\r\n                break;\r\n            default:\r\n                log.error(lang.transl('_无权访问', id));\r\n                break;\r\n        }\r\n    }\r\n    // 在抓取图片网址时，输出提示\r\n    logResultTotal() {\r\n        log.log(lang.transl('_共抓取到n个文件', store.result.length.toString()), 1, false);\r\n    }\r\n    // 抓取结果为 0 时输出提示\r\n    noResult() {\r\n        // 先触发 crawlFinish，后触发 crawlEmpty。这样便于其他组件处理 crawlEmpty 这个例外情况\r\n        // 如果触发顺序反过来，那么最后执行的都是 crawlFinish，可能会覆盖对 crawlEmpty 的处理\r\n        EVT.fire(EVT.list.crawlFinish);\r\n        EVT.fire(EVT.list.crawlEmpty);\r\n        const msg = lang.transl('_抓取结果为零');\r\n        log.error(msg, 2);\r\n        EVT.sendMsg({\r\n            msg: msg,\r\n            type: 'error',\r\n        });\r\n    }\r\n    // 抓取完成后，对结果进行排序\r\n    sortResult() { }\r\n}\r\nexport { InitPageBase };\r\n","// 初始化 pixivision 页面\r\nimport { InitPageBase } from './InitPageBase';\r\nimport { Colors } from './Colors';\r\nimport { lang } from './Lang';\r\nimport { DOM } from './DOM';\r\nimport { options } from './setting/Options';\r\nimport { store } from './Store';\r\nclass InitPixivisionPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.init();\r\n    }\r\n    addCrawlBtns() {\r\n        const typeA = document.querySelector('a[data-gtm-action=ClickCategory]');\r\n        const type = typeA.dataset.gtmLabel;\r\n        if (type === 'illustration' || type === 'manga' || type === 'cosplay') {\r\n            // 在插画、漫画、cosplay类型的页面上创建下载功能\r\n            DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_抓取该页面的图片')).addEventListener('click', () => {\r\n                this.readyCrawl();\r\n            }, false);\r\n        }\r\n    }\r\n    setFormOption() {\r\n        options.hideOption([\r\n            1,\r\n            2,\r\n            3,\r\n            4,\r\n            5,\r\n            6,\r\n            7,\r\n            8,\r\n            9,\r\n            10,\r\n            11,\r\n            12,\r\n            14,\r\n            15,\r\n            16,\r\n            18,\r\n            19,\r\n            21,\r\n            22,\r\n            23,\r\n            24,\r\n            26,\r\n            27,\r\n            28,\r\n            30,\r\n            31,\r\n            33,\r\n            34,\r\n            35,\r\n            36,\r\n            37,\r\n        ]);\r\n        // pixivision 里，文件名只有 id 标记会生效，所以把文件名规则替换成 id\r\n        // form.userSetName.value = '{p_title}/{id}'\r\n    }\r\n    nextStep() {\r\n        this.getPixivision();\r\n    }\r\n    getIdList() { }\r\n    resetGetIdListStatus() { }\r\n    // 保存要下载的图片的信息\r\n    addResult(id, url, ext) {\r\n        store.addResult({\r\n            id: id,\r\n            original: url,\r\n            ext: ext,\r\n        });\r\n    }\r\n    async getPixivision() {\r\n        const a = document.querySelector('a[data-gtm-action=ClickCategory]');\r\n        const type = a.dataset.gtmLabel;\r\n        if (type === 'illustration') {\r\n            // 插画页面，需要对图片进行测试获取原图 url\r\n            const imageList = document.querySelectorAll('.am__work__main img');\r\n            const urls = Array.from(imageList).map((el) => {\r\n                return el.src\r\n                    .replace('c/768x1200_80/img-master', 'img-original')\r\n                    .replace('_master1200', '');\r\n            });\r\n            for (const url of urls) {\r\n                let arr = url.split('/');\r\n                const id = arr[arr.length - 1].split('.')[0].split('_')[0]; // 作品id，尝试提取出数字部分\r\n                await this.testExtName(url, id);\r\n            }\r\n            this.crawlFinished();\r\n        }\r\n        else {\r\n            // 漫画和 cosplay ，直接保存页面上的图片\r\n            let selector = '';\r\n            if (type === 'manga') {\r\n                selector = '.am__work__illust';\r\n            }\r\n            else if (type === 'cosplay') {\r\n                selector = '.fab__image-block__image img';\r\n            }\r\n            // 把图片url添加进数组\r\n            const imageList = document.querySelectorAll(selector);\r\n            Array.from(imageList).forEach((el) => {\r\n                const url = el.src;\r\n                if (url !== 'https://i.pximg.net/imgaz/upload/20170407/256097898.jpg') {\r\n                    // 跳过Cure的logo图片\r\n                    // 漫画页面的图片 url 如：\r\n                    // https://i.pximg.net/c/768x1200_80/img-master/img/2017/06/19/01/08/28/63457814_p0_master1200.jpg\r\n                    // cosplay 页面的 ur 如：\r\n                    // https://i.pximg.net/imgaz/upload/20170808/670930758.jpg\r\n                    const arr = url.split('/');\r\n                    const id = arr[arr.length - 1].split('.')[0].split('_')[0]; // 作品id，尝试提取出数字部分\r\n                    const extTest = arr[arr.length - 1].match(/\\.(.*$)/); // 扩展名，不带点 .\r\n                    let ext = 'jpg';\r\n                    if (extTest && extTest.length > 1) {\r\n                        ext = extTest[1];\r\n                    }\r\n                    this.addResult(id, url, ext);\r\n                }\r\n            });\r\n            this.crawlFinished();\r\n        }\r\n    }\r\n    // 通过加载图片来判断图片的后缀名。pixivision 页面直接获取的图片后缀都是 jpg 的\r\n    async testExtName(url, id) {\r\n        let ext = 'jpg'; // 默认为 jpg\r\n        await DOM.loadImg(url).catch(() => {\r\n            // 如果图片加载失败则把后缀改为 png\r\n            url = url.replace('.jpg', '.png');\r\n            ext = 'png';\r\n        });\r\n        this.addResult(id, url, ext);\r\n        this.logResultTotal();\r\n    }\r\n}\r\nexport { InitPixivisionPage };\r\n","// 初始化用户页面\r\nimport { InitPageBase } from './InitPageBase';\r\nimport { Colors } from './Colors';\r\nimport { lang } from './Lang';\r\nimport { options } from './setting/Options';\r\nimport { API } from './API';\r\nimport { store } from './Store';\r\nimport { EVT } from './EVT';\r\nimport { log } from './Log';\r\nimport { DOM } from './DOM';\r\nimport { states } from './States';\r\nimport './SaveAvatarIcon';\r\nimport { BookmarkAllWorks } from './BookmarkAllWorks';\r\nclass InitUserPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.listType = 0; // 细分的列表类型\r\n        this.onceNumber = 48; // 每页作品个数，插画是 48 个，小说是 24 个\r\n        this.bookmarkAll = new BookmarkAllWorks();\r\n        this.sendBookmarkIdList = () => {\r\n            if (states.bookmarkMode) {\r\n                // 将 id 的 type 设置为 illusts 或 novels\r\n                const list = [];\r\n                for (const data of store.idList) {\r\n                    if (data.type === 'novels') {\r\n                        list.push(data);\r\n                    }\r\n                    else {\r\n                        list.push({\r\n                            type: 'illusts',\r\n                            id: data.id,\r\n                        });\r\n                    }\r\n                }\r\n                store.idList = []; // 清空这次抓取到的 id 列表\r\n                this.bookmarkAll.sendIdList(list);\r\n            }\r\n        };\r\n        this.init();\r\n    }\r\n    // 添加中间按钮\r\n    addCrawlBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_开始抓取') + lang.transl('_默认下载多页')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    addAnyElement() {\r\n        DOM.addBtn('otherBtns', Colors.green, lang.transl('_保存用户头像为图标'), [\r\n            ['title', lang.transl('_保存用户头像为图标说明')],\r\n        ]).addEventListener('click', () => {\r\n            EVT.fire(EVT.list.saveAvatarIcon);\r\n        });\r\n        // 添加收藏本页所有作品的功能\r\n        const bookmarkAllBtn = DOM.addBtn('otherBtns', Colors.green, lang.transl('_收藏本页面的所有作品'));\r\n        this.bookmarkAll = new BookmarkAllWorks(bookmarkAllBtn);\r\n        bookmarkAllBtn.addEventListener('click', async () => {\r\n            // 获取该用户的所有作品的 id 列表\r\n            // 模拟了抓取流程，以获取相同的 id 列表\r\n            EVT.fire(EVT.list.bookmarkModeStart);\r\n            store.tag = API.getTagFromURL();\r\n            this.crawlNumber = 1; // 设置为只抓取 1 页\r\n            this.readyGetIdList();\r\n        });\r\n        window.addEventListener(EVT.list.getIdListFinished, this.sendBookmarkIdList);\r\n    }\r\n    setFormOption() {\r\n        // 个数/页数选项的提示\r\n        options.setWantPageTip({\r\n            text: lang.transl('_页数'),\r\n            tip: lang.transl('_从本页开始下载提示'),\r\n            rangTip: lang.transl('_数字提示1'),\r\n        });\r\n    }\r\n    getWantPage() {\r\n        this.crawlNumber = this.checkWantPageInput(lang.transl('_从本页开始下载x页'), lang.transl('_下载所有页面'));\r\n    }\r\n    nextStep() {\r\n        this.readyGetIdList();\r\n        log.log(lang.transl('_正在抓取'));\r\n    }\r\n    readyGetIdList() {\r\n        // 判断页面类型\r\n        // 匹配 pathname 里用户 id 之后的字符\r\n        const test = location.pathname.match(/\\/users\\/\\d+(\\/.+)/);\r\n        if (test === null) {\r\n            // 用户主页\r\n            this.listType = 0;\r\n        }\r\n        else if (test.length === 2) {\r\n            const str = test[1]; //取出用户 id 之后的字符\r\n            if (str.includes('/artworks')) {\r\n                // 插画和漫画列表\r\n                this.listType = 1;\r\n            }\r\n            else if (str.includes('/illustrations')) {\r\n                // 插画列表\r\n                this.listType = 2;\r\n            }\r\n            else if (str.includes('/manga')) {\r\n                // 漫画列表\r\n                this.listType = 3;\r\n            }\r\n            else if (str.includes('/novels')) {\r\n                // 小说列表\r\n                this.listType = 4;\r\n                this.onceNumber = 24; // 如果是在小说列表页，一页只有 24 个作品\r\n            }\r\n        }\r\n        store.tag ? this.getIdListByTag() : this.getIdList();\r\n    }\r\n    getOffset() {\r\n        const nowPage = API.getURLSearchField(location.href, 'p'); // 判断当前处于第几页，页码从 1 开始。也可能没有页码\r\n        let offset = 0;\r\n        if (nowPage) {\r\n            offset = (parseInt(nowPage) - 1) * this.onceNumber;\r\n        }\r\n        if (offset < 0) {\r\n            offset = 0;\r\n        }\r\n        return offset;\r\n    }\r\n    // 根据页数设置，计算要下载的个数\r\n    getRequsetNumber() {\r\n        let requsetNumber = 9999999;\r\n        if (this.crawlNumber !== -1) {\r\n            requsetNumber = this.onceNumber * this.crawlNumber;\r\n        }\r\n        return requsetNumber;\r\n    }\r\n    // 获取用户某些类型的作品的 id 列表\r\n    async getIdList() {\r\n        let type = [];\r\n        switch (this.listType) {\r\n            case 0:\r\n                type = ['illusts', 'manga', 'novels'];\r\n                break;\r\n            case 1:\r\n                type = ['illusts', 'manga'];\r\n                break;\r\n            case 2:\r\n                type = ['illusts'];\r\n                break;\r\n            case 3:\r\n                type = ['manga'];\r\n                break;\r\n            case 4:\r\n                type = ['novels'];\r\n                break;\r\n        }\r\n        let idList = await API.getUserWorksByType(DOM.getUserId(), type);\r\n        // 判断是否全都是小说，如果是，把每页的作品个数设置为 24 个\r\n        const allWorkIsNovels = idList.every((data) => {\r\n            return data.type === 'novels';\r\n        });\r\n        allWorkIsNovels && (this.onceNumber = 24);\r\n        // 计算偏移量和需要保留的作品个数\r\n        const offset = this.getOffset();\r\n        const requsetNumber = this.getRequsetNumber();\r\n        // 按照 id 升序排列，之后会删除不需要的部分\r\n        idList.sort(API.sortByProperty('id')).reverse();\r\n        // 不带 tag 获取作品时，由于 API 是一次性返回用户的所有作品，可能大于要求的数量，所以需要去掉多余的作品。\r\n        // 删除 offset 需要去掉的部分。删除后面的 id，也就是近期作品\r\n        idList.splice(idList.length - offset, idList.length);\r\n        // 删除超过 requsetNumber 的作品。删除前面的 id，也就是早期作品\r\n        if (idList.length > requsetNumber) {\r\n            idList.splice(0, idList.length - requsetNumber);\r\n        }\r\n        // 储存\r\n        store.idList = store.idList.concat(idList);\r\n        this.getIdListFinished();\r\n    }\r\n    // 获取用户某些类型的作品的 id 列表（附带 tag）\r\n    async getIdListByTag() {\r\n        // 这里不用判断 0 也就是用户主页的情况，因为用户主页不会带 tag\r\n        let flag = 'illustmanga';\r\n        switch (this.listType) {\r\n            case 1:\r\n                flag = 'illustmanga';\r\n                break;\r\n            case 2:\r\n                flag = 'illusts';\r\n                break;\r\n            case 3:\r\n                flag = 'manga';\r\n                break;\r\n            case 4:\r\n                flag = 'novels';\r\n                break;\r\n        }\r\n        // 计算偏移量和需要保留的作品个数\r\n        const offset = this.getOffset();\r\n        const requsetNumber = this.getRequsetNumber();\r\n        let data = await API.getUserWorksByTypeWithTag(DOM.getUserId(), flag, store.tag, offset, requsetNumber);\r\n        // 图片和小说返回的数据是不同的，小说并没有 illustType 标记\r\n        if (this.listType === 4) {\r\n            const d = data;\r\n            d.body.works.forEach((data) => store.idList.push({\r\n                type: 'novels',\r\n                id: data.id,\r\n            }));\r\n        }\r\n        else {\r\n            const d = data;\r\n            d.body.works.forEach((data) => {\r\n                let type = 'illusts';\r\n                switch (data.illustType) {\r\n                    case 0:\r\n                        type = 'illusts';\r\n                        break;\r\n                    case 1:\r\n                        type = 'manga';\r\n                        break;\r\n                    case 2:\r\n                        type = 'ugoira';\r\n                        break;\r\n                }\r\n                store.idList.push({\r\n                    type,\r\n                    id: data.id,\r\n                });\r\n            });\r\n        }\r\n        this.getIdListFinished();\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.listType = 0;\r\n    }\r\n    sortResult() {\r\n        // 把作品数据按 id 倒序排列，id 大的在前面，这样可以先下载最新作品，后下载早期作品\r\n        store.result.sort(API.sortByProperty('id'));\r\n    }\r\n    destroy() {\r\n        DOM.clearSlot('crawlBtns');\r\n        DOM.clearSlot('otherBtns');\r\n        window.removeEventListener(EVT.list.getIdListFinished, this.sendBookmarkIdList);\r\n    }\r\n}\r\nexport { InitUserPage };\r\n","import { langText } from './langText';\r\nimport { EVT } from './EVT';\r\nimport { settings } from './setting/Settings';\r\n// 语言类\r\nclass Lang {\r\n    constructor() {\r\n        this.flag = 0;\r\n        this.setFlag();\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        // 选项变化时重新设置语言\r\n        window.addEventListener(EVT.list.settingChange, () => {\r\n            const old = this.flag;\r\n            this.setFlag();\r\n            if (this.flag !== old) {\r\n                EVT.sendMsg({\r\n                    msg: this.transl('_变更语言后刷新页面的提示'),\r\n                });\r\n            }\r\n        });\r\n    }\r\n    setFlag() {\r\n        const userSetLang = parseInt(settings.userSetLang);\r\n        this.flag = userSetLang === -1 ? this.getLangType() : userSetLang;\r\n    }\r\n    // 获取页面使用的语言，返回对应的 flag\r\n    getLangType() {\r\n        const userLang = document.documentElement.lang;\r\n        switch (userLang) {\r\n            case 'zh':\r\n            case 'zh-CN':\r\n            case 'zh-Hans':\r\n                return 0; // 简体中文\r\n            case 'ja':\r\n                return 1; // 日本語\r\n            case 'zh-Hant':\r\n            case 'zh-tw':\r\n            case 'zh-TW':\r\n                return 3; // 繁體中文\r\n            default:\r\n                return 2; // English\r\n        }\r\n    }\r\n    // translate 翻译\r\n    transl(name, ...arg) {\r\n        let content = langText[name][this.flag];\r\n        arg.forEach((val) => (content = content.replace('{}', val)));\r\n        return content;\r\n    }\r\n}\r\nconst lang = new Lang();\r\nexport { lang };\r\n","import { EVT } from './EVT';\r\n// 监听页面的无刷新切换\r\nclass ListenPageSwitch {\r\n    constructor() {\r\n        this.supportListenHistory();\r\n        this.listenPageSwitch();\r\n    }\r\n    // 为监听 history 的事件提供支持\r\n    supportListenHistory() {\r\n        const element = document.createElement('script');\r\n        element.setAttribute('type', 'text/javascript');\r\n        element.innerHTML = `\n    let _wr = function (type) {\n      let orig = history[type];\n      return function () {\n        let rv = orig.apply(this, arguments);\n        let e = new Event(type);\n        e.arguments = arguments;\n        window.dispatchEvent(e);\n        return rv;\n      };\n    };\n    history.pushState = _wr('pushState');\n    history.replaceState = _wr('replaceState');\n    `;\r\n        document.head.appendChild(element);\r\n    }\r\n    // 无刷新切换页面时派发事件\r\n    listenPageSwitch() {\r\n        ;\r\n        ['pushState', 'popstate', 'replaceState'].forEach((item) => {\r\n            window.addEventListener(item, () => {\r\n                EVT.fire(EVT.list.pageSwitch);\r\n            });\r\n        });\r\n    }\r\n}\r\nnew ListenPageSwitch();\r\n","import { DOM } from './DOM';\r\nimport { EVT } from './EVT';\r\nimport { states } from './States';\r\nimport { theme } from './Theme';\r\nimport { Colors } from './Colors';\r\n// 日志类\r\nclass Log {\r\n    constructor() {\r\n        this.logArea = document.createElement('div'); // 输出日志的区域\r\n        this.id = 'logWrap'; // 日志区域元素的 id\r\n        this.refresh = document.createElement('span'); // 刷新时使用的元素\r\n        this.level = ['success', 'warning', 'error'];\r\n        this.toBottom = false; // 指示是否需要把日志滚动到底部。当有日志被添加或刷新，则为 true。滚动到底部之后复位到 false，避免一直滚动到底部。\r\n        this.scrollToBottom();\r\n        // 切换页面时，如果任务已经完成，则清空输出区域，避免日志一直堆积。\r\n        window.addEventListener(EVT.list.pageSwitch, () => {\r\n            if (!states.busy) {\r\n                this.clear();\r\n            }\r\n        });\r\n    }\r\n    // 如果日志区域没有被添加到页面上，则添加上\r\n    checkElement() {\r\n        let test = document.getElementById(this.id);\r\n        if (test === null) {\r\n            this.logArea.id = this.id;\r\n            this.logArea.classList.add('beautify_scrollbar');\r\n            DOM.insertToHead(this.logArea);\r\n            theme.register(this.logArea);\r\n        }\r\n    }\r\n    // 清空日志\r\n    clear() {\r\n        this.logArea.innerHTML = '';\r\n    }\r\n    // 添加日志\r\n    /*\r\n    str 日志文本\r\n    level 日志等级\r\n    br 换行标签的个数\r\n    keepShow 追加日志的模式，默认为 true，把这一条日志添加后不再修改。false 则是刷新显示这条消息。\r\n  \r\n    level 日志等级：\r\n    -1 auto 不设置颜色\r\n    0 success 绿色\r\n    1 warning 黄色\r\n    2 error 红色\r\n    */\r\n    add(str, level, br, keepShow) {\r\n        this.checkElement();\r\n        let span = document.createElement('span');\r\n        if (!keepShow) {\r\n            span = this.refresh;\r\n        }\r\n        span.innerHTML = str;\r\n        if (level > -1) {\r\n            span.style.color = Colors[this.level[level]];\r\n        }\r\n        while (br > 0) {\r\n            span.appendChild(document.createElement('br'));\r\n            br--;\r\n        }\r\n        this.logArea.appendChild(span);\r\n        this.toBottom = true; // 需要把日志滚动到底部\r\n    }\r\n    log(str, br = 1, keepShow = true) {\r\n        this.add(str, -1, br, keepShow);\r\n    }\r\n    success(str, br = 1, keepShow = true) {\r\n        this.add(str, 0, br, keepShow);\r\n    }\r\n    warning(str, br = 1, keepShow = true) {\r\n        this.add(str, 1, br, keepShow);\r\n    }\r\n    error(str, br = 1, keepShow = true) {\r\n        this.add(str, 2, br, keepShow);\r\n    }\r\n    // 因为日志区域限制了最大高度，可能会出现滚动条，这里使日志总是滚动到底部\r\n    scrollToBottom() {\r\n        window.setInterval(() => {\r\n            if (this.toBottom) {\r\n                this.logArea.scrollTop = this.logArea.scrollHeight;\r\n                this.toBottom = false;\r\n            }\r\n        }, 800);\r\n    }\r\n}\r\nconst log = new Log();\r\nexport { log };\r\n","import { lang } from './Lang';\r\nimport { EVT } from './EVT';\r\nimport { theme } from './Theme';\r\nimport { Colors } from './Colors';\r\n// 一个简单的消息框\r\nclass MsgBox {\r\n    constructor() {\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        window.addEventListener(EVT.list.showMsg, (ev) => {\r\n            const msg = ev.detail.data;\r\n            this.create(msg);\r\n        });\r\n    }\r\n    create(data) {\r\n        const el = document.createElement('div');\r\n        el.classList.add('xz_msg_box');\r\n        let colorStyle = '';\r\n        if (data.type) {\r\n            colorStyle = `style=\"color:${Colors[data.type]}\"`;\r\n        }\r\n        el.innerHTML = `\n        <p class=\"title\">${data.title || ''}</p>\n        <p class=\"content\" ${colorStyle}>${data.msg}</p>\n        <button class=\"btn\" type=\"button\">${data.btn || lang.transl('_确定')}</button>\n      `;\r\n        theme.register(el);\r\n        document.body.insertAdjacentElement('afterbegin', el);\r\n        const btn = el.querySelector('.btn');\r\n        btn.focus();\r\n        if (btn) {\r\n            el.addEventListener('click', (ev) => {\r\n                ev.stopPropagation();\r\n            });\r\n            btn.addEventListener('click', () => {\r\n                this.remove(el);\r\n            });\r\n            document.addEventListener('click', () => {\r\n                this.remove(el);\r\n            });\r\n            window.addEventListener(EVT.list.closeCenterPanel, () => {\r\n                this.remove(el);\r\n            });\r\n        }\r\n    }\r\n    remove(el) {\r\n        el && el.parentNode && el.parentNode.removeChild(el);\r\n    }\r\n}\r\nnew MsgBox();\r\n","import { EVT } from './EVT';\r\n// 获取页面类型\r\nclass PageType {\r\n    constructor() {\r\n        this.type = 0;\r\n        this.type = this.getType();\r\n        window.addEventListener(EVT.list.pageSwitch, () => {\r\n            this.checkTypeChange();\r\n        });\r\n    }\r\n    getType() {\r\n        const url = window.location.href;\r\n        const pathname = window.location.pathname;\r\n        let type;\r\n        if (window.location.hostname === 'www.pixiv.net' &&\r\n            ['/', '/manga', '/novel/', '/en/'].includes(pathname)) {\r\n            type = 0;\r\n        }\r\n        else if (/\\/artworks\\/\\d{1,10}/.test(url)) {\r\n            type = 1;\r\n        }\r\n        else if (/\\/users\\/\\d+/.test(url) && !url.includes('/bookmarks')) {\r\n            type = 2;\r\n            if (pathname.includes('/following')) {\r\n                type = 20;\r\n            }\r\n        }\r\n        else if (pathname.endsWith('bookmark.php')) {\r\n            type = 3;\r\n        }\r\n        else if (pathname.includes('/bookmarks/')) {\r\n            type = 4;\r\n        }\r\n        else if (url.includes('/tags/')) {\r\n            type = pathname.endsWith('/novels') ? 15 : 5;\r\n        }\r\n        else if (pathname === '/ranking_area.php' && location.search !== '') {\r\n            type = 6;\r\n        }\r\n        else if (pathname === '/ranking.php') {\r\n            type = 7;\r\n        }\r\n        else if (url.includes('https://www.pixivision.net') &&\r\n            url.includes('/a/')) {\r\n            type = 8;\r\n        }\r\n        else if (url.includes('/bookmark_add.php?id=') ||\r\n            url.includes('/bookmark_detail.php?illust_id=')) {\r\n            type = 9;\r\n        }\r\n        else if (url.includes('/bookmark_new_illust.php') ||\r\n            url.includes('/bookmark_new_illust_r18.php')) {\r\n            type = 10;\r\n        }\r\n        else if (pathname === '/discovery') {\r\n            type = 11;\r\n        }\r\n        else if (url.includes('/new_illust.php') ||\r\n            url.includes('/new_illust_r18.php')) {\r\n            type = 12;\r\n        }\r\n        else if (pathname === '/novel/show.php') {\r\n            type = 13;\r\n        }\r\n        else if (pathname.startsWith('/novel/series/')) {\r\n            type = 14;\r\n        }\r\n        else if (pathname === '/novel/ranking.php') {\r\n            type = 16;\r\n        }\r\n        else if (pathname.startsWith('/novel/bookmark_new')) {\r\n            type = 17;\r\n        }\r\n        else if (pathname.startsWith('/novel/new')) {\r\n            type = 18;\r\n        }\r\n        else if (pathname.startsWith('/user/') && pathname.includes('/series/')) {\r\n            type = 19;\r\n        }\r\n        else {\r\n            // 没有匹配到可用的页面类型\r\n            throw new Error('Unsupported page type');\r\n        }\r\n        return type;\r\n    }\r\n    // 页面切换时，检查页面类型是否变化\r\n    checkTypeChange() {\r\n        const old = this.type;\r\n        this.type = this.getType();\r\n        if (this.type !== old) {\r\n            EVT.fire(EVT.list.pageSwitchedTypeChange, this.type);\r\n        }\r\n        else {\r\n            EVT.fire(EVT.list.pageSwitchedTypeNotChange, this.type);\r\n        }\r\n    }\r\n}\r\nconst pageType = new PageType();\r\nexport { pageType };\r\n","// 下载进度条\r\nimport { store } from './Store';\r\nimport { DOM } from './DOM';\r\nimport { lang } from './Lang';\r\n// 进度条\r\nclass ProgressBar {\r\n    constructor() {\r\n        this.wrapHTML = `\n  <div class=\"progressBarWrap\">\n  <div class=\"total\">\n  <span class=\"text\">${lang.transl('_下载进度')}</span>\n  <div class=\"right1\">\n  <div class=\"progressBar progressBar1\">\n  <div class=\"progress progress1\"></div>\n  </div>\n  <div class=\"totalNumberWrap\">\n  <span class=\"downloaded\">0</span>\n  /\n  <span class=\"imgNum totalNumber\">0</span>\n  </div>\n  </div>\n  </div>\n\n  <ul class=\"progressBarList\"></ul>\n  </div>\n  `;\r\n        this.barHTML = `<li class=\"downloadBar\">\n  <div class=\"progressBar progressBar2\">\n  <div class=\"progress progress2\"></div>\n  </div>\n  <div class=\"progressTip progressTip2\">\n  <span class=\"fileName\"></span>\n  <span class=\"loadedWrap\">\n  <span class=\"loaded\"></span>\n  </span>\n  </div>\n  </li>`;\r\n        this.allProgressBar = [];\r\n        this.KB = 1024;\r\n        this.MB = 1024 * 1024;\r\n        this.wrap = DOM.useSlot('progressBar', this.wrapHTML);\r\n        this.downloadedEl = this.wrap.querySelector('.downloaded');\r\n        this.progressColorEl = this.wrap.querySelector('.progress1');\r\n        this.listWrap = this.wrap.querySelector('.progressBarList');\r\n        this.totalNumberEl = this.wrap.querySelector('.totalNumber');\r\n    }\r\n    // 重设所有进度\r\n    reset(progressBarNum, downloaded = 0) {\r\n        if (progressBarNum === 0) {\r\n            // 如果进度条数量为 0（抓取结果为空），则隐藏进度条区域\r\n            return this.hide();\r\n        }\r\n        // 重置总进度条\r\n        this.setTotalProgress(downloaded);\r\n        this.totalNumberEl.textContent = store.result.length.toString();\r\n        // 重置子进度条\r\n        this.listWrap.innerHTML = this.barHTML.repeat(progressBarNum);\r\n        this.show();\r\n        // 保存子进度条上需要使用到的元素\r\n        const allProgressBar = this.listWrap.querySelectorAll('.downloadBar');\r\n        this.allProgressBar = [];\r\n        for (const bar of allProgressBar) {\r\n            const data = {\r\n                name: bar.querySelector('.fileName'),\r\n                loaded: bar.querySelector('.loaded'),\r\n                progress: bar.querySelector('.progress'),\r\n            };\r\n            this.allProgressBar.push(data);\r\n        }\r\n    }\r\n    // 设置总进度条的进度\r\n    setTotalProgress(downloaded) {\r\n        this.downloadedEl.textContent = downloaded.toString();\r\n        const progress = (downloaded / store.result.length) * 100;\r\n        this.progressColorEl.style.width = progress + '%';\r\n    }\r\n    // 设置子进度条的进度\r\n    setProgress(index, data) {\r\n        const bar = this.allProgressBar[index];\r\n        bar.name.textContent = data.name;\r\n        let text = '';\r\n        if (data.total >= this.MB) {\r\n            // 如果判断条件加上： || data.total === 0\r\n            // 则文件未下载时显示的默认单位会是 MiB\r\n            // 使用 MiB 作为单位\r\n            text = `${(data.loaded / this.MB).toFixed(1)}/${(data.total / this.MB).toFixed(1)} MiB`;\r\n        }\r\n        else {\r\n            // 使用 KiB 作为单位\r\n            text = `${Math.floor(data.loaded / this.KB)}/${Math.floor(data.total / this.KB)} KiB`;\r\n        }\r\n        bar.loaded.textContent = text;\r\n        const progress = data.loaded / data.total || 0; // 若结果为 NaN 则设为 0\r\n        bar.progress.style.width = progress * 100 + '%';\r\n    }\r\n    // 让某个子进度条显示警告色\r\n    showErrorColor(index, show) {\r\n        const bar = this.allProgressBar[index];\r\n        bar.name.classList[show ? 'add' : 'remove']('downloadError');\r\n    }\r\n    show() {\r\n        this.wrap.style.display = 'block';\r\n    }\r\n    hide() {\r\n        this.wrap.style.display = 'none';\r\n    }\r\n}\r\nconst progressBar = new ProgressBar();\r\nexport { progressBar };\r\n","// 快速收藏\r\nimport { API } from './API';\r\nimport { lang } from './Lang';\r\nimport { token } from './Token';\r\nimport { settings } from './setting/Settings';\r\nclass QuickBookmark {\r\n    constructor() {\r\n        this.btn = document.createElement('a'); // 快速收藏按钮\r\n        this.btnId = 'quickBookmarkEl';\r\n        this.colorClass = 'bookmarkedColor';\r\n        this.likeBtnClass = '_35vRH4a';\r\n        this.isNovel = false;\r\n        this.isBookmarked = null;\r\n        this.timer = 0;\r\n        this.flag = 'xzFlag'; // 当插入快速下载按钮时，给原本的收藏按钮添加一个标记\r\n        this.init();\r\n    }\r\n    async init() {\r\n        // 在某些条件下，不展开快速收藏功能\r\n        if (!token.token) {\r\n            return;\r\n        }\r\n        window.clearInterval(this.timer);\r\n        this.isNovel = window.location.href.includes('/novel');\r\n        this.isBookmarked = !!(await this.getBookmarkData());\r\n        this.timer = window.setInterval(() => {\r\n            this.initBtn();\r\n        }, 300);\r\n    }\r\n    async getBookmarkData() {\r\n        let data;\r\n        if (this.isNovel) {\r\n            data = await API.getNovelData(API.getNovelId());\r\n        }\r\n        else {\r\n            data = await API.getArtworkData(API.getIllustId());\r\n        }\r\n        return data.body.bookmarkData;\r\n    }\r\n    // 插入快速收藏按钮\r\n    initBtn() {\r\n        // 从父元素查找作品下方的工具栏\r\n        const toolbarParent = document.querySelectorAll('main > section');\r\n        for (const el of toolbarParent) {\r\n            const test = el.querySelector('div>section');\r\n            if (test) {\r\n                this.toolbar = test;\r\n                break;\r\n            }\r\n        }\r\n        if (this.toolbar) {\r\n            // 获取原本的收藏按钮（其实是按钮外层的 div）\r\n            this.pixivBMKDiv = this.toolbar.childNodes[2];\r\n            // 当没有收藏按钮时，停止执行（如用户处于自己作品的页面时没有收藏按钮）\r\n            // 当收藏按钮是是上一个页面的，不是这个页面新创建的时，停止执行\r\n            if (!this.pixivBMKDiv || this.pixivBMKDiv.classList.contains(this.flag)) {\r\n                return;\r\n            }\r\n            // 隐藏原来的收藏按钮\r\n            this.pixivBMKDiv.style.display = 'none';\r\n            this.pixivBMKDiv.classList.add(this.flag);\r\n            // 如果没有快速收藏元素则添加\r\n            this.btn = this.toolbar.querySelector('#' + this.btnId);\r\n            if (!this.btn) {\r\n                this.btn = this.createBtn();\r\n                this.toolbar.insertBefore(this.btn, this.toolbar.childNodes[3]);\r\n            }\r\n            if (this.isBookmarked) {\r\n                this.bookmarked();\r\n            }\r\n            else {\r\n                this.readyBookmark();\r\n            }\r\n            window.clearInterval(this.timer);\r\n        }\r\n    }\r\n    createBtn() {\r\n        const btn = document.createElement('a');\r\n        btn.id = this.btnId;\r\n        btn.textContent = '✩';\r\n        btn.href = 'javascript:void(0)';\r\n        btn.title = lang.transl('_快速收藏');\r\n        return btn;\r\n    }\r\n    // 准备快速收藏\r\n    readyBookmark() {\r\n        this.btn.classList.remove(this.colorClass);\r\n        this.btn.href = 'javascript:void(0)';\r\n        this.btn.addEventListener('click', () => {\r\n            const type = this.isNovel ? 'novels' : 'illusts';\r\n            const id = this.isNovel ? API.getNovelId() : API.getIllustId();\r\n            // 点赞\r\n            API.addLike(id, type, token.token);\r\n            // 将点赞按钮的颜色改为蓝色\r\n            let likeBtn = document.querySelector(`.${this.likeBtnClass}`);\r\n            if (!likeBtn) {\r\n                // 上面尝试直接用 class 获取点赞按钮，如果获取不到则从工具栏里选择\r\n                // 点赞按钮是工具栏里的最后一个 button 元素\r\n                console.error('likeBtn class is not available');\r\n                const btnList = this.toolbar.querySelectorAll('button');\r\n                likeBtn = btnList[btnList.length - 1];\r\n            }\r\n            likeBtn.style.color = '#0096fa';\r\n            if (this.isBookmarked) {\r\n                return;\r\n            }\r\n            // 点击 p 站自带的收藏按钮，这是因为这一行为将会在作品下方显示推荐作品。如果不点击自带的按钮，只使用本程序添加的按钮，那么就不会出现推荐作品了。\r\n            const pixivBMKBtn = this.pixivBMKDiv && this.pixivBMKDiv.querySelector('button');\r\n            pixivBMKBtn && pixivBMKBtn.click();\r\n            let tags = [];\r\n            // 如果设置了附带 tag，则从页面上获取 tag\r\n            if (settings.widthTag === '1') {\r\n                const tagElements = document.querySelectorAll('._1LEXQ_3 li');\r\n                for (const el of tagElements) {\r\n                    const nowA = el.querySelector('a');\r\n                    if (nowA) {\r\n                        const nowTag = nowA.textContent.trim();\r\n                        if (nowTag) {\r\n                            tags.push(nowTag);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // 如果一个作品是原创作品，它的 tag 列表的最前面会显示“原创” tag。以前是统一显示日文的“オリジナル”，现在则会根据用户语言显示不同的文字。这里会把“オリジナル”添加到末尾，保持和以前的习惯一致。\r\n            if (tags.includes('原创') ||\r\n                tags.includes('Original') ||\r\n                tags.includes('창작')) {\r\n                tags.push('オリジナル');\r\n            }\r\n            // 调用添加收藏的 api\r\n            // 这里加了个延迟，因为上面先点击了 pixiv 自带的收藏按钮，但不加延迟的话， p 站自己的不带 tag 的请求反而是后发送的。\r\n            setTimeout(() => {\r\n                API.addBookmark(type, id, tags, settings.restrict === '1', token.token)\r\n                    .then((response) => response.json())\r\n                    .then((data) => {\r\n                    if (data.error === false) {\r\n                        this.isBookmarked = true;\r\n                        this.bookmarked();\r\n                    }\r\n                });\r\n            }, 400);\r\n        });\r\n    }\r\n    // 如果这个作品已收藏，则改变样式\r\n    bookmarked() {\r\n        this.btn.classList.add(this.colorClass);\r\n        if (this.isNovel) {\r\n            this.btn.href = `/novel/bookmark_add.php?id=${API.getNovelId()}`;\r\n        }\r\n        else {\r\n            this.btn.href = `/bookmark_add.php?type=illust&illust_id=${API.getIllustId()}`;\r\n        }\r\n    }\r\n}\r\nexport { QuickBookmark };\r\n","import { EVT } from './EVT';\r\nimport { lang } from './Lang';\r\nimport { states } from './States';\r\n// 快速下载按钮\r\n// 只负责触发快速下载事件，不负责后续的业务逻辑\r\n// 当在无刷新切换的页面里使用快速下载时（监听了 QuickDownload 事件），记得在切换页面时解除事件监听，避免造成重复监听\r\nclass QuickDownloadBtn {\r\n    constructor() {\r\n        this.live = true; // 存活状态\r\n        this.addBtn();\r\n        this.bindEvents();\r\n    }\r\n    addBtn() {\r\n        // 在右侧添加快速下载按钮\r\n        this.btn = document.createElement('button');\r\n        this.btn.id = 'quick_down_btn';\r\n        this.btn.textContent = '↓';\r\n        this.btn.setAttribute('title', lang.transl('_快速下载本页') + ' (Alt + Q)');\r\n        document.body.insertAdjacentElement('afterbegin', this.btn);\r\n    }\r\n    bindEvents() {\r\n        // 点击按钮启动快速下载\r\n        this.btn.addEventListener('click', () => {\r\n            states.quickDownload = true;\r\n            EVT.fire(EVT.list.QuickDownload);\r\n        }, false);\r\n        // 使用快捷键 Alt + q 启动快速下载\r\n        window.addEventListener('keydown', (ev) => {\r\n            if (this.live && ev.altKey && ev.code === 'KeyQ') {\r\n                states.quickDownload = true;\r\n                EVT.fire(EVT.list.QuickDownload);\r\n            }\r\n        }, false);\r\n        // 下载完成，或者下载中止时，复位状态\r\n        const evtList = [\r\n            EVT.list.crawlEmpty,\r\n            EVT.list.downloadStop,\r\n            EVT.list.downloadPause,\r\n            EVT.list.downloadComplete,\r\n        ];\r\n        for (const ev of evtList) {\r\n            window.addEventListener(ev, () => {\r\n                states.quickDownload = false;\r\n            });\r\n        }\r\n        // 页面类型改变时销毁\r\n        window.addEventListener(EVT.list.pageSwitchedTypeChange, () => {\r\n            this.destroy();\r\n        });\r\n    }\r\n    destroy() {\r\n        this.live = false;\r\n        const parent = this.btn.parentNode;\r\n        if (parent) {\r\n            parent.removeChild(this.btn);\r\n        }\r\n    }\r\n}\r\nexport { QuickDownloadBtn };\r\n","import { EVT } from './EVT';\r\nimport { log } from './Log';\r\nimport { lang } from './Lang';\r\nimport { store } from './Store';\r\nimport { states } from './States';\r\nimport { downloadStates } from './DownloadStates';\r\nimport { IndexedDB } from './IndexedDB';\r\n// 断点续传。恢复未完成的下载\r\nclass Resume {\r\n    constructor() {\r\n        this.flag = false; // 指示是否处于恢复模式\r\n        this.DBName = 'PBD';\r\n        this.DBVer = 3;\r\n        this.metaName = 'taskMeta'; // 下载任务元数据的表名\r\n        this.dataName = 'taskData'; // 下载任务数据的表名\r\n        this.statesName = 'taskStates'; // 下载状态列表的表名\r\n        this.part = []; // 储存每个分段里的数据的数量\r\n        this.try = 0; // 任务结果是分批储存的，记录每批失败了几次。根据失败次数减少每批的数量\r\n        // 尝试存储抓取结果时，单次存储的数量不能超过这个数字。因为超过这个数字可能会碰到单次存储的上限\r\n        // 由于每个结果的体积可能不同，所以这只是一个预估值\r\n        // 这有助于减少尝试次数。因为存储的思路是存储失败时改为上次数量的 1/2。例如有 100 w 个结果，存储算法会依次尝试存入 100 w、50 w、25 w、12.5 w 以此类推，直到最后有一次能成功存储一批数据。这样的话就进行了 4 次尝试才成功存入一批数据。但通过直接指定一批数据的大小为 onceMax，理想情况下可以只尝试一次就成功存入一批数据。\r\n        // 非理想情况下，即这个数量的结果已经超过了单次存储上限（目前推测这可能会在大量抓取小说、动图时出现；如果抓取的作品大部分是插画、漫画，这个数量的结果应该不可能超出存储上限），那么这不会减少尝试数量，但因为每次尝试存储的数量不会超过这个数字，这依然有助于减少每次尝试时的资源占用、耗费时间。\r\n        this.onceMax = 150000;\r\n        this.putStatesTime = 2000; // 每隔指定时间存储一次最新的下载状态\r\n        this.needPutStates = false; // 指示是否需要更新存储的下载状态\r\n        this.IDB = new IndexedDB();\r\n        this.init();\r\n    }\r\n    async init() {\r\n        if (location.hostname.includes('pixivision.net')) {\r\n            return;\r\n        }\r\n        await this.initDB();\r\n        this.restoreData();\r\n        this.bindEvents();\r\n        this.regularPutStates();\r\n        this.clearExired();\r\n    }\r\n    // 初始化数据库，获取数据库对象\r\n    async initDB() {\r\n        // 在升级事件里创建表和索引\r\n        const onUpdate = (db) => {\r\n            if (!db.objectStoreNames.contains(this.metaName)) {\r\n                const metaStore = db.createObjectStore(this.metaName, {\r\n                    keyPath: 'id',\r\n                });\r\n                metaStore.createIndex('id', 'id', { unique: true });\r\n                metaStore.createIndex('url', 'url', { unique: true });\r\n            }\r\n            if (!db.objectStoreNames.contains(this.dataName)) {\r\n                const dataStore = db.createObjectStore(this.dataName, {\r\n                    keyPath: 'id',\r\n                });\r\n                dataStore.createIndex('id', 'id', { unique: true });\r\n            }\r\n            if (!db.objectStoreNames.contains(this.statesName)) {\r\n                const statesStore = db.createObjectStore(this.statesName, {\r\n                    keyPath: 'id',\r\n                });\r\n                statesStore.createIndex('id', 'id', { unique: true });\r\n            }\r\n        };\r\n        // 打开数据库\r\n        return new Promise(async (resolve, reject) => {\r\n            resolve(await this.IDB.open(this.DBName, this.DBVer, onUpdate));\r\n        });\r\n    }\r\n    // 恢复未完成任务的数据\r\n    async restoreData() {\r\n        // 如果下载器在抓取或者在下载，则不恢复数据\r\n        if (states.busy) {\r\n            return;\r\n        }\r\n        // 1 获取任务的元数据\r\n        const meta = (await this.IDB.get(this.metaName, this.getURL(), 'url'));\r\n        if (!meta) {\r\n            this.flag = false;\r\n            return;\r\n        }\r\n        log.warning(lang.transl('_正在恢复抓取结果'));\r\n        this.taskId = meta.id;\r\n        // 2 恢复抓取结果\r\n        // 生成每批数据的 id 列表\r\n        const dataIdList = this.createIdList(meta.id, meta.part);\r\n        // 读取全部数据并恢复\r\n        const promiseList = [];\r\n        for (const id of dataIdList) {\r\n            promiseList.push(this.IDB.get(this.dataName, id));\r\n        }\r\n        await Promise.all(promiseList).then((res) => {\r\n            store.result = [];\r\n            const r = res;\r\n            for (const taskData of r) {\r\n                for (const data of taskData.data) {\r\n                    store.result.push(data);\r\n                }\r\n            }\r\n        });\r\n        // 3 恢复下载状态\r\n        const data = (await this.IDB.get(this.statesName, this.taskId));\r\n        if (data) {\r\n            downloadStates.replace(data.states);\r\n        }\r\n        store.crawlCompleteTime = meta.date;\r\n        // 恢复模式就绪\r\n        this.flag = true;\r\n        log.success(lang.transl('_已恢复抓取结果'), 2);\r\n        // 发出恢复下载的信号\r\n        EVT.fire(EVT.list.resume);\r\n    }\r\n    bindEvents() {\r\n        // 抓取完成时，保存这次任务的数据\r\n        const evs = [EVT.list.crawlFinish, EVT.list.resultChange];\r\n        for (const ev of evs) {\r\n            window.addEventListener(ev, async () => {\r\n                // 首先检查这个网址下是否已经存在数据，如果有数据，则清除之前的数据，保持每个网址只有一份数据\r\n                const taskData = (await this.IDB.get(this.metaName, this.getURL(), 'url'));\r\n                if (taskData) {\r\n                    await this.IDB.delete(this.metaName, taskData.id);\r\n                    await this.IDB.delete(this.statesName, taskData.id);\r\n                }\r\n                // 保存本次任务的数据\r\n                // 如果此时本次任务已经完成，就不进行保存了\r\n                if (downloadStates.downloadedCount() === store.result.length) {\r\n                    return;\r\n                }\r\n                log.warning(lang.transl('_正在保存抓取结果'));\r\n                this.taskId = new Date().getTime();\r\n                this.part = [];\r\n                await this.saveTaskData();\r\n                // 保存 meta 数据\r\n                const metaData = {\r\n                    id: this.taskId,\r\n                    url: this.getURL(),\r\n                    part: this.part.length,\r\n                    date: store.crawlCompleteTime,\r\n                };\r\n                this.IDB.add(this.metaName, metaData);\r\n                // 保存 states 数据\r\n                const statesData = {\r\n                    id: this.taskId,\r\n                    states: downloadStates.states,\r\n                };\r\n                this.IDB.add(this.statesName, statesData);\r\n                log.success(lang.transl('_已保存抓取结果'), 2);\r\n            });\r\n        }\r\n        // 当有文件下载完成时，更新下载状态\r\n        window.addEventListener(EVT.list.downloadSuccess, () => {\r\n            this.needPutStates = true;\r\n        });\r\n        // 任务下载完毕时，以及停止任务时，清除这次任务的数据\r\n        const clearDataEv = [EVT.list.downloadComplete, EVT.list.downloadStop];\r\n        for (const ev of clearDataEv) {\r\n            window.addEventListener(ev, async () => {\r\n                if (!this.taskId) {\r\n                    return;\r\n                }\r\n                const meta = (await this.IDB.get(this.metaName, this.taskId));\r\n                if (!meta) {\r\n                    return;\r\n                }\r\n                this.IDB.delete(this.metaName, this.taskId);\r\n                this.IDB.delete(this.statesName, this.taskId);\r\n                const dataIdList = this.createIdList(this.taskId, meta.part);\r\n                for (const id of dataIdList) {\r\n                    this.IDB.delete(this.dataName, id);\r\n                }\r\n                this.flag = false;\r\n            });\r\n        }\r\n        // 开始新的抓取时，取消恢复模式\r\n        window.addEventListener(EVT.list.crawlStart, () => {\r\n            this.flag = false;\r\n        });\r\n        // 切换页面时，重新检查恢复数据\r\n        window.addEventListener(EVT.list.pageSwitch, () => {\r\n            this.flag = false;\r\n            this.restoreData();\r\n        });\r\n        // 清空已保存的抓取结果\r\n        window.addEventListener(EVT.list.clearSavedCrawl, () => {\r\n            this.flag = false;\r\n            this.clearSavedCrawl();\r\n        });\r\n    }\r\n    // 定时 put 下载状态\r\n    async regularPutStates() {\r\n        setInterval(() => {\r\n            if (this.needPutStates) {\r\n                const statesData = {\r\n                    id: this.taskId,\r\n                    states: downloadStates.states,\r\n                };\r\n                this.needPutStates = false;\r\n                // 如果此时本次任务已经完成，就不进行保存了\r\n                if (downloadStates.downloadedCount() === store.result.length) {\r\n                    return;\r\n                }\r\n                this.IDB.put(this.statesName, statesData);\r\n            }\r\n        }, this.putStatesTime);\r\n    }\r\n    // 存储抓取结果\r\n    async saveTaskData() {\r\n        return new Promise(async (resolve, reject) => {\r\n            // 每一批任务的第一次执行会尝试保存所有剩余数据(0.5 的 0 次幂是 1)\r\n            // 如果出错了，则每次执行会尝试保存上一次数据量的一半，直到这次存储成功\r\n            // 之后继续进行下一批任务（如果有）\r\n            let tryNum = Math.floor(store.result.length * Math.pow(0.5, this.try));\r\n            // 如果这批尝试数据大于指定数量，则设置为指定数量\r\n            tryNum > this.onceMax && (tryNum = this.onceMax);\r\n            let data = {\r\n                id: this.numAppendNum(this.taskId, this.part.length),\r\n                data: store.result.slice(this.getPartTotal(), this.getPartTotal() + tryNum),\r\n            };\r\n            try {\r\n                // 当成功存储了一批数据时\r\n                await this.IDB.add(this.dataName, data);\r\n                this.part.push(data.data.length); // 记录这一次保存的结果数量\r\n                this.try = 0; // 重置已尝试次数\r\n                // 任务数据全部添加完毕\r\n                if (this.getPartTotal() >= store.result.length) {\r\n                    // console.log('add complete')\r\n                    resolve();\r\n                }\r\n                else {\r\n                    // 任务数据没有添加完毕，继续添加\r\n                    resolve(this.saveTaskData());\r\n                }\r\n            }\r\n            catch (error) {\r\n                // 当存储失败时\r\n                console.error(error);\r\n                if (error.target && error.target.error && error.target.error.message) {\r\n                    const msg = error.target.error.message;\r\n                    if (msg.includes('too large')) {\r\n                        // 体积超大\r\n                        // 尝试次数 + 1 ，进行下一次尝试\r\n                        this.try++;\r\n                        resolve(this.saveTaskData());\r\n                    }\r\n                    else {\r\n                        // 未知错误，不再进行尝试\r\n                        this.try = 0;\r\n                        log.error('IndexedDB: ' + msg);\r\n                        reject(error);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    // 清除过期的数据\r\n    async clearExired() {\r\n        // 数据的过期时间，设置为 30 天。30*24*60*60*1000\r\n        const expiryTime = 2592000000;\r\n        const nowTime = new Date().getTime();\r\n        const callback = (item) => {\r\n            if (item) {\r\n                const data = item.value;\r\n                // 检查数据是否过期\r\n                if (nowTime - data.id > expiryTime) {\r\n                    this.IDB.delete(this.metaName, data.id);\r\n                    this.IDB.delete(this.statesName, data.id);\r\n                    const dataIdList = this.createIdList(data.id, data.part);\r\n                    for (const id of dataIdList) {\r\n                        this.IDB.delete(this.dataName, id);\r\n                    }\r\n                }\r\n                item.continue();\r\n            }\r\n        };\r\n        this.IDB.openCursor(this.metaName, callback);\r\n    }\r\n    // 计算 part 数组里的数字之和\r\n    getPartTotal() {\r\n        if (this.part.length === 0) {\r\n            return 0;\r\n        }\r\n        return this.part.reduce((prev, curr) => {\r\n            return prev + curr;\r\n        });\r\n    }\r\n    // 处理本页面的 url\r\n    getURL() {\r\n        return window.location.href.split('#')[0];\r\n    }\r\n    // 在数字后面追加数字\r\n    // 用于在 task id  后面追加序号数字(part)\r\n    numAppendNum(id, num) {\r\n        return parseInt(id.toString() + num);\r\n    }\r\n    // 根据 taskMeta 里的 id 和 part 数量，生成 taskData 里对应的数据的 id 列表\r\n    createIdList(taskid, part) {\r\n        // part 记录数据分成了几部分，所以是从 1 开始的，而不是从 0 开始\r\n        // 生成的 id 的结尾是从 0 开始增加的\r\n        const arr = [];\r\n        let start = 0;\r\n        while (start < part) {\r\n            arr.push(this.numAppendNum(taskid, start));\r\n            start++;\r\n        }\r\n        return arr;\r\n    }\r\n    // 清空已保存的抓取结果\r\n    async clearSavedCrawl() {\r\n        await Promise.all([\r\n            this.IDB.clear(this.metaName),\r\n            this.IDB.clear(this.dataName),\r\n            this.IDB.clear(this.statesName),\r\n        ]);\r\n        EVT.sendMsg({\r\n            msg: lang.transl('_数据清除完毕'),\r\n            type: 'success',\r\n        });\r\n    }\r\n}\r\nconst resume = new Resume();\r\nexport { resume };\r\n","import { lang } from './Lang';\r\nimport { API } from './API';\r\nimport { log } from './Log';\r\nimport { DOM } from './DOM';\r\nimport { EVT } from './EVT';\r\nimport { img2ico } from './ImageToIcon';\r\n// 保存用户头像为图标\r\nclass SaveAvatarIcon {\r\n    constructor() {\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        window.addEventListener(EVT.list.saveAvatarIcon, () => {\r\n            this.saveAvatarIcon();\r\n        });\r\n    }\r\n    async saveAvatarIcon() {\r\n        const userId = DOM.getUserId();\r\n        const userProfile = await API.getUserProfile(userId);\r\n        const bigImg = userProfile.body.imageBig; // imageBig 并不是头像原图，而是裁剪成 170 px 的尺寸\r\n        const fullSizeImg = bigImg.replace('_170', ''); // 去掉 170 标记，获取头像图片的原图\r\n        // 生成 ico 文件\r\n        // 尺寸固定为 256，因为尺寸更小的图标如 128，在 windows 资源管理器里会被缩小到 48 显示\r\n        const blob = await img2ico.convert({\r\n            size: [256],\r\n            source: fullSizeImg,\r\n            shape: 'fillet',\r\n            bleed: true,\r\n        });\r\n        // 直接保存到下载文件夹\r\n        const url = URL.createObjectURL(blob);\r\n        const name = `ico_${userProfile.body.name}_${userId}.ico`;\r\n        DOM.downloadFile(url, name);\r\n        log.success('✓ ' + lang.transl('_保存用户头像为图标'));\r\n        EVT.fire(EVT.list.closeCenterPanel);\r\n    }\r\n}\r\nnew SaveAvatarIcon();\r\n","import { EVT } from './EVT';\r\nimport { lang } from './Lang';\r\n// 显示正在转换的文件数量\r\nclass ShowConvertCount {\r\n    constructor(el) {\r\n        this.el = el;\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        window.addEventListener(EVT.list.convertChange, (ev) => {\r\n            const count = ev.detail.data;\r\n            let convertText = '';\r\n            if (count > 0) {\r\n                convertText = lang.transl('_转换任务提示', count.toString());\r\n            }\r\n            this.el.textContent = convertText;\r\n        });\r\n    }\r\n}\r\nexport { ShowConvertCount };\r\n","import { EVT } from './EVT';\r\nimport { lang } from './Lang';\r\n// 显示跳过下载的文件数量\r\nclass ShowSkipCount {\r\n    constructor(el) {\r\n        this.count = 0; // 跳过下载的数量\r\n        this.el = el;\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        window.addEventListener(EVT.list.crawlStart, () => {\r\n            this.reset();\r\n        });\r\n        window.addEventListener(EVT.list.downloadStop, () => {\r\n            // 重置计数但不清空提示文字，因为用户还需要看\r\n            this.count = 0;\r\n        });\r\n        window.addEventListener(EVT.list.skipDownload, () => {\r\n            this.addCount();\r\n        });\r\n        window.addEventListener(EVT.list.downloadStart, () => {\r\n            if (this.count === 0) {\r\n                this.reset();\r\n            }\r\n        });\r\n        window.addEventListener(EVT.list.downloadComplete, () => {\r\n            // 重置计数但不清空提示文字，因为用户还需要看\r\n            this.count = 0;\r\n        });\r\n    }\r\n    addCount() {\r\n        this.count++;\r\n        this.el.textContent = lang.transl('_已跳过n个文件', this.count.toString());\r\n    }\r\n    reset() {\r\n        this.count = 0;\r\n        this.el.textContent = '';\r\n    }\r\n}\r\nexport { ShowSkipCount };\r\n","import { lang } from './Lang';\r\nimport { EVT } from './EVT';\r\n// 显示最近更新内容\r\nclass ShowWhatIsNew {\r\n    constructor() {\r\n        this.newTag = '_xzNew660';\r\n        this.show();\r\n    }\r\n    show() {\r\n        const storeName = 'xzNewVerTag';\r\n        const value = localStorage.getItem(storeName);\r\n        if (window.location.host.includes('pixiv.net') && value !== this.newTag) {\r\n            EVT.sendMsg({\r\n                title: `Powerful Pixiv Downloader ${lang.transl('_最近更新')}`,\r\n                msg: lang.transl(this.newTag),\r\n            });\r\n            localStorage.setItem(storeName, this.newTag);\r\n        }\r\n    }\r\n}\r\nnew ShowWhatIsNew();\r\n","import { EVT } from './EVT';\r\n// 储存需要跨组件使用的、会变化的状态\r\n// 这里的状态不需要持久化保存。\r\n// 状态的值通常只由单一的组件修改，其他组件只读取不修改\r\nclass States {\r\n    constructor() {\r\n        // 表示下载器是否处于繁忙状态\r\n        // 如果下载器正在抓取中，或者正在下载中，则为 true；如果下载器处于空闲状态，则为 false\r\n        // 修改者：本组件根据下载器的事件来修改这个状态\r\n        this.busy = false;\r\n        // 快速下载标记。如果为 true 说明进入了快速下载模式\r\n        // 修改者：QuickDownloadBtn 组件里，启动快速下载时设为 true，下载完成或中止时复位到 false\r\n        this.quickDownload = false;\r\n        // 不自动下载的标记。如果为 true，那么下载器在抓取完成后，不会自动开始下载。（即使用户设置了自动开始下载）\r\n        // 修改者：InitSearchArtworkPage 组件根据“预览搜索结果”的设置，修改这个状态\r\n        this.notAutoDownload = false;\r\n        // 在排行榜抓取时，是否只抓取“首次登场”的作品\r\n        // 修改者：InitRankingArtworkPage 组件修改这个状态\r\n        this.debut = false;\r\n        // 收藏模式的标记\r\n        // 修改者：本组件监听批量收藏作品的事件来修改这个标记\r\n        // 开始批量收藏时设为 true，收藏完成之后复位到 false\r\n        this.bookmarkMode = false;\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        const idle = [\r\n            EVT.list.crawlFinish,\r\n            EVT.list.downloadPause,\r\n            EVT.list.downloadStop,\r\n            EVT.list.downloadComplete,\r\n            EVT.list.bookmarkModeEnd,\r\n        ];\r\n        idle.forEach((type) => {\r\n            window.addEventListener(type, () => {\r\n                this.busy = false;\r\n            });\r\n        });\r\n        const busy = [\r\n            EVT.list.crawlStart,\r\n            EVT.list.downloadStart,\r\n            EVT.list.bookmarkModeStart,\r\n        ];\r\n        busy.forEach((type) => {\r\n            window.addEventListener(type, () => {\r\n                this.busy = true;\r\n            });\r\n        });\r\n        window.addEventListener(EVT.list.bookmarkModeStart, () => {\r\n            this.bookmarkMode = true;\r\n        });\r\n        window.addEventListener(EVT.list.bookmarkModeEnd, () => {\r\n            this.bookmarkMode = false;\r\n        });\r\n    }\r\n}\r\nconst states = new States();\r\nexport { states };\r\n","import { API } from './API';\r\nimport { EVT } from './EVT';\r\nimport { DOM } from './DOM';\r\n// 储存抓取结果\r\nclass Store {\r\n    constructor() {\r\n        this.idList = []; // 储存从列表中抓取到的作品的 id\r\n        this.resultMeta = []; // 储存抓取结果的元数据。\r\n        // 当用于图片作品时，它可以根据每个作品需要下载多少张，生成每一张图片的信息\r\n        this.resultIDList = []; // 储存抓取结果的元数据的 id 列表，用来判断该作品是否已经添加过了，避免重复添加\r\n        // resultIDList 可能会有隐患，因为没有区分图片和小说。如果一次抓取任务里，有图片和小说使用了相同的 id，那么只会保留先抓取到的那个。不过目前看来这种情况几乎不会发生。\r\n        this.result = []; // 储存抓取结果\r\n        this.rankList = {}; // 储存作品在排行榜中的排名\r\n        this.tag = ''; // 开始抓取时，储存页面此时的 tag\r\n        this.title = ''; // 开始抓取时，储存页面此时的 title\r\n        this.crawlCompleteTime = new Date();\r\n        this.bindEvents();\r\n    }\r\n    assignResult(data) {\r\n        // 图片详细信息的默认值\r\n        const dataDefault = {\r\n            idNum: 0,\r\n            id: '',\r\n            original: '',\r\n            thumb: '',\r\n            regular: '',\r\n            small: '',\r\n            title: '',\r\n            pageCount: 1,\r\n            dlCount: 1,\r\n            tags: [],\r\n            tagsWithTransl: [],\r\n            tagsTranslOnly: [],\r\n            user: '',\r\n            userId: '',\r\n            fullWidth: 0,\r\n            fullHeight: 0,\r\n            ext: '',\r\n            bmk: 0,\r\n            bookmarked: false,\r\n            date: '',\r\n            type: 0,\r\n            rank: '',\r\n            ugoiraInfo: null,\r\n            seriesTitle: null,\r\n            seriesOrder: null,\r\n            novelBlob: null,\r\n        };\r\n        return Object.assign(dataDefault, data);\r\n    }\r\n    // 添加每个作品的信息。只需要传递有值的属性\r\n    addResult(data) {\r\n        // 检查该作品数据是否已存在，已存在则不添加\r\n        if (data.idNum !== undefined && this.resultIDList.includes(data.idNum)) {\r\n            return;\r\n        }\r\n        if (data.idNum !== undefined) {\r\n            this.resultIDList.push(data.idNum);\r\n        }\r\n        // 添加该作品的元数据\r\n        const result = this.assignResult(data);\r\n        this.resultMeta.push(result);\r\n        EVT.fire(EVT.list.addResult, result);\r\n        if (result.type === 3) {\r\n            this.result.push(result);\r\n        }\r\n        else {\r\n            // 添加该作品里每一张图片的数据\r\n            for (let i = 0; i < result.dlCount; i++) {\r\n                const result = this.assignResult(data);\r\n                result.idNum = parseInt(result.id);\r\n                result.id = result.id + `_p${i}`;\r\n                result.original = result.original.replace('p0', 'p' + i);\r\n                result.regular = result.regular.replace('p0', 'p' + i);\r\n                result.small = result.small.replace('p0', 'p' + i);\r\n                this.result.push(result);\r\n            }\r\n        }\r\n    }\r\n    getRankList(index) {\r\n        return this.rankList[index];\r\n    }\r\n    setRankList(id, rank) {\r\n        this.rankList[id] = rank;\r\n    }\r\n    reset() {\r\n        this.resultMeta = [];\r\n        this.resultIDList = [];\r\n        this.result = [];\r\n        this.idList = [];\r\n        this.rankList = {};\r\n        this.tag = API.getTagFromURL();\r\n        this.title = DOM.getTitle();\r\n    }\r\n    bindEvents() {\r\n        window.addEventListener(EVT.list.crawlStart, () => {\r\n            this.reset();\r\n        });\r\n        window.addEventListener(EVT.list.resume, () => {\r\n            this.tag = API.getTagFromURL();\r\n            this.title = DOM.getTitle();\r\n        });\r\n    }\r\n}\r\nconst store = new Store();\r\nexport { store };\r\n","import { EVT } from './EVT';\r\nimport { settings } from './setting/Settings';\r\n// 把需要响应主题变化的元素注册到这个组件里，元素会被添加当前主题的 className\r\n// 默认主题 white 是没有 className 的，其他主题通过对应的 className，在默认主题的基础上更改样式。\r\nclass Theme {\r\n    constructor() {\r\n        this.defaultTheme = 'white'; // 默认主题\r\n        this.theme = ''; // 当前使用的主题\r\n        // 主题标记以及对应的 className\r\n        this.classNameMap = new Map([\r\n            ['white', ''],\r\n            ['dark', 'theme-dark'],\r\n        ]);\r\n        this.selector = '#gtm-var-theme-kind'; // 通过这个选择器查找含有主题标记的元素\r\n        this.timer = 0;\r\n        // 页面上储存的主题标记，与本组件里的主题的对应关系\r\n        this.htmlFlagMap = new Map([\r\n            ['', 'white'],\r\n            ['default', 'white'],\r\n            ['dark', 'dark'],\r\n        ]);\r\n        this.elList = []; // 保存已注册的元素\r\n        this.setTheme();\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        // 初始化时使用定时器查找标记元素\r\n        this.timer = window.setInterval(() => {\r\n            this.findFlag();\r\n        }, 300);\r\n        // 设置变化时设置主题\r\n        window.addEventListener(EVT.list.settingChange, () => {\r\n            this.setTheme();\r\n        });\r\n    }\r\n    // 查找含有 pixiv 主题标记的元素，并监听其变化\r\n    findFlag() {\r\n        const el = document.querySelector(this.selector);\r\n        if (el) {\r\n            window.clearInterval(this.timer);\r\n            this.setTheme();\r\n            // 监听标记元素的 textContent 变化\r\n            const ob = new MutationObserver((mutationsList) => {\r\n                for (const item of mutationsList) {\r\n                    if (item.type === 'characterData') {\r\n                        this.setTheme();\r\n                        break;\r\n                    }\r\n                }\r\n            });\r\n            ob.observe(el, {\r\n                characterData: true,\r\n                subtree: true,\r\n            });\r\n        }\r\n    }\r\n    // 从含有 pixiv 主题标记的元素里获取主题\r\n    getThemeFromHtml() {\r\n        const el = document.querySelector(this.selector);\r\n        if (!el) {\r\n            return this.defaultTheme;\r\n        }\r\n        return this.htmlFlagMap.get(el.textContent);\r\n    }\r\n    // 设置主题。不需要传递值，因为会自动使用设置里的 theme 设置\r\n    setTheme() {\r\n        let result = ''; // 储存最终要使用的主题\r\n        // 根据标记，设置要使用的主题\r\n        switch (settings.theme) {\r\n            case 'white':\r\n                result = 'white';\r\n                break;\r\n            case 'dark':\r\n                result = 'dark';\r\n                break;\r\n            default:\r\n                // 如果传递的值是本模块不能识别的，包括 'auto'，就都自动获取\r\n                result = this.getThemeFromHtml() || this.defaultTheme;\r\n                break;\r\n        }\r\n        // 如果要使用的主题和当前主题不同，则执行变化\r\n        if (result !== this.theme) {\r\n            this.theme = result;\r\n            for (const el of this.elList) {\r\n                this.setClass(el);\r\n            }\r\n        }\r\n    }\r\n    // 把元素注册到本组件里\r\n    register(el) {\r\n        this.elList.push(el);\r\n        this.setClass(el);\r\n    }\r\n    // 给元素设置主题对应的 className\r\n    setClass(el) {\r\n        // 先清除所有主题颜色的 className\r\n        for (const className of this.classNameMap.values()) {\r\n            if (el.classList.contains(className)) {\r\n                el.classList.remove(className);\r\n            }\r\n        }\r\n        // 添加当前主题对应的 className\r\n        const name = this.classNameMap.get(this.theme);\r\n        name && el.classList.add(name);\r\n    }\r\n}\r\nconst theme = new Theme();\r\nexport { theme };\r\n","// 自定义的提示，鼠标放上去可以显示\r\n// 如果要给某个元素添加提示，先给它添加 has_tip 的 className，然后用 data-tip 设置提示内容\r\nclass Tip {\r\n    constructor() {\r\n        this.tipEl = document.createElement('div'); // tip 元素\r\n        this.addTipEl();\r\n        this.bindEvents();\r\n    }\r\n    addTipEl() {\r\n        this.tipEl = document.createElement('div');\r\n        this.tipEl.id = 'tip';\r\n        document.body.insertAdjacentElement('afterbegin', this.tipEl);\r\n    }\r\n    bindEvents() {\r\n        const tips = document.querySelectorAll('.has_tip');\r\n        for (const el of tips) {\r\n            for (const ev of ['mouseenter', 'mouseleave']) {\r\n                el.addEventListener(ev, (event) => {\r\n                    const e = (event || window.event);\r\n                    const text = el.dataset.tip;\r\n                    this.showTip(text, {\r\n                        type: ev === 'mouseenter' ? 1 : 0,\r\n                        x: e.clientX,\r\n                        y: e.clientY,\r\n                    });\r\n                });\r\n            }\r\n        }\r\n    }\r\n    // 显示中间面板上的提示。参数 mouse 指示鼠标是移入还是移出，并包含鼠标坐标\r\n    showTip(text, mouse) {\r\n        if (!text) {\r\n            throw new Error('No tip text.');\r\n        }\r\n        if (mouse.type === 1) {\r\n            this.tipEl.innerHTML = text;\r\n            this.tipEl.style.left = mouse.x + 30 + 'px';\r\n            this.tipEl.style.top = mouse.y - 30 + 'px';\r\n            this.tipEl.style.display = 'block';\r\n        }\r\n        else if (mouse.type === 0) {\r\n            this.tipEl.style.display = 'none';\r\n        }\r\n    }\r\n}\r\nnew Tip();\r\n","// 在标题栏上显示任务状态的标记\r\nimport { pageType } from './PageType';\r\nimport { EVT } from './EVT';\r\n/*\r\n本程序的标记会以 [flag] 形式添加到 title 最前面\r\nflag 及其含义如下：\r\n↑ 抓取中\r\n→ 等待下一步操作（搜索页）\r\n▶ 可以开始下载\r\n↓ 下载中\r\n║ 下载暂停\r\n■ 下载停止\r\n✓ 下载完毕\r\n*/\r\nconst flags = {\r\n    crawling: '↑',\r\n    waiting: '→',\r\n    readyDownload: '▶',\r\n    downloading: '↓',\r\n    paused: '║',\r\n    stopped: '■',\r\n    completed: '✓',\r\n    space: ' ',\r\n};\r\nclass TitleBar {\r\n    constructor() {\r\n        this.timer = 0; // title 闪烁时，使用的定时器\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        window.addEventListener(EVT.list.crawlStart, () => {\r\n            this.set('crawling');\r\n        });\r\n        window.addEventListener(EVT.list.worksUpdate, () => {\r\n            this.set('waiting');\r\n        });\r\n        for (const ev of [\r\n            EVT.list.crawlFinish,\r\n            EVT.list.resultChange,\r\n            EVT.list.resume,\r\n        ]) {\r\n            window.addEventListener(ev, () => {\r\n                this.set('readyDownload');\r\n            });\r\n        }\r\n        window.addEventListener(EVT.list.downloadStart, () => {\r\n            this.set('downloading');\r\n        });\r\n        window.addEventListener(EVT.list.downloadComplete, () => {\r\n            this.set('completed');\r\n        });\r\n        window.addEventListener(EVT.list.downloadPause, () => {\r\n            this.set('paused');\r\n        });\r\n        window.addEventListener(EVT.list.downloadStop, () => {\r\n            this.set('stopped');\r\n        });\r\n        window.addEventListener(EVT.list.crawlEmpty, () => {\r\n            this.reset();\r\n        });\r\n    }\r\n    // 检查标题里是否含有标记\r\n    includeFlag(flag = '') {\r\n        if (!flag) {\r\n            // 没有传递标记，则检查所有标记\r\n            for (const flga of Object.values(flags)) {\r\n                const str = `[${flga}]`;\r\n                if (document.title.includes(str)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // 检查指定标记\r\n            const str = `[${flag}]`;\r\n            return document.title.includes(str);\r\n        }\r\n        return false;\r\n    }\r\n    // 重设 title\r\n    reset() {\r\n        clearInterval(this.timer);\r\n        if (pageType.type == 1 || pageType.type === 2 || pageType.type === 13) {\r\n            // 从 og:title 标签获取标题。og:title 标签是最早更新标题的。但不确定是否在所有页面上都可以直接使用 og:title 标签的内容，所以这里只在部分页面上使用\r\n            const ogTitle = document.querySelector('meta[property=\"og:title\"]');\r\n            if (ogTitle) {\r\n                document.title = ogTitle.content;\r\n                return;\r\n            }\r\n        }\r\n        // 去掉 title 里的标记\r\n        const index = document.title.indexOf(']');\r\n        document.title = document.title.substr(index + 1, document.title.length);\r\n    }\r\n    // 在标题上显示指定标记\r\n    set(flagName) {\r\n        const flag = flags[flagName];\r\n        const text = `[${flag}]`;\r\n        // 如果 title 里没有标记，就添加标记\r\n        if (!this.includeFlag()) {\r\n            document.title = `${text} ${document.title}`;\r\n        }\r\n        else {\r\n            // 如果已经有标记了，则替换为新当前传入的标记\r\n            document.title = document.title.replace(/\\[.?\\]/, text);\r\n        }\r\n        // 可以开始下载，或者等待下一步操作，进行闪烁提醒\r\n        if (flagName === 'readyDownload' || flagName === 'waiting') {\r\n            this.flashing(flag);\r\n        }\r\n        else {\r\n            clearInterval(this.timer);\r\n        }\r\n    }\r\n    // 闪烁提醒，其实是把给定的标记替换成空白，来回切换\r\n    flashing(flag) {\r\n        clearInterval(this.timer);\r\n        const text = `[${flag}]`;\r\n        const whiteSpace = `[${flags.space}]`;\r\n        this.timer = window.setInterval(() => {\r\n            if (this.includeFlag(flag)) {\r\n                // 如果含有标记，就替换成空白\r\n                document.title = document.title.replace(text, whiteSpace);\r\n            }\r\n            else {\r\n                if (this.includeFlag(flags.space)) {\r\n                    // 如果含有空白，就替换成标记\r\n                    document.title = document.title.replace(whiteSpace, text);\r\n                }\r\n                else {\r\n                    // 如果都没有，一般是页面切换了，标题被重置了，取消闪烁\r\n                    clearInterval(this.timer);\r\n                }\r\n            }\r\n        }, 500);\r\n    }\r\n}\r\nnew TitleBar();\r\n","import { EVT } from './EVT';\r\n// 获取和保存 token\r\nclass Token {\r\n    constructor() {\r\n        this.tokenStore = 'xzToken';\r\n        this.timeStore = 'xzTokenTime';\r\n        this.updateURL = 'https://www.pixiv.net/artworks/62751951';\r\n        this.token = this.getToken();\r\n        this.updateToken();\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        // 重置设置时清除保存的 token，因为用户切换账号时，登录上新账号后可能 token 还是之前账号的，就会出错。清除设置时清除 token，就可以解决这个问题。\r\n        window.addEventListener(EVT.list.resetSettings, () => {\r\n            this.reset();\r\n        });\r\n    }\r\n    getToken() {\r\n        const token = localStorage.getItem(this.tokenStore);\r\n        return token ? token : '';\r\n    }\r\n    updateToken() {\r\n        const interval = 300000; // 两次更新之间的最小时间间隔。目前设置为 5 分钟\r\n        const nowTime = new Date().getTime();\r\n        const lastTimeStr = localStorage.getItem(this.timeStore);\r\n        if (this.token &&\r\n            lastTimeStr &&\r\n            nowTime - Number.parseInt(lastTimeStr) < interval) {\r\n            return;\r\n        }\r\n        // 从网页源码里获取用户 token 并储存\r\n        fetch(this.updateURL)\r\n            .then((response) => {\r\n            return response.text();\r\n        })\r\n            .then((data) => {\r\n            const result = data.match(/token\":\"(\\w+)\"/);\r\n            if (result) {\r\n                this.token = result[1];\r\n                localStorage.setItem(this.tokenStore, this.token);\r\n                localStorage.setItem(this.timeStore, new Date().getTime().toString());\r\n            }\r\n            else {\r\n                console.error('UpdateToken failed: no token found!');\r\n            }\r\n        });\r\n    }\r\n    reset() {\r\n        this.token = '';\r\n        localStorage.removeItem(this.tokenStore);\r\n        localStorage.removeItem(this.timeStore);\r\n        this.updateToken();\r\n    }\r\n}\r\nconst token = new Token();\r\nexport { token };\r\n","// 初始化地区排行榜页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { DOM } from '../DOM';\r\nimport { options } from '../setting/Options';\r\nimport { filter } from '../Filter';\r\nimport { API } from '../API';\r\nimport { store } from '../Store';\r\nclass InitAreaRankingPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.init();\r\n    }\r\n    addCrawlBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_抓取本页作品'), [\r\n            ['title', lang.transl('_抓取本页作品Title')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    setFormOption() {\r\n        options.hideOption([1]);\r\n    }\r\n    async getIdList() {\r\n        const allPicArea = document.querySelectorAll('.ranking-item>.work_wrapper');\r\n        for (const el of allPicArea) {\r\n            const img = el.querySelector('._thumbnail');\r\n            // img.dataset.type 全都是 \"illust\"，因此不能用来区分作品类型\r\n            // 提取出 tag 列表\r\n            const id = img.dataset.id;\r\n            const tags = img.dataset.tags.split(' ');\r\n            // 有的作品没有收藏按钮，点进去之后发现这个作品已经被删除了，只是排行榜里没有及时更新。这样的作品没有收藏按钮。\r\n            const bookmarkBtn = el.querySelector('._one-click-bookmark');\r\n            const bookmarked = bookmarkBtn\r\n                ? bookmarkBtn.classList.contains('on')\r\n                : false;\r\n            const filterOpt = {\r\n                id: id,\r\n                tags: tags,\r\n                bookmarkData: bookmarked,\r\n            };\r\n            if (await filter.check(filterOpt)) {\r\n                const id = API.getIllustId(el.querySelector('a').href);\r\n                store.idList.push({\r\n                    type: 'unknown',\r\n                    id,\r\n                });\r\n            }\r\n        }\r\n        this.getIdListFinished();\r\n    }\r\n    resetGetIdListStatus() { }\r\n}\r\nexport { InitAreaRankingPage };\r\n","//初始化 artwork 作品页\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { EVT } from '../EVT';\r\nimport { lang } from '../Lang';\r\nimport { options } from '../setting/Options';\r\nimport { store } from '../Store';\r\nimport { QuickBookmark } from '../QuickBookmark';\r\nimport { ImgViewer } from '../ImgViewer';\r\nimport { DOM } from '../DOM';\r\nimport { API } from '../API';\r\nimport { log } from '../Log';\r\nimport { QuickDownloadBtn } from '../QuickDownloadBtn';\r\nimport { states } from '../States';\r\nimport '../SaveAvatarIcon';\r\nclass InitArtworkPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.crawlDirection = 0; // 抓取方向，指示抓取新作品还是旧作品\r\n        /*\r\n        -1 抓取新作品\r\n        0 不设置抓取方向\r\n        1 抓取旧作品\r\n        */\r\n        this.crawlRelated = false; // 是否下载相关作品\r\n        this.startQuickDownload = () => {\r\n            this.readyCrawl();\r\n        };\r\n        this.init();\r\n    }\r\n    initAny() {\r\n        // 初始化快速收藏功能和图片查看器\r\n        this.initQuickBookmark();\r\n        this.initImgViewer();\r\n        // 页面切换再次初始化\r\n        window.addEventListener(EVT.list.pageSwitchedTypeNotChange, this.initQuickBookmark);\r\n        window.addEventListener(EVT.list.pageSwitchedTypeNotChange, this.initImgViewer);\r\n        // 初始化快速下载按钮\r\n        new QuickDownloadBtn();\r\n        window.addEventListener(EVT.list.QuickDownload, this.startQuickDownload);\r\n    }\r\n    initImgViewer() {\r\n        new ImgViewer();\r\n    }\r\n    initQuickBookmark() {\r\n        new QuickBookmark();\r\n    }\r\n    addCrawlBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_从本页开始抓取new')).addEventListener('click', () => {\r\n            this.crawlDirection = -1;\r\n            this.readyCrawl();\r\n        });\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_从本页开始抓取old')).addEventListener('click', () => {\r\n            this.crawlDirection = 1;\r\n            this.readyCrawl();\r\n        });\r\n        const downRelatedBtn = DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_抓取相关作品'));\r\n        downRelatedBtn.addEventListener('click', () => {\r\n            this.crawlRelated = true;\r\n            this.readyCrawl();\r\n        }, false);\r\n    }\r\n    addAnyElement() {\r\n        DOM.addBtn('otherBtns', Colors.green, lang.transl('_保存用户头像为图标'), [\r\n            ['title', lang.transl('_保存用户头像为图标说明')],\r\n        ]).addEventListener('click', () => {\r\n            EVT.fire(EVT.list.saveAvatarIcon);\r\n        });\r\n    }\r\n    setFormOption() {\r\n        // 个数/页数选项的提示\r\n        options.setWantPageTip({\r\n            text: lang.transl('_个数'),\r\n            tip: lang.transl('_从本页开始下载提示') +\r\n                '<br>' +\r\n                lang.transl('_相关作品大于0'),\r\n            rangTip: lang.transl('_数字提示1'),\r\n        });\r\n    }\r\n    destroy() {\r\n        DOM.clearSlot('crawlBtns');\r\n        DOM.clearSlot('otherBtns');\r\n        // 解除切换页面时绑定的事件\r\n        window.removeEventListener(EVT.list.pageSwitchedTypeNotChange, this.initQuickBookmark);\r\n        window.removeEventListener(EVT.list.pageSwitchedTypeNotChange, this.initImgViewer);\r\n        window.removeEventListener(EVT.list.QuickDownload, this.startQuickDownload);\r\n    }\r\n    getWantPage() {\r\n        if (states.quickDownload) {\r\n            // 快速下载\r\n            this.crawlNumber = 1;\r\n        }\r\n        else {\r\n            // 检查下载页数的设置\r\n            if (!this.crawlRelated) {\r\n                const crawlAllTip = this.crawlDirection === -1\r\n                    ? lang.transl('_从本页开始抓取new')\r\n                    : lang.transl('_从本页开始抓取old');\r\n                this.crawlNumber = this.checkWantPageInput(lang.transl('_从本页开始下载x个'), crawlAllTip);\r\n            }\r\n            else {\r\n                // 相关作品的提示\r\n                this.crawlNumber = this.checkWantPageInput(lang.transl('_下载x个相关作品'), lang.transl('_下载所有相关作品'));\r\n            }\r\n        }\r\n    }\r\n    nextStep() {\r\n        // 下载相关作品\r\n        if (this.crawlRelated) {\r\n            this.getRelatedList();\r\n        }\r\n        else if (states.quickDownload) {\r\n            // 快速下载\r\n            store.idList.push({\r\n                type: 'unknown',\r\n                id: API.getIllustId(window.location.href),\r\n            });\r\n            log.log(lang.transl('_开始获取作品页面'));\r\n            this.getIdListFinished();\r\n        }\r\n        else {\r\n            // 向前向后下载\r\n            this.getIdList();\r\n        }\r\n    }\r\n    async getIdList() {\r\n        let type = ['illusts', 'manga'];\r\n        let idList = await API.getUserWorksByType(DOM.getUserId(), type);\r\n        // 储存符合条件的 id\r\n        let nowId = parseInt(API.getIllustId(window.location.href));\r\n        idList.forEach((id) => {\r\n            let idNum = parseInt(id.id);\r\n            // 新作品\r\n            if (idNum >= nowId && this.crawlDirection === -1) {\r\n                store.idList.push(id);\r\n            }\r\n            else if (idNum <= nowId && this.crawlDirection === 1) {\r\n                // 旧作品\r\n                store.idList.push(id);\r\n            }\r\n        });\r\n        // 当设置了下载个数时，进行裁剪\r\n        if (this.crawlNumber !== -1) {\r\n            // 新作品 升序排列\r\n            if (this.crawlDirection === -1) {\r\n                store.idList.sort(API.sortByProperty('id')).reverse();\r\n            }\r\n            else {\r\n                // 旧作品 降序排列\r\n                store.idList.sort(API.sortByProperty('id'));\r\n            }\r\n            store.idList = store.idList.splice(0, this.crawlNumber);\r\n        }\r\n        this.getIdListFinished();\r\n    }\r\n    // 下载相关作品时使用\r\n    async getRelatedList() {\r\n        let data = await API.getRelatedData(API.getIllustId());\r\n        // 相关作品的列表由两部分构成，所以要组合起来\r\n        let ids = [];\r\n        for (const illust of data.body.illusts) {\r\n            ids.push(illust.id);\r\n        }\r\n        ids = ids.concat(data.body.nextIds);\r\n        // 当设置了下载个数时，进行裁剪\r\n        if (this.crawlNumber !== -1) {\r\n            ids = ids.slice(0, this.crawlNumber);\r\n        }\r\n        for (const id of ids) {\r\n            store.idList.push({\r\n                type: 'unknown',\r\n                id,\r\n            });\r\n        }\r\n        log.log(lang.transl('_相关作品抓取完毕', store.idList.length.toString()));\r\n        this.getIdListFinished();\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.crawlDirection = 0; // 解除下载方向的标记\r\n        this.crawlRelated = false; // 解除下载相关作品的标记\r\n    }\r\n}\r\nexport { InitArtworkPage };\r\n","// 初始化 bookmark_detail 页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { DOM } from '../DOM';\r\nimport { options } from '../setting/Options';\r\nimport { API } from '../API';\r\nimport { store } from '../Store';\r\nclass InitBookmarkDetailPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.init();\r\n    }\r\n    addCrawlBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_抓取相似图片'), [\r\n            ['title', lang.transl('_抓取相似图片')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        }, false);\r\n    }\r\n    setFormOption() {\r\n        // 个数/页数选项的提示\r\n        options.setWantPageTip({\r\n            text: lang.transl('_个数'),\r\n            tip: lang.transl('_想要获取多少个作品'),\r\n            rangTip: `1 - ${this.maxCount}`,\r\n        });\r\n    }\r\n    getWantPage() {\r\n        this.crawlNumber = this.checkWantPageInputGreater0(this.maxCount, false);\r\n    }\r\n    // 获取相似的作品列表\r\n    async getIdList() {\r\n        let data = await API.getRecommenderData(API.getIllustId(), this.crawlNumber);\r\n        for (const id of data.recommendations) {\r\n            store.idList.push({\r\n                type: 'unknown',\r\n                id: id.toString(),\r\n            });\r\n        }\r\n        this.getIdListFinished();\r\n    }\r\n    resetGetIdListStatus() { }\r\n}\r\nexport { InitBookmarkDetailPage };\r\n","// 初始化 关注的新作品 artwork 页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { DOM } from '../DOM';\r\nimport { options } from '../setting/Options';\r\nimport { filter } from '../Filter';\r\nimport { API } from '../API';\r\nimport { store } from '../Store';\r\nimport { log } from '../Log';\r\nclass InitBookmarkNewArtworkPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.r18 = false;\r\n        this.init();\r\n    }\r\n    addCrawlBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_开始抓取') + lang.transl('_默认下载多页')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    setFormOption() {\r\n        // 个数/页数选项的提示\r\n        this.maxCount = 100;\r\n        options.setWantPageTip({\r\n            text: lang.transl('_页数'),\r\n            tip: lang.transl('_从本页开始下载提示'),\r\n            rangTip: `1 - ${this.maxCount}`,\r\n        });\r\n    }\r\n    getWantPage() {\r\n        this.crawlNumber = this.checkWantPageInputGreater0(this.maxCount, true);\r\n    }\r\n    nextStep() {\r\n        this.r18 = location.pathname.includes('r18');\r\n        const p = API.getURLSearchField(location.href, 'p');\r\n        this.startpageNo = parseInt(p) || 1;\r\n        this.getIdList();\r\n    }\r\n    async getIdList() {\r\n        let p = this.startpageNo + this.listPageFinished;\r\n        // 发起请求，获取列表页\r\n        let worksData;\r\n        try {\r\n            worksData = await API.getBookmarkNewIllustData(p, this.r18);\r\n        }\r\n        catch (error) {\r\n            this.getIdList();\r\n            return;\r\n        }\r\n        // 检查一些此时可以进行检查的设置项\r\n        for (const data of worksData) {\r\n            const filterOpt = {\r\n                id: data.illustId,\r\n                width: data.width,\r\n                height: data.height,\r\n                pageCount: data.pageCount,\r\n                bookmarkData: data.isBookmarked,\r\n                illustType: parseInt(data.illustType),\r\n                tags: data.tags,\r\n                userid: data.userId,\r\n            };\r\n            if (await filter.check(filterOpt)) {\r\n                store.idList.push({\r\n                    type: API.getWorkType(data.illustType),\r\n                    id: data.illustId,\r\n                });\r\n            }\r\n        }\r\n        this.listPageFinished++;\r\n        log.log(lang.transl('_列表页抓取进度', this.listPageFinished.toString()), 1, false);\r\n        // 判断任务状态\r\n        // 如果抓取了所有页面，或者抓取完指定页面\r\n        if (p >= this.maxCount || this.listPageFinished === this.crawlNumber) {\r\n            log.log(lang.transl('_列表页抓取完成'));\r\n            this.getIdListFinished();\r\n        }\r\n        else {\r\n            // 继续抓取\r\n            this.getIdList();\r\n        }\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.listPageFinished = 0;\r\n    }\r\n}\r\nexport { InitBookmarkNewArtworkPage };\r\n","// 初始化发现页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { DOM } from '../DOM';\r\nimport { options } from '../setting/Options';\r\nimport { DeleteWorks } from '../DeleteWorks';\r\nimport { API } from '../API';\r\nimport { store } from '../Store';\r\nclass InitDiscoverPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.init();\r\n    }\r\n    addCrawlBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_抓取当前作品'), [\r\n            ['title', lang.transl('_抓取当前作品Title')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    setFormOption() {\r\n        options.hideOption([1]);\r\n    }\r\n    addAnyElement() {\r\n        const deleteWorks = new DeleteWorks('._2RNjBox');\r\n        deleteWorks.addClearMultipleBtn('._3b8AXEx');\r\n        deleteWorks.addClearUgoiraBtn('.AGgsUWZ');\r\n        deleteWorks.addManuallyDeleteBtn();\r\n    }\r\n    getWantPage() { }\r\n    getIdList() {\r\n        // 在发现页面，仅下载已有部分，所以不需要去获取列表页\r\n        const nowIllust = document.querySelectorAll('figure>div>a');\r\n        // 获取已有作品的 id\r\n        Array.from(nowIllust).forEach((el) => {\r\n            // discovery 列表的 url 是有额外后缀的，需要去掉\r\n            const id = API.getIllustId(el.href.split('&uarea')[0]);\r\n            store.idList.push({\r\n                type: 'unknown',\r\n                id,\r\n            });\r\n        });\r\n        this.getIdListFinished();\r\n    }\r\n    resetGetIdListStatus() { }\r\n}\r\nexport { InitDiscoverPage };\r\n","// 初始化 大家的新作品 artwork 页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { options } from '../setting/Options';\r\nimport { filter } from '../Filter';\r\nimport { API } from '../API';\r\nimport { store } from '../Store';\r\nimport { log } from '../Log';\r\nimport { DOM } from '../DOM';\r\nclass InitNewArtworkPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.option = this.resetOption();\r\n        this.limitMax = 20; // 每次请求的数量最大是 20\r\n        this.fetchCount = 0; // 已请求的作品数量\r\n        this.init();\r\n    }\r\n    addCrawlBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_下载大家的新作品')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    setFormOption() {\r\n        // 个数/页数选项的提示\r\n        options.setWantPageTip({\r\n            text: lang.transl('_个数'),\r\n            tip: lang.transl('_想要获取多少个作品'),\r\n            rangTip: `1 - ${this.maxCount}`,\r\n        });\r\n    }\r\n    getWantPage() {\r\n        this.crawlNumber = this.checkWantPageInputGreater0(this.maxCount, false);\r\n    }\r\n    nextStep() {\r\n        this.initFetchURL();\r\n        this.getIdList();\r\n    }\r\n    resetOption() {\r\n        return {\r\n            lastId: '0',\r\n            limit: '20',\r\n            type: '',\r\n            r18: '',\r\n        };\r\n    }\r\n    // 组织要请求的 url\r\n    initFetchURL() {\r\n        this.option = this.resetOption();\r\n        if (this.crawlNumber < this.limitMax) {\r\n            this.option.limit = this.crawlNumber.toString();\r\n        }\r\n        else {\r\n            this.option.limit = this.limitMax.toString();\r\n        }\r\n        // 当前页面的作品类型，默认是 illust\r\n        this.option.type = API.getURLSearchField(location.href, 'type') || 'illust';\r\n        // 是否是 R18 模式\r\n        this.option.r18 = (location.href.includes('_r18.php') || false).toString();\r\n    }\r\n    async getIdList() {\r\n        let data;\r\n        try {\r\n            data = await API.getNewIllustData(this.option);\r\n        }\r\n        catch (error) {\r\n            this.getIdList();\r\n            return;\r\n        }\r\n        let useData = data.body.illusts;\r\n        for (const nowData of useData) {\r\n            // 抓取够了指定的数量\r\n            if (this.fetchCount + 1 > this.crawlNumber) {\r\n                break;\r\n            }\r\n            else {\r\n                this.fetchCount++;\r\n            }\r\n            // 排除广告信息\r\n            if (nowData.isAdContainer) {\r\n                continue;\r\n            }\r\n            const filterOpt = {\r\n                id: nowData.id,\r\n                width: nowData.width,\r\n                height: nowData.height,\r\n                pageCount: nowData.pageCount,\r\n                bookmarkData: nowData.bookmarkData,\r\n                illustType: nowData.illustType,\r\n                tags: nowData.tags,\r\n                userid: nowData.userId,\r\n            };\r\n            if (await filter.check(filterOpt)) {\r\n                store.idList.push({\r\n                    type: API.getWorkType(nowData.illustType),\r\n                    id: nowData.id,\r\n                });\r\n            }\r\n        }\r\n        log.log(lang.transl('_新作品进度', this.fetchCount.toString()), 1, false);\r\n        // 抓取完毕\r\n        if (this.fetchCount >= this.crawlNumber ||\r\n            this.fetchCount >= this.maxCount) {\r\n            log.log(lang.transl('_开始获取作品页面'));\r\n            this.getIdListFinished();\r\n            return;\r\n        }\r\n        // 继续抓取\r\n        this.option.lastId = data.body.lastId;\r\n        this.getIdList();\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.fetchCount = 0;\r\n    }\r\n}\r\nexport { InitNewArtworkPage };\r\n","// 初始化 artwork 排行榜页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { API } from '../API';\r\nimport { lang } from '../Lang';\r\nimport { DOM } from '../DOM';\r\nimport { EVT } from '../EVT';\r\nimport { options } from '../setting/Options';\r\nimport { filter } from '../Filter';\r\nimport { store } from '../Store';\r\nimport { log } from '../Log';\r\nimport { states } from '../States';\r\nclass InitRankingArtworkPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.pageCount = 10; // 排行榜的页数\r\n        this.option = this.resetOption();\r\n        this.init();\r\n    }\r\n    addCrawlBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_抓取本排行榜作品'), [\r\n            ['title', lang.transl('_抓取本排行榜作品Title')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n        // 判断当前页面是否有“首次登场”标记\r\n        const debutModes = ['daily', 'daily_r18', 'rookie', ''];\r\n        const mode = API.getURLSearchField(location.href, 'mode');\r\n        if (debutModes.includes(mode)) {\r\n            DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_抓取首次登场的作品'), [\r\n                ['title', lang.transl('_抓取首次登场的作品Title')],\r\n            ]).addEventListener('click', () => {\r\n                states.debut = true;\r\n                this.readyCrawl();\r\n            });\r\n        }\r\n    }\r\n    initAny() {\r\n        // 抓取完成后，复位 debut 标记\r\n        // 因为 debut 只在抓取阶段被过滤器使用，所以抓取完成后就可以复位\r\n        window.addEventListener(EVT.list.crawlFinish, () => {\r\n            states.debut = false;\r\n        });\r\n    }\r\n    setFormOption() {\r\n        // 个数/页数选项的提示\r\n        this.maxCount = 500;\r\n        options.setWantPageTip({\r\n            text: lang.transl('_个数'),\r\n            tip: lang.transl('_想要获取多少个作品'),\r\n            rangTip: `1 - ${this.maxCount}`,\r\n        });\r\n    }\r\n    resetOption() {\r\n        return { mode: 'daily', p: 1, worksType: '', date: '' };\r\n    }\r\n    setPartNum() {\r\n        // 设置页数。排行榜页面一页有50张作品，当页面到达底部时会加载下一页\r\n        if (location.pathname.includes('r18g')) {\r\n            // r18g 只有1个榜单，固定1页\r\n            this.pageCount = 1;\r\n        }\r\n        else if (location.pathname.includes('_r18')) {\r\n            // r18 模式，这里的6是最大值，有的排行榜并没有6页\r\n            this.pageCount = 6;\r\n        }\r\n        else {\r\n            // 普通模式，这里的10也是最大值。如果实际没有10页，则在检测到404页面的时候停止抓取下一页\r\n            this.pageCount = 10;\r\n        }\r\n    }\r\n    getWantPage() {\r\n        this.listPageFinished = 0;\r\n        // 检查下载页数的设置\r\n        this.crawlNumber = this.checkWantPageInput(lang.transl('_下载排行榜前x个作品'), lang.transl('_向下获取所有作品'));\r\n        // 如果设置的作品个数是 -1，则设置为下载所有作品\r\n        if (this.crawlNumber === -1) {\r\n            this.crawlNumber = 500;\r\n        }\r\n    }\r\n    nextStep() {\r\n        // 设置 option 信息\r\n        // mode 一定要有值，其他字段不需要一定有值\r\n        this.option = this.resetOption();\r\n        this.option.mode = API.getURLSearchField(location.href, 'mode') || 'daily';\r\n        this.option.worksType = API.getURLSearchField(location.href, 'content');\r\n        this.option.date = API.getURLSearchField(location.href, 'date');\r\n        this.startpageNo = 1;\r\n        this.setPartNum();\r\n        this.getIdList();\r\n    }\r\n    async getIdList() {\r\n        this.option.p = this.startpageNo + this.listPageFinished;\r\n        // 发起请求，获取作品列表\r\n        let data;\r\n        try {\r\n            data = await API.getRankingData(this.option);\r\n        }\r\n        catch (error) {\r\n            if (error.status === 404) {\r\n                // 如果发生了404错误，则中断抓取，直接下载已有部分。因为可能确实没有下一部分了\r\n                console.log('404错误，直接下载已有部分');\r\n                this.getIdListFinished();\r\n            }\r\n            return;\r\n        }\r\n        this.listPageFinished++;\r\n        const contents = data.contents; // 取出作品信息列表\r\n        for (const data of contents) {\r\n            // 检查是否已经抓取到了指定数量的作品\r\n            if (data.rank > this.crawlNumber) {\r\n                return this.getIdListFinished();\r\n            }\r\n            // 目前，数据里并没有包含收藏数量，所以在这里没办法检查收藏数量要求\r\n            const filterOpt = {\r\n                id: data.illust_id,\r\n                illustType: parseInt(data.illust_type),\r\n                tags: data.tags,\r\n                pageCount: parseInt(data.illust_page_count),\r\n                bookmarkData: data.is_bookmarked,\r\n                width: data.width,\r\n                height: data.height,\r\n                yes_rank: data.yes_rank,\r\n                userid: data.user_id.toString(),\r\n            };\r\n            if (await filter.check(filterOpt)) {\r\n                store.setRankList(data.illust_id.toString(), data.rank.toString());\r\n                store.idList.push({\r\n                    type: API.getWorkType(data.illust_type),\r\n                    id: data.illust_id.toString(),\r\n                });\r\n            }\r\n        }\r\n        log.log(lang.transl('_排行榜进度', this.listPageFinished.toString()), 1, false);\r\n        // 抓取完毕\r\n        if (this.listPageFinished === this.pageCount) {\r\n            this.getIdListFinished();\r\n        }\r\n        else {\r\n            // 继续抓取\r\n            this.getIdList();\r\n        }\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.listPageFinished = 0;\r\n    }\r\n}\r\nexport { InitRankingArtworkPage };\r\n","// 初始化 artwork 搜索页\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { token } from '../Token';\r\nimport { options } from '../setting/Options';\r\nimport { DeleteWorks } from '../DeleteWorks';\r\nimport { EVT } from '../EVT';\r\nimport { filter } from '../Filter';\r\nimport { API } from '../API';\r\nimport { store } from '../Store';\r\nimport { log } from '../Log';\r\nimport { settings } from '../setting/Settings';\r\nimport { settingAPI } from '../setting/SettingAPI';\r\nimport { FastScreen } from '../FastScreen';\r\nimport { DOM } from '../DOM';\r\nimport { BookmarkAllWorks } from '../BookmarkAllWorks';\r\nimport { states } from '../States';\r\nclass InitSearchArtworkPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.worksWrapSelector = '#root section ul';\r\n        this.listClass = 'searchList';\r\n        this.multipleClass = 'multiplePart';\r\n        this.ugoiraClass = 'ugoiraPart';\r\n        this.addBMKBtnClass = 'bmkBtn';\r\n        this.bookmarkedClass = 'bookmarked';\r\n        this.countSelector = 'section h3+div span';\r\n        this.hotWorkAsideSelector = 'section aside';\r\n        this.worksType = '';\r\n        this.option = {};\r\n        this.worksNoPerPage = 60; // 每个页面有多少个作品\r\n        this.needCrawlPageCount = 0; // 需要抓取多少个列表页面\r\n        this.sendCrawlTaskCount = 0; // 发送抓取请求之前会自增，用于计算要抓取的页码。不是请求完成后自增\r\n        this.allOption = [\r\n            'order',\r\n            'type',\r\n            'wlt',\r\n            'wgt',\r\n            'hlt',\r\n            'hgt',\r\n            'ratio',\r\n            'tool',\r\n            's_mode',\r\n            'mode',\r\n            'scd',\r\n            'ecd',\r\n            'blt',\r\n            'bgt',\r\n        ];\r\n        this.resultMeta = []; // 每次“开始筛选”完成后，储存当时所有结果，以备“在结果中筛选”使用\r\n        this.worksWrap = null;\r\n        this.deleteId = 0; // 手动删除时，要删除的作品的 id\r\n        this.previewResult = true; // 是否预览结果\r\n        this.causeResultChange = ['firstFewImagesSwitch', 'firstFewImages']; // 这些选项变更时，可能会导致结果改变。但是过滤器 filter 不会检查，所以需要单独检测它的变更，手动处理\r\n        this.onSettingChange = (event) => {\r\n            const data = event.detail.data;\r\n            if (data.name === 'previewResult') {\r\n                this.setPreviewResult(data.value);\r\n            }\r\n            if (this.causeResultChange.includes(data.name)) {\r\n                if (store.result.length > 0) {\r\n                    this.reAddResult();\r\n                    EVT.fire(EVT.list.resultChange);\r\n                }\r\n            }\r\n        };\r\n        // 抓取完成后，保存结果的元数据，并重排结果\r\n        this.onCrawlFinish = () => {\r\n            this.resultMeta = [...store.resultMeta];\r\n            // 显示作品数量\r\n            const count = this.resultMeta.length || store.resultMeta.length;\r\n            if (count > 0) {\r\n                log.log(lang.transl('_当前作品个数', count.toString()));\r\n            }\r\n            // 显示文件数量\r\n            log.success(lang.transl('_共抓取到n个文件', store.result.length.toString()));\r\n            this.clearWorks();\r\n            this.reAddResult();\r\n            // 解绑创建作品元素的事件\r\n            window.removeEventListener(EVT.list.addResult, this.createWork);\r\n            setTimeout(() => {\r\n                EVT.fire(EVT.list.worksUpdate);\r\n            }, 0);\r\n        };\r\n        // 显示抓取到的作品数量\r\n        this.showCount = () => {\r\n            const count = this.resultMeta.length || store.resultMeta.length;\r\n            if (count > 0) {\r\n                const countEl = document.querySelector(this.countSelector);\r\n                if (countEl) {\r\n                    countEl.textContent = count.toString();\r\n                }\r\n            }\r\n        };\r\n        // 在页面上生成抓取结果对应的作品元素\r\n        this.createWork = (event) => {\r\n            if (!this.previewResult || !this.worksWrap) {\r\n                return;\r\n            }\r\n            const data = event.detail.data;\r\n            let r18Text = '';\r\n            if (data.tags.includes('R-18')) {\r\n                r18Text = 'R-18';\r\n            }\r\n            if (data.tags.includes('R-18G')) {\r\n                r18Text = 'R-18G';\r\n            }\r\n            let r18HTML = r18Text\r\n                ? `\n      <div class=\"r18Part\">\n        <div class=\"child\">\n          <div class=\"text\">${r18Text}</div>\n        </div>\n      </div>`\r\n                : '';\r\n            let multipleHTML = '';\r\n            if (data.pageCount > 1) {\r\n                multipleHTML = `\n        <div class=\"${this.multipleClass}\">\n          <div class=\"child\">\n            <span class=\"span1\">\n              <span class=\"span2\">\n              <svg viewBox=\"0 0 9 10\" size=\"9\" class=\"multipleSvg\">\n                <path d=\"M8,3 C8.55228475,3 9,3.44771525 9,4 L9,9 C9,9.55228475 8.55228475,10 8,10 L3,10\n                C2.44771525,10 2,9.55228475 2,9 L6,9 C7.1045695,9 8,8.1045695 8,7 L8,3 Z M1,1 L6,1\n                C6.55228475,1 7,1.44771525 7,2 L7,7 C7,7.55228475 6.55228475,8 6,8 L1,8 C0.44771525,8\n                0,7.55228475 0,7 L0,2 C0,1.44771525 0.44771525,1 1,1 Z\" transform=\"\"></path>\n                </svg>\n              </span>\n            </span>\n            <span>${data.pageCount}</span>\n          </div>  \n        </div>\n                    `;\r\n            }\r\n            let ugoiraHTML = '';\r\n            if (data.ugoiraInfo) {\r\n                ugoiraHTML = `\n        <svg viewBox=\"0 0 24 24\" class=\"${this.ugoiraClass}\" style=\"width: 48px; height: 48px;\">\n        <circle cx=\"12\" cy=\"12\" r=\"10\" class=\"ugoiraCircle\"></circle>\n          <path d=\"M9,8.74841664 L9,15.2515834 C9,15.8038681 9.44771525,16.2515834 10,16.2515834\n              C10.1782928,16.2515834 10.3533435,16.2039156 10.5070201,16.1135176 L16.0347118,12.8619342\n              C16.510745,12.5819147 16.6696454,11.969013 16.3896259,11.4929799\n              C16.3034179,11.3464262 16.1812655,11.2242738 16.0347118,11.1380658 L10.5070201,7.88648243\n              C10.030987,7.60646294 9.41808527,7.76536339 9.13806578,8.24139652\n              C9.04766776,8.39507316 9,8.57012386 9,8.74841664 Z\"></path>\n        </svg>`;\r\n            }\r\n            // 添加收藏的作品，让收藏图标变红\r\n            const bookmarkedFlag = data.bookmarked ? this.bookmarkedClass : '';\r\n            const html = `\n    <li class=\"${this.listClass}\" data-id=\"${data.idNum}\">\n    <div class=\"searchContent\">\n      <div class=\"searchImgArea\">\n        <div width=\"184\" height=\"184\" class=\"searchImgAreaContent\">\n          <a target=\"_blank\" class=\"imgAreaLink\" href=\"/artworks/${data.idNum}\">\n            <!--顶部横幅-->\n            <div class=\"topbar\">\n\n            <!--R-18 标记-->\n            ${r18HTML}\n\n            <!--多图作品标记-->\n            ${multipleHTML}\n              \n            </div>\n            <!--图片部分-->\n            <div class=\"imgWrap\">\n            <img src=\"${data.thumb}\" alt=\"${data.title}\" style=\"object-fit: cover; object-position: center center;\">\n              <!-- 动图 svg -->\n              ${ugoiraHTML}\n              </div>\n          </a>\n          <!--添加显示收藏数-->\n          <div class=\"bmkCount\">${data.bmk}</div>\n          <!--收藏按钮-->\n          <div class=\"bmkBtnWrap\">\n            <div class=\"\">\n            <button type=\"button\" class=\"${this.addBMKBtnClass}\">\n            <svg viewBox=\"0 0 1024 1024\" width=\"32\" height=\"32\" class=\"bmkBtnSvg ${bookmarkedFlag}\">\n            <path d=\"M958.733019 411.348626 659.258367 353.59527 511.998465 85.535095 364.741633 353.59527 65.265958 411.348626 273.72878 634.744555 235.88794 938.463881 511.998465 808.479435 788.091594 938.463881 750.250754 634.744555Z\" p-id=\"1106\" class=\"path2\"></path>\n            <path d=\"M959.008 406.016l-308-47.008L512 64 372.992 359.008l-308 47.008 223.008 228-52.992 324L512 805.024l276.992 152.992-52.992-324zM512 740L304 856.992l40-235.008-179.008-182.016 242.016-32 104.992-224 104 224 240.992 34.016L680 622.976l36.992 235.008z\" p-id=\"919\"></path>\n            </svg>\n            </button>\n            </div>\n          </div>\n        <!--收藏按钮结束-->\n        </div>\n      </div>\n      <!--标题名-->\n      <a target=\"_blank\" class=\"titleLink\" href=\"/artworks/${data.idNum}\">${data.title}</a>\n      <!--底部-->\n      <div class=\"bottomBar\">\n      <!--作者信息-->\n      <div class=\"userInfo\">\n      <!--相比原代码，这里去掉了作者头像的 html 代码。因为抓取到的数据里没有作者头像。-->\n          <a target=\"_blank\" href=\"/member.php?id=${data.userId}\">\n            <div class=\"userName\">${data.user}</div>\n          </a>\n        </div>\n      </div>\n    </div>\n  </li>\n    `;\r\n            // 添加作品\r\n            const li2 = document.createElement('li');\r\n            li2.innerHTML = html;\r\n            const li = li2.children[0];\r\n            this.worksWrap.appendChild(li);\r\n            // 绑定收藏按钮的事件\r\n            const addBMKBtn = li.querySelector(`.${this.addBMKBtnClass}`);\r\n            const bookmarkedClass = this.bookmarkedClass;\r\n            addBMKBtn.addEventListener('click', function () {\r\n                const e = new CustomEvent('addBMK', {\r\n                    detail: { data: { id: data.idNum, tags: data.tags } },\r\n                });\r\n                window.dispatchEvent(e);\r\n                this.classList.add(bookmarkedClass);\r\n            });\r\n        };\r\n        // 清除多图作品\r\n        this.clearMultiple = () => {\r\n            this.filterResult((data) => {\r\n                return data.pageCount <= 1;\r\n            });\r\n        };\r\n        // 清除动图作品\r\n        this.clearUgoira = () => {\r\n            this.filterResult((data) => {\r\n                return !data.ugoiraInfo;\r\n            });\r\n        };\r\n        // 手动删除作品\r\n        this.deleteWork = (event) => {\r\n            const el = event.detail.data;\r\n            this.deleteId = parseInt(el.dataset.id);\r\n            this.filterResult((data) => {\r\n                return data.idNum !== this.deleteId;\r\n            });\r\n        };\r\n        this.addBookmark = (event) => {\r\n            const data = event.detail.data;\r\n            API.addBookmark('illusts', data.id.toString(), settings.widthTag === '1' ? data.tags : [], settings.restrict === '1', token.token);\r\n            this.resultMeta.forEach((result) => {\r\n                if (result.idNum === data.id) {\r\n                    result.bookmarked = true;\r\n                }\r\n            });\r\n        };\r\n        this.init();\r\n        new FastScreen();\r\n    }\r\n    setFormOption() {\r\n        // 个数/页数选项的提示\r\n        options.setWantPageTip({\r\n            text: lang.transl('_页数'),\r\n            tip: lang.transl('_从本页开始下载提示'),\r\n            rangTip: `1 - ${this.maxCount}`,\r\n        });\r\n    }\r\n    addCrawlBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.green, lang.transl('_开始筛选'), [\r\n            ['title', lang.transl('_开始筛选Title')],\r\n        ]).addEventListener('click', () => {\r\n            this.resultMeta = [];\r\n            window.addEventListener(EVT.list.addResult, this.createWork);\r\n            this.readyCrawl();\r\n        });\r\n        DOM.addBtn('crawlBtns', Colors.red, lang.transl('_在结果中筛选'), [\r\n            ['title', lang.transl('_在结果中筛选Title')],\r\n        ]).addEventListener('click', () => {\r\n            this.screenInResult();\r\n        });\r\n    }\r\n    addAnyElement() {\r\n        const deleteWorks = new DeleteWorks(`.${this.listClass}`);\r\n        deleteWorks.addClearMultipleBtn(`.${this.multipleClass}`, () => {\r\n            EVT.fire(EVT.list.clearMultiple);\r\n        });\r\n        deleteWorks.addClearUgoiraBtn(`.${this.ugoiraClass}`, () => {\r\n            EVT.fire(EVT.list.clearUgoira);\r\n        });\r\n        deleteWorks.addManuallyDeleteBtn((el) => {\r\n            EVT.fire(EVT.list.deleteWork, el);\r\n        });\r\n        // 添加收藏本页所有作品的功能\r\n        const bookmarkAllBtn = DOM.addBtn('otherBtns', Colors.green, lang.transl('_收藏本页面的所有作品'));\r\n        const bookmarkAll = new BookmarkAllWorks(bookmarkAllBtn);\r\n        bookmarkAllBtn.addEventListener('click', () => {\r\n            const listWrap = this.getWorksWrap();\r\n            if (listWrap) {\r\n                const list = listWrap.querySelectorAll('li');\r\n                // 被二次筛选过滤掉的作品会被隐藏，所以批量添加收藏时，过滤掉隐藏的作品\r\n                const showList = Array.from(list).filter((el) => {\r\n                    return el.style.display !== 'none';\r\n                });\r\n                bookmarkAll.sendWorkList(showList);\r\n            }\r\n        });\r\n    }\r\n    initAny() {\r\n        this.hotBar();\r\n        this.setPreviewResult(settings.previewResult);\r\n        window.addEventListener(EVT.list.addResult, this.showCount);\r\n        window.addEventListener('addBMK', this.addBookmark);\r\n        window.addEventListener(EVT.list.crawlFinish, this.onCrawlFinish);\r\n        window.addEventListener(EVT.list.clearMultiple, this.clearMultiple);\r\n        window.addEventListener(EVT.list.clearUgoira, this.clearUgoira);\r\n        window.addEventListener(EVT.list.deleteWork, this.deleteWork);\r\n        window.addEventListener(EVT.list.settingChange, this.onSettingChange);\r\n    }\r\n    destroy() {\r\n        DOM.clearSlot('crawlBtns');\r\n        DOM.clearSlot('otherBtns');\r\n        window.removeEventListener(EVT.list.addResult, this.showCount);\r\n        window.removeEventListener(EVT.list.crawlFinish, this.onCrawlFinish);\r\n        // 离开下载页面时，取消设置“不自动下载”\r\n        states.notAutoDownload = false;\r\n    }\r\n    getWantPage() {\r\n        this.crawlNumber = this.checkWantPageInput(lang.transl('_从本页开始下载x页'), lang.transl('_下载所有页面'));\r\n        if (this.crawlNumber === -1 || this.crawlNumber > this.maxCount) {\r\n            this.crawlNumber = this.maxCount;\r\n        }\r\n    }\r\n    async nextStep() {\r\n        this.initFetchURL();\r\n        this.needCrawlPageCount = await this.calcNeedCrawlPageCount();\r\n        if (this.needCrawlPageCount === 0) {\r\n            return this.noResult();\r\n        }\r\n        this.startGetIdList();\r\n        this.clearWorks();\r\n    }\r\n    // 组织要请求的 url 中的参数\r\n    initFetchURL() {\r\n        // 从 URL 中获取分类。可能有语言标识。\r\n        /*\r\n        https://www.pixiv.net/tags/Fate%2FGrandOrder/illustrations\r\n        https://www.pixiv.net/en/tags/Fate%2FGrandOrder/illustrations\r\n        */\r\n        let URLType = location.pathname.split('tags/')[1].split('/')[1];\r\n        // 但在“顶部”页面的时候是没有分类的，会是 undefined\r\n        if (URLType === undefined) {\r\n            URLType = '';\r\n        }\r\n        switch (URLType) {\r\n            case '':\r\n                this.worksType = 'artworks';\r\n                break;\r\n            case 'illustrations':\r\n            case 'illust_and_ugoira':\r\n            case 'ugoira':\r\n            case 'illust':\r\n                this.worksType = 'illustrations';\r\n                break;\r\n            case 'manga':\r\n                this.worksType = 'manga';\r\n                break;\r\n            default:\r\n                this.worksType = 'artworks';\r\n                break;\r\n        }\r\n        let p = API.getURLSearchField(location.href, 'p');\r\n        this.startpageNo = parseInt(p) || 1;\r\n        // 从页面 url 中获取可以使用的选项\r\n        this.option = {};\r\n        this.allOption.forEach((param) => {\r\n            let value = API.getURLSearchField(location.href, param);\r\n            if (value !== '') {\r\n                this.option[param] = value;\r\n            }\r\n        });\r\n        // 如果没有指定搜索模式，则是精确匹配标签，设置对应的值\r\n        if (this.option.s_mode === undefined) {\r\n            this.option.s_mode = 's_tag_full';\r\n        }\r\n    }\r\n    // 获取搜索页的数据。因为有多处使用，所以进行了封装\r\n    async getSearchData(p) {\r\n        let data = await API.getSearchData(store.tag, this.worksType, p, this.option);\r\n        return data.body.illust || data.body.illustManga || data.body.manga;\r\n    }\r\n    // 计算应该抓取多少页\r\n    async calcNeedCrawlPageCount() {\r\n        let data = await this.getSearchData(1);\r\n        // 计算总页数\r\n        let pageCount = Math.ceil(data.total / this.worksNoPerPage);\r\n        if (pageCount > this.maxCount) {\r\n            // 最大为 1000\r\n            pageCount = this.maxCount;\r\n        }\r\n        // 计算从本页开始抓取的话，有多少页\r\n        let needFetchPage = pageCount - this.startpageNo + 1;\r\n        // 比较用户设置的页数，取较小的那个数值\r\n        if (needFetchPage < this.crawlNumber) {\r\n            return needFetchPage;\r\n        }\r\n        else {\r\n            return this.crawlNumber;\r\n        }\r\n    }\r\n    // 建立并发抓取线程\r\n    startGetIdList() {\r\n        if (this.needCrawlPageCount <= this.ajaxThreadsDefault) {\r\n            this.ajaxThreads = this.needCrawlPageCount;\r\n        }\r\n        else {\r\n            this.ajaxThreads = this.ajaxThreadsDefault;\r\n        }\r\n        for (let i = 0; i < this.ajaxThreads; i++) {\r\n            this.getIdList();\r\n        }\r\n    }\r\n    // 仅当出错重试时，才会传递参数 p。此时直接使用传入的 p，而不是继续让 p 增加\r\n    async getIdList(p) {\r\n        if (p === undefined) {\r\n            p = this.startpageNo + this.sendCrawlTaskCount;\r\n            this.sendCrawlTaskCount++;\r\n        }\r\n        // 发起请求，获取列表页\r\n        let data;\r\n        try {\r\n            data = await this.getSearchData(p);\r\n        }\r\n        catch (_a) {\r\n            return this.getIdList(p);\r\n        }\r\n        data = data.data;\r\n        for (const nowData of data) {\r\n            // 排除广告信息\r\n            if (nowData.isAdContainer) {\r\n                continue;\r\n            }\r\n            const filterOpt = {\r\n                createDate: nowData.createDate,\r\n                id: nowData.id,\r\n                width: nowData.width,\r\n                height: nowData.height,\r\n                pageCount: nowData.pageCount,\r\n                bookmarkData: nowData.bookmarkData,\r\n                illustType: nowData.illustType,\r\n                tags: nowData.tags,\r\n                userid: nowData.userId,\r\n            };\r\n            if (await filter.check(filterOpt)) {\r\n                store.idList.push({\r\n                    type: API.getWorkType(nowData.illustType),\r\n                    id: nowData.id,\r\n                });\r\n            }\r\n        }\r\n        this.listPageFinished++;\r\n        log.log(lang.transl('_列表页抓取进度', this.listPageFinished.toString()), 1, false);\r\n        if (this.sendCrawlTaskCount + 1 <= this.needCrawlPageCount) {\r\n            // 继续发送抓取任务（+1 是因为 sendCrawlTaskCount 从 0 开始）\r\n            this.getIdList();\r\n        }\r\n        else {\r\n            // 抓取任务已经全部发送\r\n            if (this.listPageFinished === this.needCrawlPageCount) {\r\n                // 抓取任务全部完成\r\n                log.log(lang.transl('_列表页抓取完成'));\r\n                this.getIdListFinished();\r\n            }\r\n        }\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.listPageFinished = 0;\r\n        this.sendCrawlTaskCount = 0;\r\n    }\r\n    // 搜索页把下载任务按收藏数从高到低下载\r\n    sortResult() {\r\n        store.resultMeta.sort(API.sortByProperty('bmk'));\r\n        store.result.sort(API.sortByProperty('bmk'));\r\n    }\r\n    setPreviewResult(value) {\r\n        this.previewResult = value;\r\n        // 如果设置了“预览搜索结果”，则“不自动下载”。否则允许自动下载\r\n        states.notAutoDownload = value ? true : false;\r\n    }\r\n    // 返回包含作品列表的 ul 元素\r\n    getWorksWrap() {\r\n        const test = document.querySelectorAll(this.worksWrapSelector);\r\n        if (test.length > 0) {\r\n            if (test.length > 2) {\r\n                // 大于 2 的情况是在搜索页的首页，或者小说页面\r\n                return test[2];\r\n            }\r\n            // 在插画、漫画、artworks 页面只有两个 ul 或者一个\r\n            return test[test.length - 1];\r\n        }\r\n        return null;\r\n    }\r\n    // 清空作品列表，只在作品抓取完毕时使用。之后会生成根据收藏数排列的作品列表。\r\n    clearWorks() {\r\n        this.worksWrap = this.getWorksWrap();\r\n        if (!this.previewResult || !this.worksWrap) {\r\n            return;\r\n        }\r\n        this.worksWrap.innerHTML = '';\r\n    }\r\n    // 传递作品 id 列表，从页面上的作品列表里移除这些作品\r\n    removeWorks(idList) {\r\n        // #root section ul .searchList\r\n        const listSelector = `${this.worksWrapSelector} .${this.listClass}`;\r\n        const lists = document.querySelectorAll(listSelector);\r\n        for (const li of lists) {\r\n            if (li.dataset.id && idList.includes(li.dataset.id)) {\r\n                li.style.display = 'none';\r\n                // li.remove()\r\n                // 推测隐藏元素可以更快的重绘好页面，因为删除元素修改了 dom 结构，花的时间可能会多一些\r\n            }\r\n        }\r\n    }\r\n    // 筛选抓取结果。传入函数，过滤符合条件的结果\r\n    // 在抓取完成之后，所有会从结果合集中删除某些结果的操作都要经过这里\r\n    async filterResult(callback) {\r\n        if (this.resultMeta.length === 0) {\r\n            EVT.sendMsg({\r\n                msg: lang.transl('_没有数据可供使用'),\r\n                type: 'error',\r\n            });\r\n            return;\r\n        }\r\n        EVT.fire(EVT.list.closeCenterPanel);\r\n        log.clear();\r\n        const beforeLength = this.resultMeta.length; // 储存过滤前的结果数量\r\n        const resultMetaTemp = [];\r\n        const resultMetaRemoved = [];\r\n        for (const meta of this.resultMeta) {\r\n            if (await callback(meta)) {\r\n                resultMetaTemp.push(meta);\r\n            }\r\n            else {\r\n                resultMetaRemoved.push(meta);\r\n            }\r\n        }\r\n        this.resultMeta = resultMetaTemp;\r\n        // 如果过滤后，作品元数据发生了改变则重排作品\r\n        if (this.resultMeta.length !== beforeLength) {\r\n            let ids = [];\r\n            for (const result of resultMetaRemoved) {\r\n                ids.push(result.idNum.toString());\r\n            }\r\n            this.removeWorks(ids);\r\n            this.reAddResult();\r\n        }\r\n        EVT.fire(EVT.list.resultChange);\r\n    }\r\n    // 重新添加抓取结果，执行时机：\r\n    // 1 作品抓取完毕之后，添加抓取到的数据\r\n    // 2 使用“在结果中筛选”或删除作品，使得作品数据变化了，改变作品列表视图\r\n    // 3 修改了“多图下载设置”，导致作品数据变化\r\n    reAddResult() {\r\n        store.reset();\r\n        for (let data of this.resultMeta) {\r\n            // 如果此时的 dlCount 与之前的 dlCount 不一样，则更新它\r\n            const dlCount = settingAPI.getDLCount(data.pageCount);\r\n            if (dlCount !== data.dlCount) {\r\n                data = Object.assign(data, { dlCount: dlCount });\r\n            }\r\n            store.addResult(data);\r\n        }\r\n    }\r\n    // 在当前结果中再次筛选，会修改第一次筛选的结果\r\n    screenInResult() {\r\n        if (states.busy) {\r\n            EVT.sendMsg({\r\n                msg: lang.transl('_当前任务尚未完成'),\r\n                type: 'error',\r\n            });\r\n            return;\r\n        }\r\n        log.clear();\r\n        this.getMultipleSetting();\r\n        this.filterResult((data) => {\r\n            const filterOpt = {\r\n                id: data.id,\r\n                illustType: data.type,\r\n                pageCount: data.pageCount,\r\n                tags: data.tags,\r\n                bookmarkCount: data.bmk,\r\n                bookmarkData: data.bookmarked,\r\n                width: data.fullWidth,\r\n                height: data.fullHeight,\r\n                createDate: data.date,\r\n                userid: data.userId,\r\n            };\r\n            return filter.check(filterOpt);\r\n        });\r\n    }\r\n    // 去除热门作品上面的遮挡\r\n    hotBar() {\r\n        // 因为热门作品里的元素是延迟加载的，所以使用定时器检查\r\n        const timer = window.setInterval(() => {\r\n            const hotWorkAside = document.querySelector(this.hotWorkAsideSelector);\r\n            if (hotWorkAside) {\r\n                window.clearInterval(timer);\r\n                // 去掉遮挡作品的购买链接\r\n                const premiumLink = hotWorkAside.nextSibling;\r\n                premiumLink && premiumLink.remove();\r\n                // 去掉遮挡后两个作品的 after。因为是伪元素，所以要通过 css 控制\r\n                const style = `\n        section aside ul::after{\n          display:none !important;\n        }\n        `;\r\n                DOM.addStyle(style);\r\n            }\r\n        }, 300);\r\n    }\r\n}\r\nexport { InitSearchArtworkPage };\r\n","// 初始化插画/漫画的系列作品页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { API } from '../API';\r\nimport { lang } from '../Lang';\r\nimport { DOM } from '../DOM';\r\nimport { options } from '../setting/Options';\r\nimport { filter } from '../Filter';\r\nimport { store } from '../Store';\r\nimport { log } from '../Log';\r\nclass InitSeriesPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        // 目前存在新版和旧版共存的情况，对这新旧页面采取不同的抓取方式\r\n        // 一个主要的原因是，旧版一页 18 个作品，新版一页 12 个作品，所以旧版还是继续使用之前的方式比较省事\r\n        this.baseUrl = '';\r\n        this.seriesId = '';\r\n        this.init();\r\n    }\r\n    addCrawlBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_开始抓取') + lang.transl('_默认下载多页')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    setFormOption() {\r\n        // 个数/页数选项的提示\r\n        this.maxCount = 100;\r\n        options.setWantPageTip({\r\n            text: lang.transl('_页数'),\r\n            tip: lang.transl('_从本页开始下载提示'),\r\n            rangTip: `1 - ${this.maxCount}`,\r\n        });\r\n    }\r\n    getWantPage() {\r\n        this.crawlNumber = this.checkWantPageInputGreater0(this.maxCount, true);\r\n    }\r\n    nextStep() {\r\n        // 设置起始页码\r\n        const p = API.getURLSearchField(location.href, 'p');\r\n        this.startpageNo = parseInt(p) || 1;\r\n        // 判断是否是旧版\r\n        let old = !!document.querySelector('.badge');\r\n        if (old) {\r\n            // 旧版\r\n            // 设置起始网址\r\n            const url = new URL(window.location.href);\r\n            url.searchParams.set('p', '1');\r\n            this.baseUrl = url.toString();\r\n            this.getIdListOld();\r\n        }\r\n        else {\r\n            // 新版\r\n            // 获取系列 id\r\n            this.seriesId = API.getURLPathField('series');\r\n            this.getIdList();\r\n        }\r\n    }\r\n    async getIdListOld() {\r\n        let p = this.startpageNo + this.listPageFinished;\r\n        let dom;\r\n        try {\r\n            const res = await fetch(this.baseUrl.replace('p=1', 'p=' + p));\r\n            const text = await res.text();\r\n            const parse = new DOMParser();\r\n            dom = parse.parseFromString(text, 'text/html');\r\n        }\r\n        catch (error) {\r\n            this.getIdListOld();\r\n            return;\r\n        }\r\n        this.listPageFinished++;\r\n        if (dom.querySelector('.no-content')) {\r\n            // 此页没有内容，也就没有后续内容了\r\n            return this.getIdListFinished();\r\n        }\r\n        const workList = dom.querySelectorAll('.works .image-item');\r\n        // 检查每个作品的信息\r\n        for (const item of workList) {\r\n            // https://www.pixiv.net/user/3698796/series/61267\r\n            const link = item.querySelector('a').href;\r\n            const id = parseInt(link.split('/artworks/')[1]);\r\n            const tagString = item.querySelector('img').dataset.tags;\r\n            const tags = tagString ? tagString.split(' ') : [];\r\n            const bookmarkBtn = item.querySelector('._one-click-bookmark');\r\n            const bookmarked = bookmarkBtn\r\n                ? bookmarkBtn.classList.contains('on')\r\n                : false;\r\n            const filterOpt = {\r\n                id: id,\r\n                tags: tags,\r\n                bookmarkData: bookmarked,\r\n            };\r\n            // 其实 type 这里有个存疑的地方。如果插画没有系列页面，只有漫画有系列页面，那么这里可以直接断言 type 为 manga。但是这一点尚不能完全确定，所以这里 type 是 unknown\r\n            if (await filter.check(filterOpt)) {\r\n                store.idList.push({\r\n                    type: 'unknown',\r\n                    id: id.toString(),\r\n                });\r\n            }\r\n        }\r\n        log.log(lang.transl('_列表页抓取进度', this.listPageFinished.toString()), 1, false);\r\n        // 抓取完毕\r\n        if (p >= this.maxCount || this.listPageFinished === this.crawlNumber) {\r\n            log.log(lang.transl('_列表页抓取完成'));\r\n            this.getIdListFinished();\r\n        }\r\n        else {\r\n            // 继续抓取\r\n            this.getIdListOld();\r\n        }\r\n    }\r\n    async getIdList() {\r\n        let p = this.startpageNo + this.listPageFinished;\r\n        const data = await API.getSeriesData(this.seriesId, p);\r\n        this.listPageFinished++;\r\n        // 保存本页面的作品的 id 列表\r\n        const idList = [];\r\n        for (const info of data.body.page.series) {\r\n            idList.push(info.workId);\r\n        }\r\n        // data.body.page.series 里的才是本页面的作品，illust 里则不同，有时它的作品数量比页面上的更多\r\n        // 从 illust 里查找 id 对应的数据，进行过滤\r\n        for (const work of data.body.thumbnails.illust) {\r\n            if (!idList.includes(work.id)) {\r\n                continue;\r\n            }\r\n            if (work.isAdContainer) {\r\n                continue;\r\n            }\r\n            // 过滤器进行检查\r\n            const filterOpt = {\r\n                id: work.id,\r\n                tags: work.tags,\r\n                bookmarkData: !!work.bookmarkData,\r\n                width: work.width,\r\n                height: work.height,\r\n                illustType: work.illustType,\r\n                userid: work.userId,\r\n            };\r\n            // 因为这个 api 的 illust 数据可能是插画也可能是漫画，所以 type 是 unknown\r\n            if (await filter.check(filterOpt)) {\r\n                store.idList.push({\r\n                    type: 'unknown',\r\n                    id: work.id,\r\n                });\r\n            }\r\n        }\r\n        // 如果 data.body.page.series 为空，就是到了最后一页\r\n        const endFlag = data.body.page.series.length === 0;\r\n        // 抓取完毕\r\n        if (endFlag ||\r\n            p >= this.maxCount ||\r\n            this.listPageFinished === this.crawlNumber) {\r\n            log.log(lang.transl('_列表页抓取完成'));\r\n            this.getIdListFinished();\r\n        }\r\n        else {\r\n            // 继续抓取\r\n            log.log(lang.transl('_列表页抓取进度', this.listPageFinished.toString()), 1, false);\r\n            this.getIdList();\r\n        }\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.listPageFinished = 0;\r\n    }\r\n}\r\nexport { InitSeriesPage };\r\n","import { API } from '../API';\r\nimport { filter } from '../Filter';\r\nimport { settings } from '../setting/Settings';\r\nimport { settingAPI } from '../setting/SettingAPI';\r\nimport { store } from '../Store';\r\n// 保存单个图片作品的数据\r\nclass SaveArtworkData {\r\n    async save(data) {\r\n        // 获取需要检查的信息\r\n        const body = data.body;\r\n        const fullWidth = body.width; // 原图宽度\r\n        const fullHeight = body.height; // 原图高度\r\n        const bmk = body.bookmarkCount; // 收藏数\r\n        const tagArr = body.tags.tags; // 取出 tag 信息\r\n        const tags = []; // 保存 tag 列表\r\n        const tagsWithTransl = []; // 保存 tag 列表，附带翻译后的 tag\r\n        const tagsTranslOnly = []; // 保存翻译后的 tag 列表\r\n        for (const tagData of tagArr) {\r\n            tags.push(tagData.tag);\r\n            tagsWithTransl.push(tagData.tag);\r\n            if (tagData.translation && tagData.translation.en) {\r\n                // 有翻译\r\n                // 不管是什么语种的翻译结果，都保存在 en 属性里\r\n                tagsWithTransl.push(tagData.translation.en);\r\n                tagsTranslOnly.push(tagData.translation.en);\r\n            }\r\n            else {\r\n                // 无翻译\r\n                // 把原 tag 保存到 tagsTranslOnly 里\r\n                tagsTranslOnly.push(tagData.tag);\r\n            }\r\n        }\r\n        const filterOpt = {\r\n            createDate: body.createDate,\r\n            id: body.id,\r\n            illustType: body.illustType,\r\n            tags: tagsWithTransl,\r\n            pageCount: body.pageCount,\r\n            bookmarkCount: bmk,\r\n            bookmarkData: body.bookmarkData,\r\n            width: fullWidth,\r\n            height: fullHeight,\r\n            mini: body.urls.mini,\r\n            userid: body.userId,\r\n        };\r\n        // 这里检查颜色设置是有一个隐患的：因为有些多图作品第一张图的颜色和后面的图片的颜色不一样，但这里检查时只检查第一张的缩略图。如果第一张被排除掉了，那么它后面的图片也就不会被加入抓取结果。\r\n        // 检查通过\r\n        if (await filter.check(filterOpt)) {\r\n            const idNum = parseInt(body.id);\r\n            const title = body.title; // 作品标题\r\n            const userid = body.userId; // 用户id\r\n            const user = body.userName; // 用户名\r\n            const thumb = body.urls.thumb;\r\n            const pageCount = body.pageCount;\r\n            const bookmarked = !!body.bookmarkData;\r\n            // 保存作品在排行榜上的编号\r\n            const rankData = store.getRankList(body.id);\r\n            const rank = rankData ? '#' + rankData : '';\r\n            const seriesTitle = body.seriesNavData ? body.seriesNavData.title : '';\r\n            const seriesOrder = body.seriesNavData\r\n                ? '#' + body.seriesNavData.order\r\n                : '';\r\n            // 储存作品信息\r\n            if (body.illustType !== 2) {\r\n                // 插画或漫画\r\n                // 下载该作品的前面几张\r\n                const dlCount = settingAPI.getDLCount(body.pageCount);\r\n                const imgUrl = body.urls.original; // 作品的原图 URL\r\n                const tempExt = imgUrl.split('.');\r\n                const ext = tempExt[tempExt.length - 1];\r\n                // 添加作品信息\r\n                store.addResult({\r\n                    id: body.id,\r\n                    idNum: idNum,\r\n                    thumb: thumb,\r\n                    pageCount: pageCount,\r\n                    dlCount: dlCount,\r\n                    original: imgUrl,\r\n                    regular: body.urls.regular,\r\n                    small: body.urls.small,\r\n                    title: title,\r\n                    tags: tags,\r\n                    tagsWithTransl: tagsWithTransl,\r\n                    tagsTranslOnly: tagsTranslOnly,\r\n                    user: user,\r\n                    userId: userid,\r\n                    fullWidth: fullWidth,\r\n                    fullHeight: fullHeight,\r\n                    ext: ext,\r\n                    bmk: bmk,\r\n                    bookmarked: bookmarked,\r\n                    date: body.createDate,\r\n                    type: body.illustType,\r\n                    rank: rank,\r\n                    seriesTitle: seriesTitle,\r\n                    seriesOrder: seriesOrder,\r\n                });\r\n            }\r\n            else if (body.illustType === 2) {\r\n                // 动图\r\n                // 获取动图的信息\r\n                const meta = await API.getUgoiraMeta(body.id);\r\n                // 动图帧延迟数据\r\n                const ugoiraInfo = {\r\n                    frames: meta.body.frames,\r\n                    mime_type: meta.body.mime_type,\r\n                };\r\n                const ext = settings.ugoiraSaveAs;\r\n                store.addResult({\r\n                    id: body.id,\r\n                    idNum: idNum,\r\n                    thumb: thumb,\r\n                    pageCount: pageCount,\r\n                    original: meta.body.originalSrc,\r\n                    regular: meta.body.src,\r\n                    small: meta.body.src,\r\n                    title: title,\r\n                    tags: tags,\r\n                    tagsWithTransl: tagsWithTransl,\r\n                    tagsTranslOnly: tagsTranslOnly,\r\n                    user: user,\r\n                    userId: userid,\r\n                    fullWidth: fullWidth,\r\n                    fullHeight: fullHeight,\r\n                    ext: ext,\r\n                    bmk: bmk,\r\n                    bookmarked: bookmarked,\r\n                    date: body.createDate,\r\n                    type: body.illustType,\r\n                    rank: rank,\r\n                    ugoiraInfo: ugoiraInfo,\r\n                    seriesTitle: seriesTitle,\r\n                    seriesOrder: seriesOrder,\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\nconst saveArtworkData = new SaveArtworkData();\r\nexport { saveArtworkData };\r\n","import Config from './Config';\r\nconst langText = {\r\n    _只下载已收藏: [\r\n        '只下载已收藏',\r\n        'ブックマークのみをダウンロードする',\r\n        'Download only bookmarked works',\r\n        '只下載已收藏',\r\n    ],\r\n    _只下载已收藏的提示: [\r\n        '只下载已经收藏的作品',\r\n        'ブックマークした作品のみをダウンロードする',\r\n        'Download only bookmarked works',\r\n        '只下載已經收藏的作品。',\r\n    ],\r\n    _下载作品类型: [\r\n        '下载作品类型',\r\n        'ダウンロード作品の種類',\r\n        'Download work type',\r\n        '下載作品類型',\r\n    ],\r\n    _下载作品类型的提示: [\r\n        '下载哪些类型的作品',\r\n        'どの種類の作品をダウンロードしますか',\r\n        'Which types of works to download',\r\n        '下載哪些類型的作品。',\r\n    ],\r\n    _多p下载前几张: [\r\n        '设置作品张数',\r\n        '作品ごとにダウンロード画像の数',\r\n        'Number of images downloaded per work',\r\n        '設定作品張數',\r\n    ],\r\n    _多p下载前几张提示: [\r\n        '下载每个作品的前几张图片。默认值 0 表示全部下载。',\r\n        '各作品の画像が最初の何枚をダウンロードしますか？ デフォルト値の 0 は、すべてをダウンロードします。',\r\n        'Download the first few images of each piece. The default value of 0 means all downloads.',\r\n        '下載每個作品的前幾張圖片。預設值 0 表示全部下載。',\r\n    ],\r\n    _不能含有tag: [\r\n        '不能含有 tag&nbsp;',\r\n        '指定した tag を除外する',\r\n        'Exclude specified tag',\r\n        '不能含有 tag&nbsp;',\r\n    ],\r\n    _排除tag的提示文字: [\r\n        '您可在下载前设置要排除的tag，这样在下载时将不会下载含有这些tag的作品。不区分大小写；如需排除多个tag，请使用英文逗号分隔。请注意要排除的tag的优先级大于要包含的tag的优先级。',\r\n        'ダウンロード前に、除外する tag を設定できます。大文字と小文字を区別しない；複数の tag を設定する必要がある場合は、「,」で区切ってください。除外された tag は、必要な tag よりも優先されます',\r\n        'Before downloading, you can set the tag you want to exclude. Not case sensitive; If you need to set multiple tags, you can use comma (,) separated. The excluded tag takes precedence over the included tag',\r\n        '可在下載前設定要排除的 tag，下載時將排除含有這些 tag 的作品，不區分大小寫；如需排除多個 tag，請使用半形逗號（,）分隔。請注意，要排除的 tag 優先於要包含的 tag。',\r\n    ],\r\n    _设置了排除tag之后的提示: [\r\n        '排除 tag：',\r\n        '以下の tag を除外：',\r\n        'Excludes tag: ',\r\n        '排除 tag：',\r\n    ],\r\n    _必须含有tag: [\r\n        '必须含有 tag&nbsp;',\r\n        '必要な tag&nbsp;',\r\n        'Must contain tag',\r\n        '必須含有 tag&nbsp;',\r\n    ],\r\n    _必须tag的提示文字: [\r\n        '您可在下载前设置作品里必须包含的tag，不区分大小写；如需包含多个tag，请使用英文逗号分隔。',\r\n        'ダウンロードする前に、必要な tag を設定することができます。大文字と小文字を区別しない；複数の tag を設定する必要がある場合は、「,」で区切ってください。',\r\n        'Before downloading, you can set the tag that must be included. Not case sensitive; If you need to set multiple tags, you can use comma (,) separated. ',\r\n        '可在下載前設定作品裡必須包含的 tag，不區分大小寫；如需包含多個 tag，請使用半形逗號（,）分隔。',\r\n    ],\r\n    _设置了必须tag之后的提示: [\r\n        '包含 tag：',\r\n        '以下の tag を含める：',\r\n        'Include tag: ',\r\n        '包含 tag：',\r\n    ],\r\n    _筛选宽高的按钮文字: [\r\n        '设置宽高条件',\r\n        '幅と高さの条件を設定する',\r\n        'Set the width and height',\r\n        '設定寬高條件',\r\n    ],\r\n    _筛选宽高的按钮Title: [\r\n        '在下载前，您可以设置要下载的图片的宽高条件。',\r\n        'ダウンロードする前に、画像の幅と高さの条件を設定できます。',\r\n        'Before downloading, you can set the width and height conditions of the images you want to download.',\r\n        '在下載前可以設定要下載的圖片的寬高條件。',\r\n    ],\r\n    _设置宽高比例: [\r\n        '设置宽高比例',\r\n        '縦横比を設定する',\r\n        'Set the aspect ratio',\r\n        '設定寬高比例',\r\n    ],\r\n    _设置宽高比例Title: [\r\n        '设置宽高比例，也可以手动输入宽高比',\r\n        '縦横比を設定する、手動で縦横比を入力することもできる',\r\n        'Set the aspect ratio, or manually type the aspect ratio',\r\n        '設定寬高比，也可以手動輸入寬高比。',\r\n    ],\r\n    _不限制: ['不限制', '無制限', 'not limited', '不限制'],\r\n    _横图: ['横图', '横長', 'Horizontal', '橫圖'],\r\n    _竖图: ['竖图', '縦長', 'Vertical', '豎圖'],\r\n    _输入宽高比: ['宽高比 >=', '縦横比 >=', 'Aspect ratio >=', '寬高比 >='],\r\n    _设置了宽高比之后的提示: [\r\n        '宽高比：{}',\r\n        '縦横比：{}',\r\n        'Aspect ratio: {}',\r\n        '寬高比：{}',\r\n    ],\r\n    _宽高比必须是数字: [\r\n        '宽高比必须是数字',\r\n        '縦横比は数値でなければなりません',\r\n        'The aspect ratio must be a number',\r\n        '寬高比必須是數字',\r\n    ],\r\n    _筛选宽高的提示文字: [\r\n        '请输入最小宽度和最小高度，不会下载不符合要求的图片。',\r\n        '最小幅と最小高さを入力してください。要件を満たしていない画像はダウンロードされません。',\r\n        'Please type the minimum width and minimum height. Will not download images that do not meet the requirements',\r\n        '請輸入最小寬度和最小高度，只會下載符合要求的圖片。',\r\n    ],\r\n    _本次输入的数值无效: [\r\n        '本次输入的数值无效',\r\n        '無効な入力',\r\n        'Invalid input',\r\n        '本次輸入的數值無效',\r\n    ],\r\n    _宽度: ['宽度', '幅', 'Width', '寬度'],\r\n    _或者: [' 或者 ', ' または ', ' or ', ' 或是 '],\r\n    _并且: [' 并且 ', ' そして ', ' and ', ' 並且 '],\r\n    _高度: ['高度', '高さ', 'height', '高度'],\r\n    _个数: [\r\n        '设置作品数量',\r\n        '作品数を設定する',\r\n        'Set the number of works',\r\n        '設定作品數量',\r\n    ],\r\n    _页数: [\r\n        '设置页面数量',\r\n        'ページ数を設定する',\r\n        'Set the number of pages',\r\n        '設定頁面數量',\r\n    ],\r\n    _筛选收藏数的按钮文字: [\r\n        '设置收藏数量',\r\n        'ブックマークされた数を設定する',\r\n        'Set the bookmarkCount conditions',\r\n        '設定收藏數量',\r\n    ],\r\n    _筛选收藏数的按钮Title: [\r\n        '在下载前，您可以设置对收藏数量的要求。',\r\n        'ダウンロードする前に、ブックマークされた数の条件を設定することができます。',\r\n        'Before downloading, You can set the requirements for the number of bookmarks.',\r\n        '下載前可以設定對收藏數量的要求。',\r\n    ],\r\n    _设置收藏数量: [\r\n        '设置收藏数量',\r\n        'ブックマークされた数を設定する',\r\n        'Set the number of bookmarks',\r\n        '設定收藏數量',\r\n    ],\r\n    _设置收藏数量的提示: [\r\n        '如果作品的收藏数小于设置的数字，作品不会被下载。',\r\n        '作品のブックマークされた数が設定された数字よりも少ない場合、作品はダウンロードされません。',\r\n        'If the number of bookmarks of the work is less than the set number, the work will not be downloaded.',\r\n        '只會下載設定收藏數範圍內的作品。',\r\n    ],\r\n    _筛选收藏数的提示文字: [\r\n        '请输入一个数字，如果作品的收藏数小于这个数字，作品不会被下载。',\r\n        '数字を入力してください。 作品のブックマークされた数がこの数字より少ない場合、作品はダウンロードされません。',\r\n        'Please type a number. If the number of bookmarks of the work is less than this number, the work will not be downloaded.',\r\n        '請輸入數字，只會下載設定收藏數範圍內的作品。',\r\n    ],\r\n    _收藏数大于: [\r\n        '收藏数 >= ',\r\n        'ブックマークの数 >= ',\r\n        'Number of bookmarks >= ',\r\n        '收藏數 >= ',\r\n    ],\r\n    _收藏数小于: [\r\n        '收藏数 <= ',\r\n        'ブックマークの数 <= ',\r\n        'Number of bookmarks <= ',\r\n        '收藏數 <= ',\r\n    ],\r\n    _本次任务已全部完成: [\r\n        '本次任务已全部完成。',\r\n        'このタスクは完了しました。',\r\n        'This task has been completed.',\r\n        '本次工作已全部完成',\r\n    ],\r\n    _本次任务条件: [\r\n        '本次任务条件: ',\r\n        'このタスクの条件：',\r\n        'This task condition: ',\r\n        '本次工作條件：',\r\n    ],\r\n    _参数不合法: [\r\n        '参数不合法，本次操作已取消。',\r\n        'パラメータは有効ではありません。この操作はキャンセルされました。',\r\n        'Parameter is not legal, this operation has been canceled.',\r\n        '參數不合法，本次動作已取消。',\r\n    ],\r\n    _向下获取所有作品: [\r\n        '向下获取所有作品',\r\n        'このページからすべての作品をダウンロードする。',\r\n        'download all the work from this page.',\r\n        '向下取得所有作品',\r\n    ],\r\n    _从本页开始下载提示: [\r\n        '从本页开始下载<br>如果要限制下载的页数，请输入从1开始的数字，1为仅下载本页。',\r\n        'このページからダウンロードする<br>ダウンロードするページを設定する場合は、1から始まる数字を入力してください。 1は現在のページのみをダウンロードする。',\r\n        'Download from this page<br>If you want to set the number of pages to download, type a number starting at 1. This page is 1.',\r\n        '從本頁開始下載。<br>如果要限制下載的頁數，請輸入從 1 開始的數字，1 為僅下載本頁。',\r\n    ],\r\n    _下载所有页面: [\r\n        '下载所有页面',\r\n        'すべてのページをダウンロードする',\r\n        'download all pages',\r\n        '下載所有頁面',\r\n    ],\r\n    _下载x个相关作品: [\r\n        '下载 {} 个相关作品',\r\n        '関連作品 {} 枚をダウンロードする。',\r\n        'download {} related works.',\r\n        '下載 {} 個相關作品',\r\n    ],\r\n    _下载所有相关作品: [\r\n        '下载所有相关作品',\r\n        '関連作品をすべてダウンロードする。',\r\n        'download all related works.',\r\n        '下載所有相關作品',\r\n    ],\r\n    _下载推荐作品: [\r\n        '下载推荐作品',\r\n        'お勧め作品をダウンロードする',\r\n        'download recommend works',\r\n        '下載推薦作品',\r\n    ],\r\n    _下载排行榜前x个作品: [\r\n        '下载排行榜前 {} 个作品',\r\n        'ランク前 {} 位の作品をダウンロードする。',\r\n        'download the top {} works in the ranking list',\r\n        '下載排行榜前 {} 個作品',\r\n    ],\r\n    _输入超过了最大值: [\r\n        '您输入的数字超过了最大值',\r\n        '入力した番号が最大値を超えています',\r\n        'The number you set exceeds the maximum',\r\n        '輸入的數字超出最大值',\r\n    ],\r\n    _从本页开始下载x页: [\r\n        '从本页开始下载 {} 页',\r\n        'このページから {} ページをダウンロードする',\r\n        'download {} pages from this page',\r\n        '從本頁開始下載 {} 頁',\r\n    ],\r\n    _从本页开始下载x个: [\r\n        '从本页开始下载 {} 个作品',\r\n        'このページから {} 枚の作品をダウンロード。',\r\n        'Download {} works from this page.',\r\n        '從本頁開始下載 {} 個作品',\r\n    ],\r\n    _任务开始0: ['任务开始', 'タスクが開始されます', 'Task starts', '工作開始'],\r\n    _排除了所有作品类型: [\r\n        '由于您排除了所有作品类型，本次任务已取消。',\r\n        'すべての種類の作品を除外したため、タスクはキャンセルされました。',\r\n        'Because you excluded all types of work, the task was canceled.',\r\n        '由於排除了所有作品類型，本次工作已取消。',\r\n    ],\r\n    _排除作品类型: [\r\n        '排除作品类型：',\r\n        'これらのタイプの作品を除外します：',\r\n        'Excludes these types of works: ',\r\n        '排除作品類型：',\r\n    ],\r\n    _多图作品: [\r\n        '多图作品',\r\n        'マルチイメージ作品',\r\n        'Multi-image works',\r\n        '多圖作品',\r\n    ],\r\n    _多图下载设置: [\r\n        '多图下载设置',\r\n        'マルチイメージ設定',\r\n        'Download multi-image works',\r\n        '多圖下載設定',\r\n    ],\r\n    _怎样下载多图作品: [\r\n        '怎样下载多图作品？',\r\n        'どのようにマルチイメージ作品をダウンロードしますか？',\r\n        'How to download multi-image works?',\r\n        '如何下載多圖作品？',\r\n    ],\r\n    _多图建立目录: [\r\n        '多图建立目录',\r\n        'マルチイメージにフォルダを作成',\r\n        'Create directory for multi-image works',\r\n        '多圖建立目錄',\r\n    ],\r\n    _多图建立目录提示: [\r\n        '当你下载多图作品时，下载器可以自动创建一个目录，保存里面的图片。',\r\n        'マルチイメージをダウンロードする時、自動的にフォルダを作成し、イメージをその中で保存することができます。',\r\n        'When you download a multi-image work, the downloader can automatically create a directory and save the images inside.',\r\n        '當下載多圖作品時，下載器可以自動建立一個目錄，儲存裡面的圖片。',\r\n    ],\r\n    _不下载: ['不下载', '必要なし', 'No', '不下載'],\r\n    _全部下载: ['全部下载', '全部ダウンロード', 'Yes', '全部下載'],\r\n    _下载前几张图片: [\r\n        '下载前几张图片：',\r\n        '最初のいくつかの画像：',\r\n        'First few images:',\r\n        '下載前幾張圖片：',\r\n    ],\r\n    _不下载多图作品: [\r\n        '不下载多图作品',\r\n        'マルチイメージ作品をダウンロードしない',\r\n        'Do not download multi-image works',\r\n        '不下載多圖作品',\r\n    ],\r\n    _多图作品下载前n张图片: [\r\n        '多图作品下载前 {} 张图片',\r\n        'マルチイメージ作品は、最初の {} イメージをダウンロードします',\r\n        'Multi-image works download the first {} images',\r\n        '多圖作品下載前 {} 張圖片',\r\n    ],\r\n    _插画: ['插画 ', 'イラスト', 'Illustrations', '插畫 '],\r\n    _漫画: ['漫画 ', '漫画', 'Manga', '漫畫 '],\r\n    _动图: ['动图 ', 'うごイラ', 'Ugoira', '動圖 '],\r\n    _动图保存格式: [\r\n        '动图保存格式',\r\n        'うごイラの保存タイプ',\r\n        'Save the ugoira work as',\r\n        '動圖儲存格式',\r\n    ],\r\n    _动图保存格式title: [\r\n        '下载动图时，可以把它转换成视频文件',\r\n        'うごイラをダウンロードするとき、動画に変換することができます。',\r\n        'When you download a ugoira work, you can convert it to a video file.',\r\n        '下載動圖時，可以將它轉換為影片檔案。',\r\n    ],\r\n    _webmVideo: ['WebM 视频', 'WebM ビデオ', 'WebM video', '影片（WebM）'],\r\n    _gif: ['GIF 图片', 'GIF 画像', 'GIF picture', '圖片（GIF）'],\r\n    _apng: ['APNG 图片', 'APNG 画像', 'APNG picture', '圖片（APNG）'],\r\n    _zipFile: ['Zip 文件', 'ZIP ファイル', 'Zip file', '壓縮檔（Zip）'],\r\n    _当前作品个数: [\r\n        '当前有 {} 个作品 ',\r\n        '今は　{}　枚の作品があります ',\r\n        'There are now {} works ',\r\n        '目前有 {} 個作品 ',\r\n    ],\r\n    _当前有x个用户: [\r\n        '当前有 {} 个用户 ',\r\n        '現在 {} 人のユーザーがいます ',\r\n        'There are currently {} users ',\r\n        '目前有 {} 個使用者 ',\r\n    ],\r\n    _排行榜进度: [\r\n        '已抓取本页面第{}部分',\r\n        'このページの第　{}　部がクロールされました',\r\n        'Part {} of this page has been crawled',\r\n        '已擷取本頁面第 {} 部分',\r\n    ],\r\n    _新作品进度: [\r\n        '已抓取本页面 {} 个作品',\r\n        'このページの {} つの作品をクロールしました',\r\n        'This page has been crawled {} works',\r\n        '已擷取本頁面 {} 個作品',\r\n    ],\r\n    _抓取多少个作品: [\r\n        '抓取本页面 {} 个作品',\r\n        'このページの {} つの作品をクロールします',\r\n        'Crawl this page {} works',\r\n        '擷取本頁面 {} 個作品',\r\n    ],\r\n    _相关作品抓取完毕: [\r\n        '相关作品抓取完毕。包含有{}个作品，开始获取作品信息。',\r\n        '関連作品はクロールされました。 {} 作品を含み、その作品に関する情報の取得を開始します。',\r\n        'The related works have been crawled. Contains {} works and starts getting information about the work.',\r\n        '相關作品擷取完畢。包含有 {} 個作品，開始取得作品資訊。',\r\n    ],\r\n    _排行榜任务完成: [\r\n        '本页面抓取完毕。<br>当前有{}个作品，开始获取作品信息。',\r\n        'このページのクロール終了。<br>{}枚の作品があります。 作品情報の取得を開始します。',\r\n        'This page is crawled and now has {} works.<br> Start getting the works for more information.',\r\n        '本頁面擷取完畢。<br>目前有 {} 個作品，開始取得作品資訊。',\r\n    ],\r\n    _列表页抓取进度: [\r\n        '已抓取列表页{}个页面',\r\n        '{} のリストページを取得しました',\r\n        'Has acquired {} list pages',\r\n        '已擷取清單頁 {} 個頁面',\r\n    ],\r\n    _列表页抓取完成: [\r\n        '列表页面抓取完成',\r\n        'リストページがクロールされ',\r\n        'The list page is crawled',\r\n        '清單頁面擷取完成',\r\n    ],\r\n    _抓取结果为零: [\r\n        '抓取完毕，但没有找到符合筛选条件的作品。',\r\n        'クロールは終了しましたが、フィルタ条件に一致する作品が見つかりませんでした。',\r\n        'Crawl finished but did not find works that match the filter criteria.',\r\n        '擷取完畢，但沒有找到符合篩選條件的作品。',\r\n    ],\r\n    _当前任务尚未完成: [\r\n        '当前任务尚未完成',\r\n        '現在のタスクはまだ完了していません',\r\n        'The current task has not yet been completed',\r\n        '目前工作尚未完成',\r\n    ],\r\n    _当前任务尚未完成2: [\r\n        '当前任务尚未完成，请等待完成后再下载。',\r\n        '現在のタスクはまだ完了していません、完了するまでお待ちください',\r\n        'The current task has not yet been completed',\r\n        '目前工作尚未完成，請等待完成後再下載。',\r\n    ],\r\n    _列表抓取完成开始获取作品页: [\r\n        '当前列表中有{}张作品，开始获取作品信息',\r\n        '{} 枚の作品があります。 作品情報の取得を開始します。',\r\n        'Now has {} works. Start getting the works for more information.',\r\n        '目前清單中有 {} 張作品，開始取得作品資訊',\r\n    ],\r\n    _开始获取作品页面: [\r\n        '开始获取作品页面',\r\n        '作品ページの取得を開始する',\r\n        'Start getting the works page',\r\n        '開始取得作品頁面',\r\n    ],\r\n    _无权访问: [\r\n        '无权访问 {}，跳过该作品。',\r\n        '{} のアクセス権限がありません、作品を無視する。',\r\n        'No access {}, skip.',\r\n        '沒有權限存取 {}，跳過該作品。',\r\n    ],\r\n    _作品页状态码0: [\r\n        '请求的url不可访问',\r\n        '要求された URL にアクセスできません',\r\n        'The requested url is not accessible',\r\n        '要求的 url 無法存取',\r\n    ],\r\n    _作品页状态码400: [\r\n        '该作品已被删除',\r\n        '作品は削除されました',\r\n        'The work has been deleted',\r\n        '該作品已被刪除',\r\n    ],\r\n    _作品页状态码403: [\r\n        '无权访问请求的url 403',\r\n        'リクエストされた url にアクセスできない 403',\r\n        'Have no access to the requested url 403',\r\n        '沒有權限存取要求的 url 403',\r\n    ],\r\n    _作品页状态码404: [\r\n        '404 not found',\r\n        '404 not found',\r\n        '404 not found',\r\n        '404 not found',\r\n    ],\r\n    _正在抓取: [\r\n        '正在抓取，请等待……',\r\n        'クロール中、しばらくお待ちください...',\r\n        'Getting, please wait...',\r\n        '擷取中，請稍後……',\r\n    ],\r\n    _获取全部书签作品: [\r\n        '获取全部书签作品，时间可能比较长，请耐心等待。',\r\n        'ブックマークしたすべての作品を取得すると、時間がかかることがあります。お待ちください。',\r\n        'Get all bookmarked works, the time may be longer, please wait.',\r\n        '取得全部書籤作品，時間可能比較長，請耐心等待。',\r\n    ],\r\n    _抓取图片网址遇到中断: [\r\n        '当前任务已中断!',\r\n        '現在のタスクが中断されました。',\r\n        'The current task has been interrupted.',\r\n        '目前工作已中斷！',\r\n    ],\r\n    _关闭: ['关闭', 'クローズ', 'close', '關閉'],\r\n    _输出信息: ['输出信息', '出力情報', 'Output information', '輸出資訊'],\r\n    _复制: ['复制', 'コピー', 'Copy', '複製'],\r\n    _已复制到剪贴板: [\r\n        '已复制到剪贴板，可直接粘贴',\r\n        'クリップボードにコピーされました',\r\n        'Has been copied to the clipboard',\r\n        '已複製至剪貼簿，可直接貼上',\r\n    ],\r\n    _下载设置: ['下载设置', 'ダウンロード設定', 'Download settings', '下載設定'],\r\n    _收起展开设置项: [\r\n        '收起/展开设置项',\r\n        '設定の折りたたみ/展開',\r\n        'Collapse/expand settings',\r\n        '摺疊/展開設定項目',\r\n    ],\r\n    _github: [\r\n        'Github 页面，欢迎 star',\r\n        'Github のページ、star をクリックしてください',\r\n        'Github page, if you like, please star it',\r\n        'Github 頁面，歡迎 star',\r\n    ],\r\n    _wiki: ['使用手册', 'マニュアル', 'Wiki', 'Wiki'],\r\n    _快捷键切换显示隐藏: [\r\n        '使用 Alt + X，可以显示和隐藏下载面板',\r\n        'Alt + X てダウンロードパネルを表示および非表示にする',\r\n        'Use Alt + X to show and hide the download panel',\r\n        'Alt + X 可以顯示或隱藏下載面板。',\r\n    ],\r\n    _共抓取到n个文件: [\r\n        '共抓取到 {} 个文件',\r\n        '合計 {} つのファイルがあります',\r\n        'Crawl a total of {} files',\r\n        '共擷取到 {} 個檔案',\r\n    ],\r\n    _命名规则: ['命名规则', '命名規則', 'Naming rule', '命名規則'],\r\n    _设置文件夹名的提示: [\r\n        `可以使用 '/' 建立文件夹<br>示例：{user}/{id}`,\r\n        `フォルダーは '/' で作成できます<br>例：{user}/{id}`,\r\n        `You can create a directory with '/'<br>Example：{user}/{id}`,\r\n        `可以使用斜線（/）建立資料夾。<br>範例：{user}/{id}`,\r\n    ],\r\n    _添加命名标记前缀: [\r\n        '添加命名标记前缀',\r\n        '前に tag の名前を追加',\r\n        'Add named tag prefix',\r\n        '加入命名標記前綴',\r\n    ],\r\n    _添加字段名称提示: [\r\n        '例如，在用户名前面添加“user_”标记',\r\n        'たとえば、ユーザー名の前に 「user_」 tag を追加します。',\r\n        'For example, add the \"user_\" tag in front of the username',\r\n        '例如，在使用者名稱前面加入「user_」標記。',\r\n    ],\r\n    _查看标记的含义: [\r\n        '查看标记的含义',\r\n        ' tag の意味を表示する',\r\n        'View the meaning of the tag',\r\n        '檢視標記的意義',\r\n    ],\r\n    _命名标记id: [\r\n        '默认文件名，如 44920385_p0',\r\n        'デフォルトのファイル名，例 44920385_p0',\r\n        'Default file name, for example 44920385_p0',\r\n        '預設檔案名稱，例如：44920385_p0。',\r\n    ],\r\n    _命名标记title: ['作品标题', '作品のタイトル', 'works title', '作品標題'],\r\n    _命名标记tags: [\r\n        '作品的 tag 列表',\r\n        '作品の tags',\r\n        'The tags of the work',\r\n        '作品的 tag 清單',\r\n    ],\r\n    _命名标记user: ['画师名字', 'アーティスト名', 'Artist name', '畫師名稱'],\r\n    _命名标记userid: ['画师 id', 'アーティスト ID', 'Artist id', '畫師 id'],\r\n    _命名标记px: ['宽度和高度', '幅と高さ', 'width and height', '寬度和高度'],\r\n    _命名标记bmk: [\r\n        'bookmark-count，作品的收藏数。把它放在最前面可以让文件按收藏数排序。',\r\n        'bookmark-count，作品のボックマークの数、前に追加することでボックマーク数で并べることができます。',\r\n        'bookmark-count, bookmarks number of works.',\r\n        'bookmark-count，作品的收藏數。將它放在最前面可以讓檔案依收藏數排序。',\r\n    ],\r\n    _命名标记id_num: [\r\n        '数字 id，如 44920385',\r\n        '44920385 などの番号 ID',\r\n        'Number id, for example 44920385',\r\n        '數字 id，例如：44920385。',\r\n    ],\r\n    _命名标记p_num: [\r\n        '图片在作品内的序号，如 0、1、2 …… 每个作品都会重新计数。',\r\n        '0、1、2 など、作品の画像のシリアル番号。各ピースは再集計されます。',\r\n        'The serial number of the picture in the work, such as 0, 1, 2 ... Each work will be recounted.',\r\n        '圖片在作品內的序號，例如：0、1、2……每個作品都將重新計數。',\r\n    ],\r\n    _命名标记tags_trans: [\r\n        '作品的 tag 列表，附带翻译后的 tag（如果有）',\r\n        '作品の tag リスト、翻訳付き tag (あれば)',\r\n        'The tags of the work, with the translated tag (if any)',\r\n        '作品的 tag 清單，包含翻譯後的 tag（如果有的話）。',\r\n    ],\r\n    _命名标记tags_transl_only: [\r\n        '翻译后的 tag 列表',\r\n        '翻訳后の tag リスト',\r\n        'Translated tags',\r\n        '譯後的 tag 清單。',\r\n    ],\r\n    _命名标记date: [\r\n        '作品的创建时间。如 2019-08-29',\r\n        '作品の作成時間。例 2019-08-29',\r\n        'The time the creation of the work. Such as 2019-08-29',\r\n        '作品的建立時間。例如：2019-08-29。',\r\n    ],\r\n    _命名标记rank: [\r\n        '作品在排行榜中的排名。如 #1、#2 …… 只能在排行榜页面中使用。',\r\n        '作品のランキング。例え　#1、#2 …… ランキングページのみで使用できます。',\r\n        'The ranking of the work in the ranking pages. Such as #1, #2 ... Can only be used in ranking pages.',\r\n        '作品在排行榜中的排名。例如：#1、#2……只能在排行榜頁面中使用。',\r\n    ],\r\n    _命名标记type: [\r\n        '作品类型，分为 illustration、manga、ugoira、novel',\r\n        '作品分類は、illustration、manga、ugoira、novel',\r\n        'The type of work, divided into illustration, manga, ugoira, novel',\r\n        '作品類型，分為 illustration、manga、ugoira、novel。',\r\n    ],\r\n    _命名标记提醒: [\r\n        '一定要包含 {id} 或者 {id_num}{p_num}。<br>您可以使用多个标记；建议在不同标记之间添加分割用的字符。示例：{id}-{userid}<br>* 在某些情况下，会有一些标记不可用。',\r\n        '必ず{id}または{id_num}{p_num}を含めてください。<br>複数のタグを使用することができます；異なるタグ間の分割のために文字を追加することをお勧めします。例：{id}-{userid}<br>* 場合によっては、一部の tag が利用できず。',\r\n        'Be sure to include {id} or {id_num}{p_num}.<br>You can use multiple tags, and you can add a separate character between different tags. Example: {id}-{userid}<br>* In some cases, some tags will not be available.',\r\n        '一定要包含 {id} 或者 {id_num}{p_num}。可以使用多個標記；建議在不同標記之間加入分隔用的字元。範例：{id}-{userid}<br><br>＊某些情況下有些標記無法使用。',\r\n    ],\r\n    _文件夹标记PTag: [\r\n        '当前页面的 tag。当前页面没有 tag 时不可用。',\r\n        '現在のページの tag。現在のページの tag がないときは使用できません。',\r\n        'The tag of the current page. Not available if the current page has no tag.',\r\n        '目前頁面的 tag。目前頁面沒有 tag 時無法使用。',\r\n    ],\r\n    _命名标记seriesTitle: [\r\n        '系列标题（可能为空）',\r\n        'シリーズタイトル（あれば）',\r\n        'Series title (may be empty)',\r\n        '系列標題（可能為空）',\r\n    ],\r\n    _命名标记seriesOrder: [\r\n        '作品在系列中的序号，如 #1 #2',\r\n        'シリーズの中の作品の番号，例え #1 #2',\r\n        'The number of the work in the series, such as #1 #2',\r\n        '作品在系列中的編號，如 #1 #2',\r\n    ],\r\n    _文件夹标记PTitle: [\r\n        '当前页面的标题',\r\n        'ページのタイトル',\r\n        'The title of this page',\r\n        '目前頁面的標題',\r\n    ],\r\n    _预览文件名: [\r\n        '预览文件名',\r\n        'ファイル名のプレビュー',\r\n        'Preview file name',\r\n        '預覽檔案名稱',\r\n    ],\r\n    _设置下载线程: [\r\n        '设置下载线程',\r\n        'ダウンロードスレッドを設定する',\r\n        'Set the download thread',\r\n        '設定下載執行緒',\r\n    ],\r\n    _线程数字: [\r\n        `可以输入 1-${Config.downloadThreadMax} 之间的数字，设置同时下载的数量`,\r\n        `同時ダウンロード数を設定、1-${Config.downloadThreadMax} の数値を入力してください`,\r\n        `You can type a number between 1-${Config.downloadThreadMax} to set the number of concurrent downloads`,\r\n        `可以輸入 1-${Config.downloadThreadMax} 之間的數字，設定同時下載的數量。`,\r\n    ],\r\n    _下载按钮1: ['开始下载', 'ダウンロードを開始', 'start download', '開始下載'],\r\n    _下载按钮2: [\r\n        '暂停下载',\r\n        'ダウンロードを一時停止',\r\n        'pause download',\r\n        '暫停下載',\r\n    ],\r\n    _下载按钮3: ['停止下载', 'ダウンロードを停止', 'stop download', '停止下載'],\r\n    _复制url: ['复制 url', 'URL をコピー', 'copy urls', '複製下載網址'],\r\n    _当前状态: ['当前状态 ', '現在の状態 ', 'State ', '目前狀態：'],\r\n    _未开始下载: [\r\n        '未开始下载',\r\n        'まだダウンロードを開始していません',\r\n        'Not yet started downloading',\r\n        '未開始下載',\r\n    ],\r\n    _下载进度: [\r\n        '下载进度：',\r\n        'ダウンロードの進行状況：',\r\n        'Total progress: ',\r\n        '下載進度：',\r\n    ],\r\n    _下载线程: ['下载线程：', 'スレッド：', 'Thread: ', '下載執行緒：'],\r\n    _常见问题: ['常见问题', 'よくある質問', 'Help', '常見問題'],\r\n    _uuid: [\r\n        '如果下载后的文件名异常，请禁用其他有下载功能的浏览器扩展。',\r\n        'ダウンロード後のファイル名が異常な場合は、ダウンロード機能を持つ他のブラウザ拡張機能を無効にしてください。',\r\n        'If the file name after downloading is abnormal, disable other browser extensions that have download capabilities.',\r\n        '如果下載後的檔案名稱異常，請停用其他有下載功能的瀏覽器擴充功能。',\r\n    ],\r\n    _下载说明: [\r\n        \"下载的文件保存在浏览器的下载目录里。<br>请不要在浏览器的下载选项里选中'总是询问每个文件的保存位置'。<br><b>如果下载后的文件名异常，请禁用其他有下载功能的浏览器扩展。</b><br>如果你使用 ssr、v2ray 等代理软件，开启全局代理有助于提高下载速度。<br>QQ群：116015651\",\r\n        'ダウンロードしたファイルは、ブラウザのダウンロードディレクトリに保存されます。<br><b>ダウンロード後のファイル名が異常な場合は、ダウンロード機能を持つ他のブラウザ拡張機能を無効にしてください。</b>',\r\n        'The downloaded file is saved in the browser`s download directory. <br><b>If the file name after downloading is abnormal, disable other browser extensions that have download capabilities.</b>',\r\n        '下載的檔案儲存在瀏覽器的下載目錄裡。<br>請不要在瀏覽器的下載選項裡選取「下載每個檔案前先詢問儲存位置」。<br><b>如果下載後的檔名異常，請停用其他有下載功能的瀏覽器擴充功能。</b>',\r\n    ],\r\n    _正在下载中: ['正在下载中', 'ダウンロード中', 'Downloading', '正在下載'],\r\n    _下载完毕: [\r\n        '✓ 下载完毕',\r\n        '✓ ダウンロードが完了しました',\r\n        '✓ Download finished',\r\n        '✓ 下載完畢',\r\n    ],\r\n    _已暂停: [\r\n        '下载已暂停',\r\n        'ダウンロードは一時停止中です',\r\n        'Download is paused',\r\n        '下載已暫停',\r\n    ],\r\n    _已停止: [\r\n        '下载已停止',\r\n        'ダウンロードが停止しました',\r\n        'Download stopped',\r\n        '下載已停止',\r\n    ],\r\n    _已下载: ['已下载', 'downloaded', 'downloaded', '已下載'],\r\n    _抓取完毕: [\r\n        '抓取完毕！',\r\n        'クロールが終了しました！',\r\n        'Crawl finished!',\r\n        '擷取完畢！',\r\n    ],\r\n    _快速下载本页: [\r\n        '快速下载本页作品',\r\n        'この作品をすばやくダウンロードする',\r\n        'Download this work quickly',\r\n        '快速下載本頁作品',\r\n    ],\r\n    _从本页开始抓取new: [\r\n        '从本页开始抓取新作品',\r\n        'このページから新しい作品を入手する',\r\n        'Crawl the new works from this page',\r\n        '從本頁開始擷取新作品',\r\n    ],\r\n    _从本页开始抓取old: [\r\n        '从本页开始抓取旧作品',\r\n        'このページから古い作品を入手する',\r\n        'Crawl the old works from this page',\r\n        '從本頁開始擷取舊作品',\r\n    ],\r\n    _抓取推荐作品: [\r\n        '抓取推荐作品',\r\n        '推奨作品をダウンロードする',\r\n        'Crawl the recommend works',\r\n        '擷取推薦作品',\r\n    ],\r\n    _抓取推荐作品Title: [\r\n        '抓取页面底部的的推荐作品',\r\n        'ページの下部で推奨作品をクロールします',\r\n        'Crawl the recommended works at the bottom of the page',\r\n        '擷取頁面底部的推薦作品。',\r\n    ],\r\n    _抓取相关作品: [\r\n        '抓取相关作品',\r\n        '関連作品をダウンロードする',\r\n        'Crawl the related works',\r\n        '擷取相關作品',\r\n    ],\r\n    _相关作品大于0: [\r\n        ' （下载相关作品必须大于 0）',\r\n        ' 「ダウンロードする関連作品の数は0より大きくなければならない」',\r\n        '  (Download related works must be greater than 0)',\r\n        ' （下載相關作品必須大於 0）',\r\n    ],\r\n    _默认下载多页: [\r\n        ', 如有多页，默认会下载全部。',\r\n        '、複数のページがある場合、デフォルトですべてをダウンロードされます。',\r\n        ', If there are multiple pages, the default will be downloaded.',\r\n        '，如有多頁，預設會下載全部。',\r\n    ],\r\n    _调整完毕: [\r\n        '调整完毕，当前有{}个作品。',\r\n        '調整が完了し、今、{} の作品があります。',\r\n        'The adjustment is complete and now has {} works.',\r\n        '調整完畢，目前有 {} 個作品。',\r\n    ],\r\n    _抓取当前作品: [\r\n        '抓取当前作品',\r\n        '現在の作品をクロールする',\r\n        'Crawl the current work',\r\n        '擷取目前作品',\r\n    ],\r\n    _抓取当前作品Title: [\r\n        '抓取当前列表里的所有作品',\r\n        '現在のリスト内のすべての作品をクロールする',\r\n        'Crawl all the works in the current list',\r\n        '擷取目前清單裡的所有作品',\r\n    ],\r\n    _清除多图作品: [\r\n        '清除多图作品',\r\n        '複数の作品を削除する',\r\n        'Remove multi-drawing works',\r\n        '清除多圖作品',\r\n    ],\r\n    _清除多图作品Title: [\r\n        '如果不需要可以清除多图作品',\r\n        '必要がない場合は、複数のグラフを削除することができます',\r\n        'If you do not need it, you can delete multiple graphs',\r\n        '如果不需要可以清除多圖作品。',\r\n    ],\r\n    _清除动图作品: [\r\n        '清除动图作品',\r\n        'うごイラ作品を削除する',\r\n        'Remove ugoira work',\r\n        '清除動圖作品',\r\n    ],\r\n    _清除动图作品Title: [\r\n        '如果不需要可以清除动图作品',\r\n        '必要がない場合は、うごイラを削除することができます',\r\n        'If you do not need it, you can delete the ugoira work',\r\n        '如果不需要可以清除動圖作品。',\r\n    ],\r\n    _手动删除作品: [\r\n        '手动删除作品',\r\n        '作品を手動で削除する',\r\n        'Manually delete the work',\r\n        '手動刪除作品',\r\n    ],\r\n    _手动删除作品Title: [\r\n        '可以在下载前手动删除不需要的作品',\r\n        'ダウンロードする前に不要な作品を手動で削除することができます',\r\n        'You can manually delete unwanted work before downloading',\r\n        '可以在下載前手動刪除不需要的作品，點擊作品刪除。',\r\n    ],\r\n    _退出手动删除: [\r\n        '退出手动删除',\r\n        '削除モードを終了する',\r\n        'Exit manually delete',\r\n        '結束手動刪除',\r\n    ],\r\n    _抓取本页作品: [\r\n        '抓取本页作品',\r\n        'このページをクロールする',\r\n        'Crawl this page works',\r\n        '擷取本頁作品',\r\n    ],\r\n    _抓取本页作品Title: [\r\n        '抓取本页列表中的所有作品',\r\n        'このページの全ての作品をクロールする',\r\n        'Crawl this page works',\r\n        '擷取本頁清單中的所有作品',\r\n    ],\r\n    _抓取本排行榜作品: [\r\n        '抓取本排行榜作品',\r\n        'このリストの作品をクロールする',\r\n        'Crawl the works in this list',\r\n        '擷取本排行榜作品',\r\n    ],\r\n    _抓取本排行榜作品Title: [\r\n        '抓取本排行榜的所有作品，包括现在尚未加载出来的。',\r\n        'まだ読み込まれていないものを含めて、このリストの作品をダウンロードする',\r\n        'Crawl all of the works in this list, including those that are not yet loaded.',\r\n        '擷取本排行榜的所有作品，包括現在尚未載入出來的。',\r\n    ],\r\n    _抓取首次登场的作品: [\r\n        '抓取首次登场作品',\r\n        '初登場作品をダウンロードする',\r\n        'Crawl the debut works',\r\n        '擷取首次登場作品',\r\n    ],\r\n    _抓取首次登场的作品Title: [\r\n        '只下载首次登场的作品',\r\n        '初登場作品のみダウンロードします',\r\n        'Download only debut works',\r\n        '只下載首次登場的作品',\r\n    ],\r\n    _抓取该页面的图片: [\r\n        '抓取该页面的图片',\r\n        'ページの画像をクロールする',\r\n        'Crawl the picture of the page',\r\n        '擷取該頁面的圖片',\r\n    ],\r\n    _抓取相似图片: [\r\n        '抓取相似图片',\r\n        '類似の作品をクロールする',\r\n        'Crawl similar works',\r\n        '擷取相似圖片',\r\n    ],\r\n    _想要获取多少个作品: [\r\n        '您想要获取多少个作品？',\r\n        'いくつの作品をダウンロードしたいですか？',\r\n        'How many works do you want to download?',\r\n        '想要取得多少個作品？',\r\n    ],\r\n    _数字提示1: [\r\n        '-1, 或者大于 0',\r\n        '-1、または 0 より大きい',\r\n        '-1, or greater than 0',\r\n        '-1 或是大於 0',\r\n    ],\r\n    _下载大家的新作品: [\r\n        '下载大家的新作品',\r\n        'みんなの新作をダウンロードする',\r\n        'Download everyone`s new work',\r\n        '下載大家的新作品',\r\n    ],\r\n    _屏蔽设定: ['屏蔽設定', 'ミュート設定', 'Mute settings', '封鎖設定'],\r\n    _举报: ['举报', '報告', 'Report', '回報'],\r\n    _输入id进行抓取: [\r\n        '输入id进行抓取',\r\n        'idを入力してダウンロードする',\r\n        'Type id to crawl',\r\n        '輸入 id 進行擷取',\r\n    ],\r\n    _输入id进行抓取的提示文字: [\r\n        '请输入作品id。如果有多个id，则以换行分割（即每行一个id）',\r\n        'イラストレーターIDを入力してください。 複数の id がある場合は、1 行に 1 つの id を付けます。',\r\n        'Please type the illustration id. If there is more than one id, one id per line.',\r\n        '請輸入作品 id。如果有多個 id，則以換行分隔（即每行一個 id）。',\r\n    ],\r\n    _开始抓取: ['开始抓取', 'クロールを開始する', 'Start crawling', '開始擷取'],\r\n    _给未分类作品添加添加tag: [\r\n        '给未分类作品添加 tag',\r\n        '未分類の作品に tag を追加',\r\n        'Add tag to unclassified work',\r\n        '幫未分類的作品加入 tag',\r\n    ],\r\n    _id不合法: ['id不合法', 'id が不正な', 'id is illegal', 'id 不合法'],\r\n    _快速收藏: [\r\n        '快速收藏',\r\n        'クイックブックマーク',\r\n        'Quick bookmarks',\r\n        '快速收藏',\r\n    ],\r\n    _启用: ['启用', '有効にする', 'Enable', '啟用'],\r\n    _自动开始下载: [\r\n        '自动开始下载',\r\n        'ダウンロードは自動的に開始されます',\r\n        'Download starts automatically',\r\n        '自動開始下載',\r\n    ],\r\n    _快速下载的提示: [\r\n        '当“开始下载”状态可用时，自动开始下载，不需要点击下载按钮。',\r\n        '「ダウンロードを開始する」ステータスが利用可能になると、ダウンロードは自動的に開始され、ダウンロードボタンをクリックする必要はありません。',\r\n        'When the &quot;Start Downloa&quot; status is available, the download starts automatically and no need to click the download button.',\r\n        '當可下載時自動開始下載，不需要點選下載按鈕。',\r\n    ],\r\n    _转换任务提示: [\r\n        '正在转换 {} 个文件',\r\n        '{} ファイルの変換',\r\n        'Converting {} files',\r\n        '正在轉換 {} 個檔案',\r\n    ],\r\n    _最近更新: ['最近更新', '最近更新する', 'What`s new', '最近更新'],\r\n    _确定: ['确定', '確定', 'Ok', '確定'],\r\n    _file404: [\r\n        '404 错误：文件 {} 不存在。',\r\n        '404 エラー：ファイル {} は存在しません。',\r\n        '404 error: File {} does not exist.',\r\n        '404 錯誤：檔案 {} 不存在。',\r\n    ],\r\n    _文件下载失败: [\r\n        '文件 {} 下载失败',\r\n        'ファイル {} のダウンロードを失敗しました',\r\n        'File {} download failed',\r\n        '檔案 {} 下載失敗',\r\n    ],\r\n    _是否重置设置: [\r\n        '是否重置设置？',\r\n        '設定をリセットしますか？',\r\n        'Do you want to reset the settings?',\r\n        '確定要重設設定嗎？',\r\n    ],\r\n    _newver: [\r\n        '有新版本可用',\r\n        '新しいバージョンがあります',\r\n        'A new version is available',\r\n        '有新版本可更新',\r\n    ],\r\n    _快速下载建立文件夹: [\r\n        '快速下载时，始终创建文件夹',\r\n        'クイックダウンロード時、常にフォルダを作成します',\r\n        'Always create directory when downloading quickly',\r\n        '快速下載時，始終建立資料夾',\r\n    ],\r\n    _快速下载建立文件夹提示: [\r\n        '快速下载时，如果只有一张图片，也会建立文件夹',\r\n        'すばやくダウンロードとき、イラストが一枚だけでも、フォルダも作成されます',\r\n        'When downloading quickly, if there is only one picture, a directory is also created',\r\n        '快速下載時，若只有一張圖片，也會建立資料夾',\r\n    ],\r\n    _设置id范围: [\r\n        '设置 id 范围',\r\n        'id 範囲を設定',\r\n        'Set id range',\r\n        '設定 id 範圍',\r\n    ],\r\n    _设置id范围提示: [\r\n        '您可以输入一个作品 id，抓取比它新或者比它旧的作品',\r\n        '1 つの作品 id を入力することで、それより新しいあるいは古い作品をクロールことができます',\r\n        'You can type a work id and crawl works that are newer or older than it',\r\n        '可以輸入一個作品 id，擷取比它新或者比它舊的作品。',\r\n    ],\r\n    _大于: ['大于', 'より大きい', 'Bigger than', '大於'],\r\n    _小于: ['小于', 'より小さい', 'Less than', '小於'],\r\n    _设置投稿时间: [\r\n        '设置投稿时间',\r\n        '投稿日時を設定する',\r\n        'Set posting date',\r\n        '設定投稿時間',\r\n    ],\r\n    _设置投稿时间提示: [\r\n        '您可以下载指定时间内发布的作品',\r\n        '指定された時間内に配信された作品をダウンロードすることができます',\r\n        'You can download works posted in a specified period of time',\r\n        '可以下載指定時間內發布的作品。',\r\n    ],\r\n    _时间范围: ['时间范围', '時間範囲', 'Time range', '時間範圍'],\r\n    _必须大于0: [\r\n        '必须大于 0',\r\n        '0 より大きくなければなりません',\r\n        'must be greater than 0',\r\n        '必須大於 0',\r\n    ],\r\n    _开始筛选: ['开始筛选', 'スクリーニング開始', 'Start screening', '開始篩選'],\r\n    _开始筛选Title: [\r\n        '按照设置来筛选当前 tag 里的作品。',\r\n        '現在の tag にある作品を設定によってスクリーニングする',\r\n        'Screen the works in the current tag.',\r\n        '按照設定來篩選目前 tag 裡的作品。',\r\n    ],\r\n    _在结果中筛选: [\r\n        '在结果中筛选',\r\n        '結果の中からスクリーニング',\r\n        'Screen in results',\r\n        '在結果中篩選',\r\n    ],\r\n    _在结果中筛选Title: [\r\n        '您可以改变设置，并在结果中再次筛选。',\r\n        '設定を変えて、結果の中で再びスクリーニングすることができます。',\r\n        'You can change the settings and screen again in the results.',\r\n        '可以變更設定，並在結果中再次篩選。',\r\n    ],\r\n    _抓取筛选结果: [\r\n        '抓取筛选结果',\r\n        'スクリーニングの結果をクロールする',\r\n        'Crawl the screening results',\r\n        '擷取篩選結果',\r\n    ],\r\n    _尚未开始筛选: [\r\n        '尚未开始筛选',\r\n        'まだスクリーニングを開始していない',\r\n        'Screening has not started',\r\n        '尚未開始篩選',\r\n    ],\r\n    _没有数据可供使用: [\r\n        '没有数据可供使用',\r\n        '使用可能なデータはない',\r\n        'No data is available.',\r\n        '沒有資料可供使用',\r\n    ],\r\n    _预览搜索结果: [\r\n        '预览搜索页面的筛选结果',\r\n        '検索ページのフィルタ結果をプレビューします',\r\n        'Preview filter results on search page',\r\n        '預覽搜尋頁面的篩選結果',\r\n    ],\r\n    _预览搜索结果说明: [\r\n        '下载器可以把符合条件的作品显示在当前页面上。如果抓取结果太多导致页面崩溃，请关闭这个功能。<br>启用预览功能时，下载器不会自动开始下载。',\r\n        'ローダは、該当する作品を現在のページに表示することができます。クロール結果が多すぎてページが崩れる場合は、この機能をオフにしてください。<br>プレビュー機能を有効にすると、ダウンロードは自動的に開始されません。',\r\n        'The downloader can display the qualified works on the current page. If too many crawling results cause the page to crash, turn off this feature.<br>When the preview feature is enabled, the downloader does not start downloading automatically.',\r\n        '下載器可以將符合條件的作品顯示在目前頁面上。如果擷取結果太多導致頁面當掉，請關閉這個功能。<br>啟用預覽功能時，下載器不會自動開始下載。',\r\n    ],\r\n    _目录名使用: [\r\n        '目录名使用：',\r\n        'ディレクトリ名の使用：',\r\n        'Folder name use: ',\r\n        '資料夾名稱使用：',\r\n    ],\r\n    _启用快速收藏: [\r\n        '启用快速收藏',\r\n        'クイックボックマークを有効にする',\r\n        'Enable quick bookmark',\r\n        '開啟快速收藏',\r\n    ],\r\n    _启用快速收藏说明: [\r\n        '当你点击下载器添加的收藏按钮(☆)，把作品添加到书签时，自动添加这个作品的 tag。',\r\n        'ダウンローダーに追加されたボックマークボタン「☆」をクリックして、作品をブックマークに追加すると、自動的に作品の tag が追加されます。',\r\n        'When you click the favorite button (☆) added by the downloader to bookmark a work, the tag of the work is automatically added.',\r\n        '當點選下載器新增的收藏按鈕（☆），將作品加入書籤時，自動新增這個作品的 tag。',\r\n    ],\r\n    _新增设置项: [\r\n        '新增设置项',\r\n        '新たな機能を追加されました。',\r\n        'Added setting items',\r\n        '新增設定項目',\r\n    ],\r\n    _抓取: ['抓取', 'クロール', 'Crawl', '擷取'],\r\n    _下载: ['下载', 'ダウンロード', 'Download', '下載'],\r\n    _其他: ['其他', 'その他', 'Other', '其他'],\r\n    _第一张图不带序号: [\r\n        '第一张图不带序号',\r\n        '最初のイメージの番号を削除します',\r\n        'The first picture without a serial number',\r\n        '第一張圖片不包含序號',\r\n    ],\r\n    _第一张图不带序号说明: [\r\n        '去掉每个作品第一张图的序号。例如 80036479_p0 变成 80036479',\r\n        '作品ごとの最初のイメージの番号を削除します。例えば 80036479_p0 は 80036479 になります。',\r\n        'Remove the serial number of the first picture of each work. For example 80036479_p0 becomes 80036479.',\r\n        '去掉每個作品第一張圖的序號。例如：80036479_p0 變成 80036479。',\r\n    ],\r\n    _最小值: ['最小值', '最小値', 'Minimum', '最小值'],\r\n    _最大值: ['最大值', '最大値', 'Maximum', '最大值'],\r\n    _单图作品: [\r\n        '单图作品',\r\n        'シングルイメージ作品',\r\n        'Single image works',\r\n        '單圖作品',\r\n    ],\r\n    _彩色图片: ['彩色图片', 'カラーイメージ', 'Color picture', '彩色圖片'],\r\n    _黑白图片: [\r\n        '黑白图片',\r\n        '白黒イメージ',\r\n        'Black and white pictures',\r\n        '黑白圖片',\r\n    ],\r\n    _不保存图片因为颜色: [\r\n        '{} 没有被保存，因为它的颜色不符合设定。',\r\n        '{} は色が設定に合わないため、保存されていません。',\r\n        '{} was not saved because its colors do not match the settings.',\r\n        '{} 並未儲存，因為它的色彩不符合設定。',\r\n    ],\r\n    _同时转换多少个动图: [\r\n        '同时转换多少个动图',\r\n        '同時変換のうごイラの上限',\r\n        'How many animations are converted at the same time',\r\n        '同時轉換多少個動圖',\r\n    ],\r\n    _同时转换多少个动图警告: [\r\n        '同时转换多个动图会增加资源占用。<br>转换动图时，请保持该标签页激活，否则浏览器会降低转换速度。',\r\n        '複数の動画を同時に変換すると、リソースの占有が増加します。<br>うごイラを変換するときは、このタブを有効にしてください。そうしないと、ブラウザは変換速度を下げます。',\r\n        'Converting multiple animations at the same time will increase resource consumption. <br> Please keep the tab active when converting animation, otherwise the browser will reduce the conversion speed.',\r\n        '同時轉換多個動圖會增加資源占用。<br>轉換動圖時，請保持這個分頁啟動，否則瀏覽器會降低轉換速度。',\r\n    ],\r\n    _提示: ['提示', 'ヒント', 'tip', '提示'],\r\n    _fanboxDownloader: [\r\n        'Fanbox 下载器',\r\n        'Fanbox ダウンロード',\r\n        'Fanbox Downloader',\r\n        'Fanbox 下載器',\r\n    ],\r\n    _不保存图片因为体积: [\r\n        '{} 没有被保存，因为它的体积不符合设定。',\r\n        '{} はファイルサイズが設定に合わないため、保存されていません。',\r\n        '{} was not saved because its size do not match the settings.',\r\n        '{} 並未儲存，因為它的大小不符合設定。',\r\n    ],\r\n    _文件体积限制: [\r\n        '文件体积限制',\r\n        'ファイルサイズ制限',\r\n        'File size limit',\r\n        '檔案體積限制',\r\n    ],\r\n    _不符合要求的文件不会被保存: [\r\n        '不符合要求的文件不会被保存。',\r\n        '設定 に合わないファイルは保存されません。',\r\n        'Files that do not meet the requirements will not be saved.',\r\n        '不符合要求的檔案不會被儲存。',\r\n    ],\r\n    _小说: ['小说', '小説', 'Novel', '小說'],\r\n    _抓取系列小说: [\r\n        '抓取系列小说',\r\n        '小説のシリーズをクロールする',\r\n        'Crawl series of novels',\r\n        '擷取系列小說',\r\n    ],\r\n    _小说保存格式: [\r\n        '小说保存格式',\r\n        '小説の保存形式',\r\n        'Save the novel as',\r\n        '小說儲存格式',\r\n    ],\r\n    _在小说里保存元数据: [\r\n        '在小说里保存元数据',\r\n        '小説の中にメタデータを保存する',\r\n        'Save metadata in the novel',\r\n        '將中繼資料（metadata）儲存在小說裡',\r\n    ],\r\n    _在小说里保存元数据提示: [\r\n        '把作者、网址等信息保存到小說里',\r\n        '作者やURLなどの情報をファイルの中に保存します。',\r\n        'Save the author, url and other information in the file',\r\n        '將作者、網址等訊息儲存到小說裡',\r\n    ],\r\n    _收藏本页面的所有作品: [\r\n        '收藏本页面的所有作品',\r\n        'この頁の全ての作品をブックマークに追加します',\r\n        'Bookmark all works on this page',\r\n        '收藏本頁面的所有作品',\r\n    ],\r\n    _输出内容太多已经为你保存到文件: [\r\n        '因为输出内容太多，已经为您保存到文件。',\r\n        '出力内容が多いため、txt ファイルに保存しました。',\r\n        'Because the output is too much, it has been saved to a file.',\r\n        '因為輸出內容太多，已經為你保存到檔案。',\r\n    ],\r\n    _不下载重复文件: [\r\n        '不下载重复文件',\r\n        '重複ファイルをダウンロードしない',\r\n        'Don`t download duplicate files',\r\n        '不下載重複檔案',\r\n    ],\r\n    _不下载重复文件的提示: [\r\n        '下载器会保存自己的下载记录，以避免下载重复的文件。',\r\n        'ダウンローダーは独自のダウンロード履歴を保存して、重複ファイルのダウンロードを回避する。',\r\n        'The downloader will save its download record to avoid downloading duplicate files.',\r\n        '下載器會儲存自己的下載記錄，以避免下載重複的檔案。',\r\n    ],\r\n    _策略: ['策略：', 'フィルター：', 'Strategy:', '策略：'],\r\n    _严格: ['严格', '厳格', 'Strict', '嚴格'],\r\n    _宽松: ['宽松', '緩い', 'Loose', '寬鬆'],\r\n    _严格模式说明: [\r\n        '当文件的 id 和文件名都相同时，认为是重复文件',\r\n        'ファイルの ID とファイル名が同じ場合、重複ファイルとみなされます',\r\n        'When the file id and file name are the same, it is considered a duplicate file',\r\n        '當檔案 id 和檔名都相同時，認為是重複檔案',\r\n    ],\r\n    _宽松模式说明: [\r\n        '只要文件的 id 相同，就认为是重复文件',\r\n        'ファイルの ID が同じである限り、重複ファイルと見なされます',\r\n        'As long as the id of the file is the same, it is considered a duplicate file',\r\n        '只要檔案 id 相同，就認為是重複檔案',\r\n    ],\r\n    _清除下载记录: [\r\n        '清除下载记录',\r\n        '履歴をクリア',\r\n        'Clear download record',\r\n        '清除下載記錄',\r\n    ],\r\n    _下载记录已清除: [\r\n        '下载记录已清除',\r\n        'ダウンロード履歴がクリアされました',\r\n        'Download record has been cleared',\r\n        '已清除下載記錄',\r\n    ],\r\n    _跳过下载因为重复文件: [\r\n        '检测到文件 {} 已经下载过，跳过此次下载',\r\n        '重複ファイル {} をスキップ',\r\n        'Skip downloading duplicate files {}',\r\n        '偵測到檔案 {} 已經下載過，跳過此次下載。',\r\n    ],\r\n    _xzNew660: [\r\n        '添加点续传功能；添加不下载重复文件的功能。',\r\n        '「レジューム機能を追加しました；重複ファイルの除外機能を追加しました。',\r\n        'Add breakpoint resume function; add the function not to download duplicate files.',\r\n        '新增断點續傳功能；新增不下載重複檔案的功能。',\r\n    ],\r\n    _保存用户头像为图标: [\r\n        '保存用户头像为图标',\r\n        'プロフィール画像をアイコンとして保存',\r\n        'Save user avatar as icon',\r\n        '將使用者頭像另存為圖示檔案',\r\n    ],\r\n    _保存用户头像为图标说明: [\r\n        '把用户头像保存为 ico 文件，可以手动设置成文件夹的图标。',\r\n        'ユーザーのプロフィール画像を ico ファイルとして保存して、フォルダーアイコンとして設定できます。',\r\n        'Save user avatar as icon',\r\n        '將使用者頭像儲存為 ico 檔案，可以手動設定成資料夾圖示。',\r\n    ],\r\n    _正在保存抓取结果: [\r\n        '正在保存抓取结果',\r\n        'クロール結果を保存しています',\r\n        'Saving crawl results',\r\n        '正在儲存擷取結果',\r\n    ],\r\n    _已保存抓取结果: [\r\n        '已保存抓取结果',\r\n        'クロール結果を保存しました',\r\n        'Crawl results saved',\r\n        '已儲存擷取結果',\r\n    ],\r\n    _正在恢复抓取结果: [\r\n        '正在恢复抓取结果',\r\n        'クロール結果を再開しています',\r\n        'Restoring crawl results',\r\n        '正在還原擷取結果',\r\n    ],\r\n    _已恢复抓取结果: [\r\n        '已恢复抓取结果',\r\n        'クロール結果を再開しました',\r\n        'Crawl results resumed',\r\n        '已還原擷取結果',\r\n    ],\r\n    _清空已保存的抓取结果: [\r\n        '清空已保存的抓取结果',\r\n        'セーブしたクロール結果をクリアします',\r\n        'Clear saved crawl results',\r\n        '清除已儲存的擷取結果',\r\n    ],\r\n    _数据清除完毕: [\r\n        '数据清除完毕',\r\n        'クリアされたデータ',\r\n        'Data cleared',\r\n        '資料清除完畢',\r\n    ],\r\n    _已跳过n个文件: [\r\n        '已跳过 {} 个文件',\r\n        '{} つのファイルをスキップしました',\r\n        '{} files skipped',\r\n        '已跳过 {} 个文件',\r\n    ],\r\n    _不保存图片因为宽高: [\r\n        '{} 没有被保存，因为它的宽高不符合设定。',\r\n        '{} は幅と高さが設定に合わないため、保存されていません。',\r\n        '{} was not saved because its width and height do not match the settings.',\r\n        '{} 並未儲存，因為它的寬高不符合設定。',\r\n    ],\r\n    _显示下载面板: [\r\n        '显示下载面板',\r\n        'ダウンロードパネルを表示',\r\n        'Show download panel',\r\n        '顯示下載面板',\r\n    ],\r\n    _保存: ['保存', '保存', 'Save', '儲存'],\r\n    _加载: ['加载', 'ロード', 'Load', '載入'],\r\n    _保存命名规则提示: [\r\n        '保存命名规则，最多 {} 个',\r\n        'ネームルールを保存します。最大 {} 個まで',\r\n        'Save naming rule, up to {}',\r\n        '儲存命名規則，最多 {} 個',\r\n    ],\r\n    _已保存命名规则: [\r\n        '已保存命名规则',\r\n        'ネームルールを保存しました',\r\n        'Naming rule saved',\r\n        '已儲存命名規則',\r\n    ],\r\n    _无损: ['无损', 'ロスレス', 'Lossless', '無損'],\r\n    _文件名长度限制: [\r\n        '文件名长度限制',\r\n        'ファイル名の長さ制限',\r\n        'File name length limit',\r\n        '檔案名稱長度限制',\r\n    ],\r\n    _导出csv: [\r\n        '导出 CSV 文件',\r\n        'CSV ファイルをエクスポート',\r\n        'Export CSV file',\r\n        '匯出 CSV 文檔',\r\n    ],\r\n    _导出抓取结果: [\r\n        '导出抓取结果',\r\n        'クロール結果をエクスポート',\r\n        'Export crawl results',\r\n        '匯出擷取結果',\r\n    ],\r\n    _图片尺寸: ['图片尺寸', '画像サイズ', 'Image size', '圖片尺寸'],\r\n    _原图: ['原图', 'Original', 'Original', '原圖'],\r\n    _普通: ['普通', 'Regular', 'Regular', '普通'],\r\n    _小图: ['小图', 'Small', 'Small', '小圖'],\r\n    _导出: ['导出', 'エクスポート', 'Export', '匯出'],\r\n    _导入: ['导入', 'インポート', 'Import', '匯入'],\r\n    _清除: ['清除', 'クリア', 'Clear', '清除'],\r\n    _导入下载记录: [\r\n        '导入下载记录',\r\n        'ダウンロード記録をインポート',\r\n        'Import download record',\r\n        '匯入下載記錄',\r\n    ],\r\n    _完成: ['完成', '完了', 'Completed', '完成'],\r\n    _日期格式: [\r\n        '日期和时间格式',\r\n        '日付と時刻の書式',\r\n        'Date and time format',\r\n        '日期和時間格式',\r\n    ],\r\n    _日期格式提示: [\r\n        '你可以使用以下标记来设置日期和时间格式。这会影响命名规则里的 {date} 和 {task_date}。<br>对于时间如 2021-04-30T06:40:08',\r\n        '以下のタグを使用して日時と時刻の書式を設定することができます。 これは命名規則の {date} と {task_date} に影響します。 <br> 例：2021-04-30T06:40:08',\r\n        'You can use the following notation to set the date and time format. This will affect {date} and {task_date} in the naming rules. <br>For time such as 2021-04-30T06:40:08',\r\n        '你可以使用以下標記來設定日期和時間格式。這會影響命名規則裡的 {date} 和 {task_date}。<br>對於資料如：2021-04-30T06:40:08。',\r\n    ],\r\n    _命名标记taskDate: [\r\n        '本次任务抓取完成时的时间。例如：2020-10-21',\r\n        'このタスクのクロールが完了した時刻です。 例：2020-10-21',\r\n        'The time when the task was crawl completed. For example: 2020-10-21',\r\n        '本次工作擷取完成時的時間。例如：2020-10-21。',\r\n    ],\r\n    _自动检测: ['自动检测', '自動検出', 'Auto', '自動偵測'],\r\n    _变更语言后刷新页面的提示: [\r\n        '更换语言后，请刷新页面。',\r\n        '言語を変更した後は、ページを更新してください。',\r\n        'Please refresh the page after changing the language.',\r\n        '變更語言後，請重新整理頁面。',\r\n    ],\r\n    _公开: ['公开', '公開', 'Public', '公開'],\r\n    _不公开: ['不公开', '非公開', 'Private', '非公開'],\r\n    _已收藏: ['已收藏', 'ブックマーク', 'Bookmarked', '已收藏'],\r\n    _下载之后收藏作品: [\r\n        '下载之后收藏作品',\r\n        'ダウンロードした作品をブックマークする',\r\n        'Bookmark works after downloading',\r\n        '下載之後收藏作品',\r\n    ],\r\n    _下载之后收藏作品的提示: [\r\n        '下载文件之后，自动收藏这个作品。',\r\n        'ダウンロード後、作品は自動的にブックマークされます。',\r\n        'After you download a file, the downloader will automatically bookmark the work.',\r\n        '下載檔案之後，自動收藏這個作品。',\r\n    ],\r\n    _收藏设置: ['收藏设置', 'ブックマーク設定 ', 'Bookmark settings', '收藏設定'],\r\n    _添加tag: ['添加 tag', 'tag を追加', 'Add tag', '加入 tag'],\r\n    _不添加tag: ['不添加 tag', 'tag なし', `Don't add tag`, '不加入 tag'],\r\n    _用户阻止名单: [\r\n        '用户阻止名单',\r\n        'ユーザーブロックリスト',\r\n        'User block list',\r\n        '使用者阻止名單',\r\n    ],\r\n    _用户阻止名单的说明: [\r\n        '不下载这些用户的作品。需要输入用户 id。如果有多个用户 id，使用英文逗号,分割。',\r\n        'これらのユーザーの作品はダウンロードしません。ユーザー ID が必要です。複数のユーザ ID は \",\" で区切ってください。',\r\n        'The works of these users will not be downloaded. Need to type the user ID. If there are multiple user ID, use comma (,) separated.',\r\n        '不下載這些使用者的作品。需要輸入使用者 id。若有多個使用者 id，使用英文逗號,分隔。',\r\n    ],\r\n    _全部: ['全部', '全部', 'All', '全部'],\r\n    _任一: ['任一', '何れか', 'One', '任一'],\r\n    _颜色主题: ['颜色主题', 'カラーテーマ', 'Color theme', '色彩主題'],\r\n    _管理设置: ['管理设置', '設定の管理', 'Manage settings', '管理設定'],\r\n    _导出设置: ['导出设置', 'エクスポート設定', 'Export settings', '匯出設定'],\r\n    _导入设置: ['导入设置', 'インポート設定', 'Import settings', '匯入設定'],\r\n    _重置设置: ['重置设置', 'リセット設定', 'Reset settings', '重設設定'],\r\n};\r\nexport { langText };\r\n","// 初始化收藏的新作小说页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { API } from '../API';\r\nimport { lang } from '../Lang';\r\nimport { DOM } from '../DOM';\r\nimport { options } from '../setting/Options';\r\nimport { filter } from '../Filter';\r\nimport { store } from '../Store';\r\nimport { log } from '../Log';\r\nclass InitBookmarkNewNovelPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.baseUrl = '';\r\n        this.init();\r\n    }\r\n    addCrawlBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_开始抓取') + lang.transl('_默认下载多页')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    setFormOption() {\r\n        // 个数/页数选项的提示\r\n        this.maxCount = 100;\r\n        options.setWantPageTip({\r\n            text: lang.transl('_页数'),\r\n            tip: lang.transl('_从本页开始下载提示'),\r\n            rangTip: `1 - ${this.maxCount}`,\r\n        });\r\n    }\r\n    getWantPage() {\r\n        this.crawlNumber = this.checkWantPageInputGreater0(this.maxCount, true);\r\n    }\r\n    getPageUrl() {\r\n        // 设置起始页面\r\n        const p = API.getURLSearchField(location.href, 'p');\r\n        this.startpageNo = parseInt(p) || 1;\r\n        const url = new URL(window.location.href);\r\n        url.searchParams.set('p', '1');\r\n        this.baseUrl = url.toString();\r\n        // https://www.pixiv.net/novel/bookmark_new.php?p=1\r\n        // https://www.pixiv.net/novel/bookmark_new_r18.php?p=1\r\n    }\r\n    nextStep() {\r\n        this.getPageUrl();\r\n        this.getIdList();\r\n    }\r\n    async getIdList() {\r\n        let p = this.startpageNo + this.listPageFinished;\r\n        let dom;\r\n        try {\r\n            const res = await fetch(this.baseUrl.replace('p=1', 'p=' + p));\r\n            const text = await res.text();\r\n            const parse = new DOMParser();\r\n            dom = parse.parseFromString(text, 'text/html');\r\n        }\r\n        catch (error) {\r\n            this.getIdList();\r\n            return;\r\n        }\r\n        this.listPageFinished++;\r\n        if (dom.querySelector('._no-item')) {\r\n            // 此页没有内容，也就没有后续内容了\r\n            return this.getIdListFinished();\r\n        }\r\n        const NovelItem = dom.querySelectorAll('.novel-items>li');\r\n        // 检查每个作品的信息\r\n        for (const item of NovelItem) {\r\n            // https://www.pixiv.net/novel/show.php?id=12831389\r\n            const link = item.querySelector('.imgbox a').href;\r\n            const id = parseInt(link.split('id=')[1]);\r\n            const bmkEl = item.querySelector('.bookmark-count');\r\n            let bmk = bmkEl ? parseInt(bmkEl.innerText) : 0;\r\n            const tags = [];\r\n            const tagsA = item.querySelectorAll('.tags>li>a');\r\n            for (const a of tagsA) {\r\n                tags.push(a.innerText.trim());\r\n            }\r\n            const userid = item.querySelector('img').dataset.userId;\r\n            // 有的作品没有收藏按钮，点进去之后发现这个作品已经被删除了，只是排行榜里没有及时更新。这样的作品没有收藏按钮。\r\n            const bookmarkBtn = item.querySelector('._one-click-bookmark');\r\n            const bookmarked = bookmarkBtn\r\n                ? bookmarkBtn.classList.contains('on')\r\n                : false;\r\n            const filterOpt = {\r\n                id: id,\r\n                illustType: 3,\r\n                tags: tags,\r\n                bookmarkCount: bmk,\r\n                bookmarkData: bookmarked,\r\n                userid: userid,\r\n            };\r\n            if (await filter.check(filterOpt)) {\r\n                store.idList.push({\r\n                    type: 'novels',\r\n                    id: id.toString(),\r\n                });\r\n            }\r\n        }\r\n        log.log(lang.transl('_列表页抓取进度', this.listPageFinished.toString()), 1, false);\r\n        // 抓取完毕\r\n        if (p >= this.maxCount || this.listPageFinished === this.crawlNumber) {\r\n            log.log(lang.transl('_列表页抓取完成'));\r\n            this.getIdListFinished();\r\n        }\r\n        else {\r\n            // 继续抓取\r\n            this.getIdList();\r\n        }\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.listPageFinished = 0;\r\n    }\r\n}\r\nexport { InitBookmarkNewNovelPage };\r\n","// 初始化 大家的新作小说页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { options } from '../setting/Options';\r\nimport { filter } from '../Filter';\r\nimport { API } from '../API';\r\nimport { store } from '../Store';\r\nimport { log } from '../Log';\r\nimport { DOM } from '../DOM';\r\nclass InitNewNovelPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.option = this.resetOption();\r\n        this.limitMax = 20; // 每次请求的数量最大是 20\r\n        this.fetchCount = 0; // 已请求的作品数量\r\n        this.init();\r\n    }\r\n    addCrawlBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_下载大家的新作品')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    setFormOption() {\r\n        // 个数/页数选项的提示\r\n        options.setWantPageTip({\r\n            text: lang.transl('_个数'),\r\n            tip: lang.transl('_想要获取多少个作品'),\r\n            rangTip: `1 - ${this.maxCount}`,\r\n        });\r\n    }\r\n    getWantPage() {\r\n        this.crawlNumber = this.checkWantPageInputGreater0(this.maxCount, false);\r\n    }\r\n    nextStep() {\r\n        this.initFetchURL();\r\n        this.getIdList();\r\n    }\r\n    resetOption() {\r\n        return {\r\n            lastId: '0',\r\n            limit: '20',\r\n            type: '',\r\n            r18: '',\r\n        };\r\n    }\r\n    // 组织要请求的 url\r\n    initFetchURL() {\r\n        this.option = this.resetOption();\r\n        if (this.crawlNumber < this.limitMax) {\r\n            this.option.limit = this.crawlNumber.toString();\r\n        }\r\n        else {\r\n            this.option.limit = this.limitMax.toString();\r\n        }\r\n        // 是否是 R18 模式\r\n        this.option.r18 = (location.href.includes('_r18.php') || false).toString();\r\n    }\r\n    async getIdList() {\r\n        let data;\r\n        try {\r\n            data = await API.getNewNovleData(this.option);\r\n        }\r\n        catch (error) {\r\n            this.getIdList();\r\n            return;\r\n        }\r\n        let useData = data.body.novels;\r\n        for (const nowData of useData) {\r\n            // 抓取够了指定的数量\r\n            if (this.fetchCount + 1 > this.crawlNumber) {\r\n                break;\r\n            }\r\n            else {\r\n                this.fetchCount++;\r\n            }\r\n            const filterOpt = {\r\n                id: nowData.id,\r\n                bookmarkData: nowData.bookmarkData,\r\n                bookmarkCount: nowData.bookmarkCount,\r\n                illustType: 3,\r\n                tags: nowData.tags,\r\n                userid: nowData.userId,\r\n            };\r\n            if (await filter.check(filterOpt)) {\r\n                store.idList.push({\r\n                    type: 'novels',\r\n                    id: nowData.id,\r\n                });\r\n            }\r\n        }\r\n        log.log(lang.transl('_新作品进度', this.fetchCount.toString()), 1, false);\r\n        // 抓取完毕\r\n        if (this.fetchCount >= this.crawlNumber ||\r\n            this.fetchCount >= this.maxCount) {\r\n            log.log(lang.transl('_开始获取作品页面'));\r\n            this.getIdListFinished();\r\n            return;\r\n        }\r\n        // 继续抓取\r\n        this.option.lastId = data.body.lastId;\r\n        this.getIdList();\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.fetchCount = 0;\r\n    }\r\n}\r\nexport { InitNewNovelPage };\r\n","//初始化小说作品页\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { options } from '../setting/Options';\r\nimport { store } from '../Store';\r\nimport { QuickBookmark } from '../QuickBookmark';\r\nimport { DOM } from '../DOM';\r\nimport { API } from '../API';\r\nimport { log } from '../Log';\r\nimport { EVT } from '../EVT';\r\nimport { states } from '../States';\r\nimport { QuickDownloadBtn } from '../QuickDownloadBtn';\r\nimport '../SaveAvatarIcon';\r\nclass InitNovelPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.quickDownBtn = document.createElement('button');\r\n        this.crawlDirection = 0; // 抓取方向，指示抓取新作品还是旧作品\r\n        this.startQuickDownload = () => {\r\n            this.readyCrawl();\r\n        };\r\n        this.init();\r\n    }\r\n    /*\r\n    -1 抓取新作品\r\n    0 不设置抓取方向\r\n    1 抓取旧作品\r\n    */\r\n    initAny() {\r\n        this.initQuickBookmark();\r\n        window.addEventListener(EVT.list.pageSwitchedTypeNotChange, this.initQuickBookmark);\r\n        // 初始化快速下载按钮\r\n        new QuickDownloadBtn();\r\n        window.addEventListener(EVT.list.QuickDownload, this.startQuickDownload);\r\n    }\r\n    initQuickBookmark() {\r\n        new QuickBookmark();\r\n    }\r\n    addCrawlBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_从本页开始抓取new')).addEventListener('click', () => {\r\n            this.crawlDirection = -1;\r\n            this.readyCrawl();\r\n        });\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_从本页开始抓取old')).addEventListener('click', () => {\r\n            this.crawlDirection = 1;\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    addAnyElement() {\r\n        DOM.addBtn('otherBtns', Colors.green, lang.transl('_保存用户头像为图标'), [\r\n            ['title', lang.transl('_保存用户头像为图标说明')],\r\n        ]).addEventListener('click', () => {\r\n            EVT.fire(EVT.list.saveAvatarIcon);\r\n        });\r\n    }\r\n    setFormOption() {\r\n        // 个数/页数选项的提示\r\n        options.setWantPageTip({\r\n            text: lang.transl('_个数'),\r\n            tip: lang.transl('_从本页开始下载提示') +\r\n                '<br>' +\r\n                lang.transl('_相关作品大于0'),\r\n            rangTip: lang.transl('_数字提示1'),\r\n        });\r\n    }\r\n    destroy() {\r\n        DOM.clearSlot('crawlBtns');\r\n        DOM.clearSlot('otherBtns');\r\n        // 删除快速下载按钮\r\n        DOM.removeEl(this.quickDownBtn);\r\n        window.removeEventListener(EVT.list.pageSwitchedTypeNotChange, this.initQuickBookmark);\r\n        window.removeEventListener(EVT.list.QuickDownload, this.startQuickDownload);\r\n    }\r\n    getWantPage() {\r\n        if (states.quickDownload) {\r\n            // 快速下载\r\n            this.crawlNumber = 1;\r\n        }\r\n        else {\r\n            // 检查下载页数的设置\r\n            const crawlAllTip = this.crawlDirection === -1\r\n                ? lang.transl('_从本页开始抓取new')\r\n                : lang.transl('_从本页开始抓取old');\r\n            this.crawlNumber = this.checkWantPageInput(lang.transl('_从本页开始下载x个'), crawlAllTip);\r\n        }\r\n    }\r\n    nextStep() {\r\n        if (states.quickDownload) {\r\n            // 快速下载\r\n            store.idList.push({\r\n                type: 'novels',\r\n                id: API.getNovelId(window.location.href),\r\n            });\r\n            log.log(lang.transl('_开始获取作品页面'));\r\n            this.getIdListFinished();\r\n        }\r\n        else {\r\n            // 向前向后下载\r\n            this.getIdList();\r\n        }\r\n    }\r\n    async getIdList() {\r\n        let type = ['novels'];\r\n        let idList = await API.getUserWorksByType(DOM.getUserId(), type);\r\n        // 储存符合条件的 id\r\n        let nowId = parseInt(API.getIllustId(window.location.href));\r\n        idList.forEach((id) => {\r\n            let idNum = parseInt(id.id);\r\n            // 新作品\r\n            if (idNum >= nowId && this.crawlDirection === -1) {\r\n                store.idList.push(id);\r\n            }\r\n            else if (idNum <= nowId && this.crawlDirection === 1) {\r\n                // 旧作品\r\n                store.idList.push(id);\r\n            }\r\n        });\r\n        // 当设置了下载个数时，进行裁剪\r\n        if (this.crawlNumber !== -1) {\r\n            // 新作品 升序排列\r\n            if (this.crawlDirection === -1) {\r\n                store.idList.sort(API.sortByProperty('id')).reverse();\r\n            }\r\n            else {\r\n                // 旧作品 降序排列\r\n                store.idList.sort(API.sortByProperty('id'));\r\n            }\r\n            store.idList = store.idList.splice(0, this.crawlNumber);\r\n        }\r\n        this.getIdListFinished();\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.crawlDirection = 0; // 解除下载方向的标记\r\n    }\r\n}\r\nexport { InitNovelPage };\r\n","//初始化小说系列作品页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { options } from '../setting/Options';\r\nimport { store } from '../Store';\r\nimport { DOM } from '../DOM';\r\nimport { API } from '../API';\r\nclass InitNovelSeriesPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.seriesId = '';\r\n        this.limit = 30;\r\n        this.last = 0;\r\n        this.init();\r\n    }\r\n    addCrawlBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_抓取系列小说')).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    setFormOption() {\r\n        // 隐藏“个数/页数”选项\r\n        options.hideOption([1]);\r\n    }\r\n    getWantPage() { }\r\n    nextStep() {\r\n        this.seriesId = API.getURLPathField('series');\r\n        this.getIdList();\r\n    }\r\n    async getIdList() {\r\n        const seriesData = await API.getNovelSeriesData(this.seriesId, this.limit, this.last, 'asc');\r\n        const list = seriesData.body.seriesContents;\r\n        for (const item of list) {\r\n            store.idList.push({\r\n                type: 'novels',\r\n                id: item.id,\r\n            });\r\n        }\r\n        this.last += list.length;\r\n        // 如果这一次返回的作品数量达到了每批限制，可能这次没有请求完，继续请求后续的数据\r\n        if (list.length === this.limit) {\r\n            this.getIdList();\r\n        }\r\n        else {\r\n            this.getIdListFinished();\r\n        }\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.seriesId = '';\r\n        this.last = 0;\r\n    }\r\n}\r\nexport { InitNovelSeriesPage };\r\n","// 初始化小说排行榜页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { DOM } from '../DOM';\r\nimport { options } from '../setting/Options';\r\nimport { filter } from '../Filter';\r\nimport { store } from '../Store';\r\nimport { log } from '../Log';\r\nclass InitRankingNovelPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.pageUrlList = [];\r\n        this.init();\r\n    }\r\n    addCrawlBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_抓取本排行榜作品'), [\r\n            ['title', lang.transl('_抓取本排行榜作品Title')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    setFormOption() {\r\n        // 个数/页数选项的提示\r\n        this.maxCount = 100;\r\n        options.setWantPageTip({\r\n            text: lang.transl('_个数'),\r\n            tip: lang.transl('_想要获取多少个作品'),\r\n            rangTip: `1 - ${this.maxCount}`,\r\n        });\r\n    }\r\n    getWantPage() {\r\n        // 检查下载页数的设置\r\n        this.crawlNumber = this.checkWantPageInput(lang.transl('_下载排行榜前x个作品'), lang.transl('_向下获取所有作品'));\r\n        // 如果设置的作品个数是 -1，则设置为下载所有作品\r\n        if (this.crawlNumber === -1) {\r\n            this.crawlNumber = this.maxCount;\r\n        }\r\n    }\r\n    getPageUrl() {\r\n        const ul = document.querySelector('.ui-selectbox-container ul');\r\n        if (ul) {\r\n            const li = ul.querySelectorAll('li');\r\n            this.maxCount = li.length * 50;\r\n            for (const el of li) {\r\n                this.pageUrlList.push(el.dataset.url);\r\n            }\r\n        }\r\n        else {\r\n            // 只有一页的话，没有页码部分的 ul li\r\n            this.pageUrlList.push(location.href);\r\n        }\r\n    }\r\n    nextStep() {\r\n        this.getPageUrl();\r\n        this.getIdList();\r\n    }\r\n    async getIdList() {\r\n        let dom;\r\n        try {\r\n            const res = await fetch(this.pageUrlList[this.listPageFinished]);\r\n            const text = await res.text();\r\n            const parse = new DOMParser();\r\n            dom = parse.parseFromString(text, 'text/html');\r\n        }\r\n        catch (error) {\r\n            this.getIdList();\r\n            return;\r\n        }\r\n        this.listPageFinished++;\r\n        const rankingItem = dom.querySelectorAll('._ranking-items>div');\r\n        // 检查每个作品的信息\r\n        for (const item of rankingItem) {\r\n            const rank = parseInt(item.querySelector('h1').innerText);\r\n            // 检查是否已经抓取到了指定数量的作品\r\n            if (rank > this.crawlNumber) {\r\n                return this.getIdListFinished();\r\n            }\r\n            // https://www.pixiv.net/novel/show.php?id=12831389\r\n            const link = item.querySelector('.imgbox a').href;\r\n            const id = parseInt(link.split('id=')[1]);\r\n            const bmkEl = item.querySelector('.bookmark-count');\r\n            let bmk = bmkEl ? parseInt(bmkEl.innerText) : 0;\r\n            const tags = [];\r\n            const tagsA = item.querySelectorAll('.tags>li>a');\r\n            for (const a of tagsA) {\r\n                tags.push(a.innerText.trim());\r\n            }\r\n            const userid = item.querySelector('img').dataset.userId;\r\n            // 有的作品没有收藏按钮，点进去之后发现这个作品已经被删除了，只是排行榜里没有及时更新。这样的作品没有收藏按钮。\r\n            const bookmarkBtn = item.querySelector('._one-click-bookmark');\r\n            const bookmarked = bookmarkBtn\r\n                ? bookmarkBtn.classList.contains('on')\r\n                : false;\r\n            const filterOpt = {\r\n                id: id,\r\n                illustType: 3,\r\n                tags: tags,\r\n                bookmarkCount: bmk,\r\n                bookmarkData: bookmarked,\r\n                userid: userid,\r\n            };\r\n            if (await filter.check(filterOpt)) {\r\n                store.setRankList(id.toString(), rank.toString());\r\n                store.idList.push({\r\n                    type: 'novels',\r\n                    id: id.toString(),\r\n                });\r\n            }\r\n        }\r\n        log.log(lang.transl('_排行榜进度', this.listPageFinished.toString()), 1, false);\r\n        // 抓取完毕\r\n        if (store.idList.length >= this.crawlNumber ||\r\n            this.listPageFinished === this.pageUrlList.length) {\r\n            this.getIdListFinished();\r\n        }\r\n        else {\r\n            // 继续抓取\r\n            this.getIdList();\r\n        }\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.pageUrlList = [];\r\n        this.listPageFinished = 0;\r\n    }\r\n}\r\nexport { InitRankingNovelPage };\r\n","// 初始化小说搜索页\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { options } from '../setting/Options';\r\nimport { filter } from '../Filter';\r\nimport { API } from '../API';\r\nimport { store } from '../Store';\r\nimport { log } from '../Log';\r\nimport { FastScreen } from '../FastScreen';\r\nimport { DOM } from '../DOM';\r\nimport { BookmarkAllWorks } from '../BookmarkAllWorks';\r\nclass InitSearchNovelPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.worksWrapSelector = '#root section>div>ul';\r\n        this.option = {};\r\n        this.worksNoPerPage = 24; // 每个页面有多少个作品\r\n        this.needCrawlPageCount = 0; // 一共有有多少个列表页面\r\n        this.sendCrawlTaskCount = 0; // 已经抓取了多少个列表页面\r\n        this.allOption = [\r\n            'order',\r\n            'type',\r\n            'wlt',\r\n            'wgt',\r\n            'hlt',\r\n            'hgt',\r\n            'ratio',\r\n            'tool',\r\n            's_mode',\r\n            'mode',\r\n            'scd',\r\n            'ecd',\r\n            'blt',\r\n            'bgt',\r\n            'tlt',\r\n            'tgt',\r\n            'original_only',\r\n            'work_lang',\r\n        ];\r\n        this.init();\r\n    }\r\n    initAny() {\r\n        new FastScreen();\r\n    }\r\n    addCrawlBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.green, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_开始抓取') + lang.transl('_默认下载多页')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    getWorksWrap() {\r\n        const test = document.querySelectorAll(this.worksWrapSelector);\r\n        if (test.length > 0) {\r\n            // 小说页面用这个选择器，只匹配到了一个 ul\r\n            return test[test.length - 1];\r\n        }\r\n        return null;\r\n    }\r\n    addAnyElement() {\r\n        // 添加收藏本页所有作品的功能\r\n        const bookmarkAllBtn = DOM.addBtn('otherBtns', Colors.green, lang.transl('_收藏本页面的所有作品'));\r\n        const bookmarkAll = new BookmarkAllWorks(bookmarkAllBtn);\r\n        bookmarkAllBtn.addEventListener('click', () => {\r\n            const listWrap = this.getWorksWrap();\r\n            if (listWrap) {\r\n                const list = document.querySelectorAll('#root section>div>ul>li');\r\n                const showList = Array.from(list).filter((el) => {\r\n                    return el.style.display !== 'none';\r\n                });\r\n                bookmarkAll.sendWorkList(showList);\r\n            }\r\n        });\r\n    }\r\n    setFormOption() {\r\n        // 个数/页数选项的提示\r\n        options.setWantPageTip({\r\n            text: lang.transl('_页数'),\r\n            tip: lang.transl('_从本页开始下载提示'),\r\n            rangTip: `1 - ${this.maxCount}`,\r\n        });\r\n    }\r\n    async nextStep() {\r\n        this.initFetchURL();\r\n        this.needCrawlPageCount = await this.calcNeedCrawlPageCount();\r\n        if (this.needCrawlPageCount === 0) {\r\n            return this.noResult();\r\n        }\r\n        this.startGetIdList();\r\n    }\r\n    getWantPage() {\r\n        this.crawlNumber = this.checkWantPageInput(lang.transl('_从本页开始下载x页'), lang.transl('_下载所有页面'));\r\n        if (this.crawlNumber === -1 || this.crawlNumber > this.maxCount) {\r\n            this.crawlNumber = this.maxCount;\r\n        }\r\n    }\r\n    // 获取搜索页的数据。因为有多处使用，所以进行了封装\r\n    async getSearchData(p) {\r\n        let data = await API.getNovelSearchData(store.tag, p, this.option);\r\n        return data.body.novel;\r\n    }\r\n    // 组织要请求的 url 中的参数\r\n    initFetchURL() {\r\n        let p = API.getURLSearchField(location.href, 'p');\r\n        this.startpageNo = parseInt(p) || 1;\r\n        // 从页面 url 中获取可以使用的选项\r\n        this.option = {};\r\n        this.allOption.forEach((param) => {\r\n            let value = API.getURLSearchField(location.href, param);\r\n            if (value !== '') {\r\n                this.option[param] = value;\r\n            }\r\n        });\r\n        // 如果没有指定搜索模式，则是精确匹配标签，设置对应的值\r\n        if (this.option.s_mode === undefined) {\r\n            this.option.s_mode = 's_tag_full';\r\n        }\r\n    }\r\n    // 计算应该抓取多少页\r\n    async calcNeedCrawlPageCount() {\r\n        let data = await this.getSearchData(1);\r\n        // 计算总页数\r\n        let pageCount = Math.ceil(data.total / this.worksNoPerPage);\r\n        if (pageCount > this.maxCount) {\r\n            // 最大为 1000\r\n            pageCount = this.maxCount;\r\n        }\r\n        // 计算从本页开始抓取的话，有多少页\r\n        let needFetchPage = pageCount - this.startpageNo + 1;\r\n        // 比较用户设置的页数，取较小的那个数值\r\n        if (needFetchPage < this.crawlNumber) {\r\n            return needFetchPage;\r\n        }\r\n        else {\r\n            return this.crawlNumber;\r\n        }\r\n    }\r\n    // 计算页数之后，准备建立并发抓取线程\r\n    startGetIdList() {\r\n        if (this.needCrawlPageCount <= this.ajaxThreadsDefault) {\r\n            this.ajaxThreads = this.needCrawlPageCount;\r\n        }\r\n        else {\r\n            this.ajaxThreads = this.ajaxThreadsDefault;\r\n        }\r\n        for (let i = 0; i < this.ajaxThreads; i++) {\r\n            this.getIdList();\r\n        }\r\n    }\r\n    // 仅当出错重试时，才会传递参数 p。此时直接使用传入的 p，而不是继续让 p 增加\r\n    async getIdList(p) {\r\n        if (p === undefined) {\r\n            p = this.startpageNo + this.sendCrawlTaskCount;\r\n            this.sendCrawlTaskCount++;\r\n        }\r\n        // 发起请求，获取列表页\r\n        let data;\r\n        try {\r\n            data = await this.getSearchData(p);\r\n        }\r\n        catch (_a) {\r\n            return this.getIdList(p);\r\n        }\r\n        data = data.data;\r\n        for (const nowData of data) {\r\n            const filterOpt = {\r\n                createDate: nowData.createDate,\r\n                id: nowData.id,\r\n                bookmarkData: nowData.bookmarkData,\r\n                bookmarkCount: nowData.bookmarkCount,\r\n                illustType: 3,\r\n                tags: nowData.tags,\r\n                userid: nowData.userId,\r\n            };\r\n            if (await filter.check(filterOpt)) {\r\n                store.idList.push({\r\n                    type: 'novels',\r\n                    id: nowData.id,\r\n                });\r\n            }\r\n        }\r\n        this.listPageFinished++;\r\n        log.log(lang.transl('_列表页抓取进度', this.listPageFinished.toString()), 1, false);\r\n        if (this.sendCrawlTaskCount + 1 <= this.needCrawlPageCount) {\r\n            // 继续发送抓取任务（+1 是因为 sendCrawlTaskCount 从 0 开始）\r\n            this.getIdList();\r\n        }\r\n        else {\r\n            // 抓取任务已经全部发送\r\n            if (this.listPageFinished === this.needCrawlPageCount) {\r\n                // 抓取任务全部完成\r\n                log.log(lang.transl('_列表页抓取完成'));\r\n                this.getIdListFinished();\r\n            }\r\n        }\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.listPageFinished = 0;\r\n        this.sendCrawlTaskCount = 0;\r\n    }\r\n    // 搜索页把下载任务按收藏数从高到低下载\r\n    sortResult() {\r\n        store.resultMeta.sort(API.sortByProperty('bmk'));\r\n        store.result.sort(API.sortByProperty('bmk'));\r\n    }\r\n}\r\nexport { InitSearchNovelPage };\r\n","import { API } from '../API';\r\nclass MakeEPUB {\r\n    constructor() { }\r\n    // epub 内部会使用标题 title 建立一个文件夹，把一些文件存放进去，所以这里要替换掉标题的特殊字符，特殊字符会导致这个文件夹名被截断，结果就是这个 epub 文件无法被解析。\r\n    make(data, content = '') {\r\n        return new Promise((resolve, reject) => {\r\n            content = content.replace(/\\n/g, '<br/>');\r\n            new EpubMaker()\r\n                .withTemplate('idpf-wasteland')\r\n                .withAuthor(API.replaceUnsafeStr(data.body.userName))\r\n                .withModificationDate(new Date(data.body.createDate))\r\n                .withRights({\r\n                description: data.body.description,\r\n                license: '',\r\n            })\r\n                .withAttributionUrl(`https://www.pixiv.net/novel/show.php?id=${data.body.id}`)\r\n                .withCover(data.body.coverUrl, {\r\n                license: '',\r\n                attributionUrl: '',\r\n            })\r\n                .withTitle(API.replaceUnsafeStr(data.body.title))\r\n                .withSection(new EpubMaker.Section('1', null, { content: content }, false, true))\r\n                .makeEpub()\r\n                .then((blob) => {\r\n                resolve(blob);\r\n            });\r\n        });\r\n    }\r\n}\r\nconst makeEPUB = new MakeEPUB();\r\nexport { makeEPUB };\r\n","import { makeEPUB } from './MakeEPUB';\r\nclass MakeNovelFile {\r\n    static async makeEPUB(novelData, text) {\r\n        return makeEPUB.make(novelData, text);\r\n    }\r\n    static makeTXT(content) {\r\n        // 替换换行标签，移除 html 标签\r\n        content = content.replace(/<br \\/>/g, '\\n').replace(/<\\/?.+?>/g, '');\r\n        return new Blob([content], {\r\n            type: 'text/plain',\r\n        });\r\n    }\r\n}\r\nexport { MakeNovelFile };\r\n","import { filter } from '../Filter';\r\nimport { store } from '../Store';\r\nimport { settings } from '../setting/Settings';\r\nimport { MakeNovelFile } from './MakeNovelFile';\r\n// 保存单个小说作品的数据\r\nclass SaveNovelData {\r\n    async save(data) {\r\n        // 小说没有 illustType 属性， 把小说的 illustType 设置为 3，这是为了方便检查\r\n        const illustType = 3;\r\n        // 获取需要检查的信息\r\n        const body = data.body;\r\n        const bmk = body.bookmarkCount; // 收藏数\r\n        const tagArr = body.tags.tags; // 取出 tag 信息\r\n        const tags = []; // 保存 tag 列表\r\n        // 小说的标签没有进行翻译，所以没有翻译后的标签\r\n        for (const tagData of tagArr) {\r\n            tags.push(tagData.tag);\r\n        }\r\n        const filterOpt = {\r\n            createDate: body.createDate,\r\n            id: body.id,\r\n            illustType: illustType,\r\n            tags: tags,\r\n            bookmarkCount: bmk,\r\n            bookmarkData: body.bookmarkData,\r\n            userid: body.userId,\r\n        };\r\n        // 检查通过\r\n        if (await filter.check(filterOpt)) {\r\n            const id = body.id;\r\n            const idNum = parseInt(id);\r\n            const title = body.title;\r\n            const userid = body.userId;\r\n            const user = body.userName;\r\n            const bookmarked = !!body.bookmarkData;\r\n            // 保存作品在排行榜上的编号\r\n            const rankData = store.getRankList(id);\r\n            const rank = rankData ? '#' + rankData : '';\r\n            const seriesTitle = body.seriesNavData ? body.seriesNavData.title : '';\r\n            const seriesOrder = body.seriesNavData\r\n                ? '#' + body.seriesNavData.order\r\n                : '';\r\n            let ext = settings.novelSaveAs;\r\n            let metaArr = [];\r\n            let meta = '';\r\n            if (settings.saveNovelMeta) {\r\n                const pageUrl = `https://www.pixiv.net/novel/show.php?id=${id}`;\r\n                const tagsA = [];\r\n                for (const tag of tags) {\r\n                    tagsA.push('#' + tag);\r\n                }\r\n                metaArr.push(title, user, pageUrl, body.description, tagsA.join('\\n'));\r\n                meta = metaArr.join('\\n\\n') + '\\n\\n\\n';\r\n            }\r\n            let content = this.replaceFlag(meta + body.content);\r\n            let blob;\r\n            if (ext === 'txt') {\r\n                blob = MakeNovelFile.makeTXT(content);\r\n            }\r\n            else {\r\n                // 创建 epub 文件，如果失败则回滚到 txt\r\n                try {\r\n                    blob = await MakeNovelFile.makeEPUB(data, content);\r\n                }\r\n                catch (_a) {\r\n                    ext = 'txt';\r\n                    blob = MakeNovelFile.makeTXT(content);\r\n                }\r\n            }\r\n            // 添加作品信息\r\n            store.addResult({\r\n                id: id,\r\n                idNum: idNum,\r\n                thumb: body.coverUrl || undefined,\r\n                dlCount: 1,\r\n                original: URL.createObjectURL(blob),\r\n                title: title,\r\n                tags: tags,\r\n                tagsWithTransl: tags,\r\n                tagsTranslOnly: tags,\r\n                user: user,\r\n                userId: userid,\r\n                ext: ext,\r\n                bmk: bmk,\r\n                bookmarked: bookmarked,\r\n                date: body.createDate,\r\n                type: illustType,\r\n                rank: rank,\r\n                seriesTitle: seriesTitle,\r\n                seriesOrder: seriesOrder,\r\n                novelBlob: blob,\r\n            });\r\n        }\r\n    }\r\n    // '[[jumpuri:予約ページ>https://www.amazon.co.jp/dp/4758092486]]'\r\n    // 替换成\r\n    // '予約ページ（https://www.amazon.co.jp/dp/4758092486）'\r\n    replaceJumpuri(str) {\r\n        let reg = /\\[\\[jumpuri:(.*?)>(.*?)\\]\\]/g;\r\n        let temp;\r\n        while ((temp = reg.exec(str))) {\r\n            str = str.replace(temp[0], `${temp[1].trim()}（${temp[2].trim()}）`);\r\n            reg.lastIndex = 0;\r\n        }\r\n        return str;\r\n    }\r\n    // > '[[rb:莉莉丝 > Lilith]]'\r\n    // 替换成\r\n    // '莉莉丝（Lilith）'\r\n    replaceRb(str) {\r\n        let reg = /\\[\\[rb:(.*?)>(.*?)\\]\\]/g;\r\n        let temp;\r\n        while ((temp = reg.exec(str))) {\r\n            str = str.replace(temp[0], `${temp[1].trim()}（${temp[2].trim()}）`);\r\n            reg.lastIndex = 0;\r\n        }\r\n        return str;\r\n    }\r\n    // > '[chapter:标题]'\r\n    // 替换成\r\n    // '标题'\r\n    replaceChapter(str) {\r\n        const reg = /\\[chapter:(.*?)\\]/g;\r\n        let temp;\r\n        while ((temp = reg.exec(str))) {\r\n            str = str.replace(temp[0], temp[1]);\r\n            reg.lastIndex = 0;\r\n        }\r\n        return str;\r\n    }\r\n    // > [pixivimage:70551567]\r\n    // 替换成\r\n    // [pixiv image link: <a href=\"http://pixiv.net/i/70551567\" target=\"_blank\">http://pixiv.net/i/70551567</a>]\r\n    replacePixivImage(str) {\r\n        let reg = /\\[pixivimage:(.*?)\\]/g;\r\n        let temp;\r\n        while ((temp = reg.exec(str))) {\r\n            const url = `http://pixiv.net/i/${temp[1].trim()}`;\r\n            str = str.replace(temp[0], `[pixiv image link: <a href=\"${url}\" target=\"_blank\">${url}</a>]`);\r\n            reg.lastIndex = 0;\r\n        }\r\n        return str;\r\n    }\r\n    // 对小说里的一些标记进行替换\r\n    replaceFlag(str) {\r\n        str = str.replace(/\\[newpage\\]/g, '');\r\n        str = this.replaceJumpuri(str);\r\n        str = str.replace(/\\[jump:.*?\\]/g, '');\r\n        str = this.replaceRb(str);\r\n        str = this.replaceChapter(str);\r\n        str = this.replacePixivImage(str);\r\n        return str;\r\n    }\r\n}\r\nconst saveNovelData = new SaveNovelData();\r\nexport { saveNovelData };\r\n","import { EVT } from '../EVT';\r\nimport { lang } from '../Lang';\r\nimport { store } from '../Store';\r\nimport { DOM } from '../DOM';\r\nimport config from '../Config';\r\nimport { theme } from '../Theme';\r\n// 输出面板\r\nclass OutputPanel {\r\n    constructor() {\r\n        this.addOutPutPanel();\r\n        theme.register(this.outputPanel);\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        this.closeBtn.addEventListener('click', () => {\r\n            this.close();\r\n        });\r\n        this.outputPanel.addEventListener('click', (e) => {\r\n            const ev = e || window.event;\r\n            ev.stopPropagation();\r\n        });\r\n        document.addEventListener('click', () => {\r\n            if (this.outputPanel.style.display !== 'none') {\r\n                this.close();\r\n            }\r\n        });\r\n        window.addEventListener(EVT.list.closeCenterPanel, () => {\r\n            this.close();\r\n        });\r\n        // 复制输出内容\r\n        this.copyBtn.addEventListener('click', () => {\r\n            const range = document.createRange();\r\n            range.selectNodeContents(this.outputContent);\r\n            window.getSelection().removeAllRanges();\r\n            window.getSelection().addRange(range);\r\n            document.execCommand('copy');\r\n            // 改变提示文字\r\n            this.copyBtn.textContent = lang.transl('_已复制到剪贴板');\r\n            setTimeout(() => {\r\n                window.getSelection().removeAllRanges();\r\n                this.copyBtn.textContent = lang.transl('_复制');\r\n            }, 1000);\r\n        });\r\n        window.addEventListener(EVT.list.output, (ev) => {\r\n            this.output(ev.detail.data.content, ev.detail.data.title);\r\n        });\r\n    }\r\n    addOutPutPanel() {\r\n        const html = `\n    <div class=\"outputWrap\">\n    <div class=\"outputClose\" title=\"${lang.transl('_关闭')}\">×</div>\n    <div class=\"outputTitle\">${lang.transl('_输出信息')}</div>\n    <div class=\"outputContent beautify_scrollbar\"></div>\n    <div class=\"outputFooter\">\n    <button class=\"outputCopy\" title=\"\">${lang.transl('_复制')}</button>\n    </div>\n    </div>\n    `;\r\n        document.body.insertAdjacentHTML('beforeend', html);\r\n        this.outputPanel = document.querySelector('.outputWrap');\r\n        this.outputTitle = this.outputPanel.querySelector('.outputTitle');\r\n        this.outputContent = this.outputPanel.querySelector('.outputContent');\r\n        this.copyBtn = this.outputPanel.querySelector('.outputCopy');\r\n        this.closeBtn = this.outputPanel.querySelector('.outputClose');\r\n    }\r\n    // 输出内容\r\n    output(content, title = lang.transl('_输出信息')) {\r\n        // 如果结果较多，则不直接输出，改为保存 txt 文件\r\n        if (store.result.length > config.outputMax) {\r\n            const con = content.replace(/<br>/g, '\\n'); // 替换换行符\r\n            const file = new Blob([con], {\r\n                type: 'text/plain',\r\n            });\r\n            const url = URL.createObjectURL(file);\r\n            const fileName = new Date().toLocaleString() + '.txt';\r\n            DOM.downloadFile(url, fileName);\r\n            // 禁用复制按钮\r\n            this.copyBtn.disabled = true;\r\n            content = lang.transl('_输出内容太多已经为你保存到文件');\r\n        }\r\n        else {\r\n            this.copyBtn.disabled = false;\r\n        }\r\n        if (content) {\r\n            this.outputContent.innerHTML = content;\r\n            this.outputPanel.style.display = 'block';\r\n            this.outputTitle.textContent = title;\r\n        }\r\n    }\r\n    // 关闭输出面板\r\n    close() {\r\n        this.outputPanel.style.display = 'none';\r\n        this.outputContent.innerHTML = '';\r\n    }\r\n}\r\nnew OutputPanel();\r\n","import { store } from '../Store';\r\nimport { EVT } from '../EVT';\r\nimport { fileName } from '../FileName';\r\nimport { lang } from '../Lang';\r\nimport config from '../Config';\r\n// 预览文件名\r\nclass PreviewFileName {\r\n    constructor() {\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        window.addEventListener(EVT.list.previewFileName, () => {\r\n            this.previewFileName();\r\n        });\r\n    }\r\n    previewFileName() {\r\n        if (store.result.length === 0) {\r\n            EVT.sendMsg({\r\n                msg: lang.transl('_没有数据可供使用'),\r\n                type: 'error',\r\n            });\r\n            return;\r\n        }\r\n        // 使用数组储存和拼接字符串，提高性能\r\n        const resultArr = [];\r\n        const length = store.result.length;\r\n        for (let i = 0; i < length; i++) {\r\n            const data = store.result[i];\r\n            // 为默认文件名添加颜色。默认文件名有两种处理方式，一种是取出用其他下载软件下载后的默认文件名，一种是取出本程序使用的默认文件名 data.id。这里使用前者，方便用户用其他下载软件下载后，再用生成的文件名重命名。\r\n            const defaultName = data.original.replace(/.*\\//, '');\r\n            const fullName = fileName.getFileName(data);\r\n            let nowResult = `${defaultName}: ${fullName}<br>`;\r\n            if (length < config.outputMax) {\r\n                // 为生成的文件名添加颜色。只有当文件数量少于一定数值时才添加颜色。这是因为添加颜色会导致生成的 HTML 元素数量增多，复制时资源占用增加。有些用户电脑配置差，如果生成的结果很多，还添加了颜色，可能复制时会导致这个页面卡死。\r\n                const defaultNameHtml = `<span class=\"color999\">${defaultName}</span>`;\r\n                const part = fullName.split('/');\r\n                const length = part.length;\r\n                for (let i = 0; i < length; i++) {\r\n                    const str = part[i];\r\n                    if (i < length - 1) {\r\n                        // 如果不是最后一项，说明是文件夹名，添加颜色\r\n                        part[i] = `<span class=\"color666\">${str}</span>`;\r\n                    }\r\n                    else {\r\n                        // 最后一项，是文件名，添加颜色\r\n                        part[i] = `<span class=\"color000\">${str}</span>`;\r\n                    }\r\n                }\r\n                const fullNameHtml = part.join('/');\r\n                nowResult = `<p class=\"result\">${defaultNameHtml}: ${fullNameHtml}</p>`;\r\n            }\r\n            // 保存本条结果\r\n            resultArr.push(nowResult);\r\n        }\r\n        // 拼接所有结果\r\n        const result = resultArr.join('');\r\n        EVT.fire(EVT.list.output, {\r\n            content: result,\r\n            title: lang.transl('_预览文件名'),\r\n        });\r\n    }\r\n}\r\nnew PreviewFileName();\r\n","import { store } from '../Store';\r\nimport { EVT } from '../EVT';\r\nimport { lang } from '../Lang';\r\nimport { settings } from '../setting/Settings';\r\n// 显示 url\r\nclass ShowURLs {\r\n    constructor() {\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        window.addEventListener(EVT.list.showURLs, () => {\r\n            this.showURLs();\r\n        });\r\n    }\r\n    showURLs() {\r\n        if (store.result.length === 0) {\r\n            EVT.sendMsg({\r\n                msg: lang.transl('_没有数据可供使用'),\r\n                type: 'error',\r\n            });\r\n            return;\r\n        }\r\n        const urls = [];\r\n        const size = settings.imageSize;\r\n        for (const result of store.result) {\r\n            urls.push(result[size]);\r\n        }\r\n        EVT.fire(EVT.list.output, {\r\n            content: urls.join('<br>'),\r\n            title: lang.transl('_复制url'),\r\n        });\r\n    }\r\n}\r\nnew ShowURLs();\r\n","import { EVT } from '../EVT';\r\nimport { DOM } from '../DOM';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport formHtml from './FormHTML';\r\nimport { SaveNamingRule } from './SaveNamingRule';\r\nimport { theme } from '../Theme';\r\nimport { FormSettings } from './FormSettings';\r\n// 设置表单\r\nclass Form {\r\n    constructor() {\r\n        this.activeClass = 'active';\r\n        this.chooseKeys = ['Enter', 'NumpadEnter']; // 让回车键可以控制复选框（浏览器默认只支持空格键）\r\n        this.form = DOM.useSlot('form', formHtml);\r\n        theme.register(this.form);\r\n        this.allCheckBox = this.form.querySelectorAll('input[type=\"checkbox\"]');\r\n        this.allRadio = this.form.querySelectorAll('input[type=\"radio\"]');\r\n        this.allSwitch = this.form.querySelectorAll('.checkbox_switch');\r\n        this.allLabel = this.form.querySelectorAll('label');\r\n        this.allTabTitle = this.form.querySelectorAll('.tabsTitle .title');\r\n        this.allTabCon = this.form.querySelectorAll('.tabsContnet .con');\r\n        this.bindEvents();\r\n        new SaveNamingRule(this.form.userSetName);\r\n        new FormSettings(this.form);\r\n        this.initFormBueatiful();\r\n        // 激活第一个选项卡\r\n        this.activeTab(0);\r\n    }\r\n    // 设置表单上美化元素的状态\r\n    initFormBueatiful() {\r\n        // 设置改变时，重设 label 激活状态\r\n        this.resetLabelActive();\r\n        // 重设该选项的子选项的显示/隐藏\r\n        this.resetSubOptionDisplay();\r\n    }\r\n    // 设置激活的选项卡\r\n    activeTab(no = 0) {\r\n        for (const title of this.allTabTitle) {\r\n            title.classList.remove(this.activeClass);\r\n        }\r\n        this.allTabTitle[no].classList.add(this.activeClass);\r\n        for (const con of this.allTabCon) {\r\n            con.style.display = 'none';\r\n        }\r\n        this.allTabCon[no].style.display = 'block';\r\n    }\r\n    bindEvents() {\r\n        // 给美化的复选框绑定功能\r\n        for (const checkbox of this.allCheckBox) {\r\n            this.bindCheckboxEvent(checkbox);\r\n        }\r\n        // 给美化的单选按钮绑定功能\r\n        for (const radio of this.allRadio) {\r\n            this.bindRadioEvent(radio);\r\n        }\r\n        // 设置发生改变时，重新设置美化状态\r\n        window.addEventListener(EVT.list.settingChange, () => {\r\n            this.initFormBueatiful();\r\n        });\r\n        window.addEventListener(EVT.list.resetSettings, () => {\r\n            this.form.reset();\r\n        });\r\n        // 在选项卡的标题上触发事件时，激活对应的选项卡\r\n        for (let index = 0; index < this.allTabTitle.length; index++) {\r\n            ;\r\n            ['click', 'mouseenter'].forEach((name) => {\r\n                this.allTabTitle[index].addEventListener(name, () => {\r\n                    this.activeTab(index);\r\n                });\r\n            });\r\n        }\r\n        // 当可以开始下载时，切换到“下载”选项卡\r\n        for (const ev of [\r\n            EVT.list.crawlFinish,\r\n            EVT.list.resultChange,\r\n            EVT.list.resume,\r\n        ]) {\r\n            window.addEventListener(ev, () => {\r\n                this.activeTab(1);\r\n            });\r\n        }\r\n        window.addEventListener(EVT.list.crawlEmpty, () => {\r\n            this.activeTab(0);\r\n        });\r\n        // 预览文件名\r\n        DOM.addBtn('namingBtns', Colors.green, lang.transl('_预览文件名')).addEventListener('click', () => {\r\n            EVT.fire(EVT.list.previewFileName);\r\n        }, false);\r\n        // 导出 csv\r\n        DOM.addBtn('namingBtns', Colors.green, lang.transl('_导出csv')).addEventListener('click', () => {\r\n            EVT.fire(EVT.list.outputCSV);\r\n        }, false);\r\n        // 导出抓取结果\r\n        DOM.addBtn('namingBtns', Colors.green, lang.transl('_导出抓取结果')).addEventListener('click', () => {\r\n            EVT.fire(EVT.list.outputResult);\r\n        }, false);\r\n        // 重置设置按钮\r\n        {\r\n            const el = this.form.querySelector('#resetSettings');\r\n            if (el) {\r\n                el.addEventListener('click', () => {\r\n                    const result = window.confirm(lang.transl('_是否重置设置'));\r\n                    if (result) {\r\n                        EVT.fire(EVT.list.resetSettings);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        // 导出设置按钮\r\n        {\r\n            const el = this.form.querySelector('#exportSettings');\r\n            if (el) {\r\n                el.addEventListener('click', () => {\r\n                    EVT.fire(EVT.list.exportSettings);\r\n                });\r\n            }\r\n        }\r\n        // 导入设置按钮\r\n        {\r\n            const el = this.form.querySelector('#importSettings');\r\n            if (el) {\r\n                el.addEventListener('click', () => {\r\n                    EVT.fire(EVT.list.importSettings);\r\n                });\r\n            }\r\n        }\r\n        // 显示命名字段提示\r\n        this.form\r\n            .querySelector('.showFileNameTip')\r\n            .addEventListener('click', () => DOM.toggleEl(document.querySelector('.fileNameTip')));\r\n        // 显示日期格式提示\r\n        this.form\r\n            .querySelector('.showDateTip')\r\n            .addEventListener('click', () => DOM.toggleEl(document.querySelector('.dateFormatTip')));\r\n        // 输入框获得焦点时自动选择文本（文件名输入框例外）\r\n        const centerInputs = this.form.querySelectorAll('input[type=text]');\r\n        for (const el of centerInputs) {\r\n            if (el.name !== 'userSetName') {\r\n                el.addEventListener('focus', function () {\r\n                    this.select();\r\n                });\r\n            }\r\n        }\r\n        // 把下拉框的选择项插入到文本框里\r\n        this.insertValueToInput(this.form.fileNameSelect, this.form.userSetName);\r\n    }\r\n    // 把下拉框的选择项插入到文本框里\r\n    insertValueToInput(from, to) {\r\n        from.addEventListener('change', () => {\r\n            if (from.value !== 'default') {\r\n                // 把选择项插入到光标位置,并设置新的光标位置\r\n                const position = to.selectionStart;\r\n                to.value =\r\n                    to.value.substr(0, position) +\r\n                        from.value +\r\n                        to.value.substr(position, to.value.length);\r\n                to.selectionStart = position + from.value.length;\r\n                to.selectionEnd = position + from.value.length;\r\n                to.focus();\r\n            }\r\n        });\r\n    }\r\n    // 设置复选框的事件\r\n    bindCheckboxEvent(el) {\r\n        // 让复选框支持用回车键选择\r\n        el.addEventListener('keydown', (event) => {\r\n            if (this.chooseKeys.includes(event.code)) {\r\n                el.click();\r\n            }\r\n        });\r\n        // 点击美化按钮，点击对应的复选框\r\n        el.nextElementSibling.addEventListener('click', () => {\r\n            el.click();\r\n        });\r\n        // 点击它的 label 时，不需要传递它的值。因为点击 lable 激活这个 input 控件时，浏览器会自动触发这个控件的 click 事件。settings 模块已经监听了 click 事件，所以这里就不要监听 label 了，否则就会因此多触发了一次 settingChange 事件。而且点击 label 时获得的值还是改变之前的旧的值。\r\n    }\r\n    // 设置单选控件的事件\r\n    bindRadioEvent(el) {\r\n        // 点击美化按钮，选择对应的单选框\r\n        el.nextElementSibling.addEventListener('click', () => {\r\n            el.click();\r\n        });\r\n        // 点击它的 label 时，不需要传递它的值。原因同上。\r\n    }\r\n    // 重设 label 的激活状态\r\n    resetLabelActive() {\r\n        // 设置复选框的 label 的激活状态\r\n        for (const checkbox of this.allCheckBox) {\r\n            this.setLabelActive(checkbox);\r\n        }\r\n        // 设置单选按钮的 label 的激活状态\r\n        for (const radio of this.allRadio) {\r\n            this.setLabelActive(radio);\r\n        }\r\n    }\r\n    // 设置 input 元素对应的 label 的激活状态\r\n    setLabelActive(input) {\r\n        const label = this.form.querySelector(`label[for=\"${input.id}\"]`);\r\n        if (label) {\r\n            const method = input.checked ? 'add' : 'remove';\r\n            label.classList[method]('active');\r\n        }\r\n    }\r\n    // 重设子选项的显示/隐藏\r\n    resetSubOptionDisplay() {\r\n        for (const _switch of this.allSwitch) {\r\n            const subOption = this.form.querySelector(`.subOptionWrap[data-show=\"${_switch.name}\"]`);\r\n            if (subOption) {\r\n                subOption.style.display = _switch.checked ? 'inline' : 'none';\r\n            }\r\n        }\r\n    }\r\n}\r\nconst form = new Form().form;\r\nexport { form };\r\n","import { lang } from '../Lang';\r\nconst formHtml = `<form class=\"settingForm\">\n  <div class=\"tabsTitle\">\n    <div class=\"title\">${lang.transl('_抓取')}</div>\n    <div class=\"title\">${lang.transl('_下载')}</div>\n    <div class=\"title\">${lang.transl('_其他')}</div>\n  </div>\n  <div class=\"tabsContnet\">\n    <div class=\"con\">\n      <p class=\"option\" data-no=\"1\">\n      <span class=\"setWantPageWrap\">\n      <span class=\"has_tip settingNameStyle1 setWantPageTip1\" data-tip=\"${lang.transl('_页数')}\" style=\"margin-right: 0px;\">${lang.transl('_页数')}</span>\n      <span class=\"gray1\" style=\"margin-right: 10px;\"> ? </span>\n      <input type=\"text\" name=\"setWantPage\" class=\"setinput_style1 blue setWantPage\"\n      value = '-1'>\n      &nbsp;&nbsp;&nbsp;\n      <span class=\"setWantPageTip2 gray1\">-1 或者大于 0 的数字</span>\n      </span>\n      </p>\n\n      <p class=\"option\" data-no=\"2\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_下载作品类型的提示')}\">${lang.transl('_下载作品类型')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"downType0\" id=\"setWorkType0\" class=\"need_beautify checkbox_common\" checked>\n      <span class=\"beautify_checkbox\"></span>\n      <label for=\"setWorkType0\"> ${lang.transl('_插画')}&nbsp;</label>\n      <input type=\"checkbox\" name=\"downType1\" id=\"setWorkType1\" class=\"need_beautify checkbox_common\" checked>\n      <span class=\"beautify_checkbox\"></span>\n      <label for=\"setWorkType1\"> ${lang.transl('_漫画')}&nbsp;</label>\n      <input type=\"checkbox\" name=\"downType2\" id=\"setWorkType2\" class=\"need_beautify checkbox_common\" checked>\n      <span class=\"beautify_checkbox\"></span>\n      <label for=\"setWorkType2\"> ${lang.transl('_动图')}&nbsp;</label>\n      <input type=\"checkbox\" name=\"downType3\" id=\"setWorkType3\" class=\"need_beautify checkbox_common\" checked>\n      <span class=\"beautify_checkbox\"></span>\n      <label for=\"setWorkType3\"> ${lang.transl('_小说')}&nbsp;</label>\n      </p>\n\n      <p class=\"option\" data-no=\"21\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_下载作品类型的提示')}\">${lang.transl('_下载作品类型')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"downSingleImg\" id=\"setDownSingleImg\" class=\"need_beautify checkbox_common\" checked>\n      <span class=\"beautify_checkbox\"></span>\n      <label for=\"setDownSingleImg\"> ${lang.transl('_单图作品')}&nbsp;</label>\n      <input type=\"checkbox\" name=\"downMultiImg\" id=\"setDownMultiImg\" class=\"need_beautify checkbox_common\" checked>\n      <span class=\"beautify_checkbox\"></span>\n      <label for=\"setDownMultiImg\"> ${lang.transl('_多图作品')}&nbsp;</label>\n      </p>\n\n      <p class=\"option\" data-no=\"23\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_下载作品类型的提示')}\">${lang.transl('_下载作品类型')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"downColorImg\" id=\"setDownColorImg\" class=\"need_beautify checkbox_common\" checked>\n      <span class=\"beautify_checkbox\"></span>\n      <label for=\"setDownColorImg\"> ${lang.transl('_彩色图片')}&nbsp;</label>\n      <input type=\"checkbox\" name=\"downBlackWhiteImg\" id=\"setDownBlackWhiteImg\" class=\"need_beautify checkbox_common\" checked>\n      <span class=\"beautify_checkbox\"></span>\n      <label for=\"setDownBlackWhiteImg\"> ${lang.transl('_黑白图片')}&nbsp;</label>\n      </p>\n\n      <p class=\"option\" data-no=\"3\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_怎样下载多图作品')}\">${lang.transl('_多图下载设置')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"firstFewImagesSwitch\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"firstFewImagesSwitch\">\n      ${lang.transl('_下载前几张图片')}&nbsp;\n      <input type=\"text\" name=\"firstFewImages\" class=\"setinput_style1 blue\" value=\"1\">\n      </span>\n      </p>\n\n      <p class=\"option\" data-no=\"6\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_只下载已收藏的提示')}\">${lang.transl('_只下载已收藏')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"setOnlyBmk\" id=\"setOnlyBmk\" class=\"need_beautify checkbox_switch\"> \n      <span class=\"beautify_switch\"></span>\n      </p>\n\n      <p class=\"option\" data-no=\"5\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_设置收藏数量的提示')}\">${lang.transl('_设置收藏数量')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"BMKNumSwitch\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"BMKNumSwitch\">\n      <span>${lang.transl('_最小值')}&nbsp;</span>\n      <input type=\"text\" name=\"BMKNumMin\" class=\"setinput_style1 blue bmkNum\" value=\"0\">\n      <span>${lang.transl('_最大值')}&nbsp;</span>\n      <input type=\"text\" name=\"BMKNumMax\" class=\"setinput_style1 blue bmkNum\" value=\"0\">\n      </span>\n      </p>\n\n      <p class=\"option\" data-no=\"7\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_筛选宽高的按钮Title')} ${lang.transl('_筛选宽高的提示文字')}\">${lang.transl('_筛选宽高的按钮文字')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"setWHSwitch\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"setWHSwitch\">\n\n      <input type=\"radio\" name=\"widthHeightLimit\" id=\"widthHeightLimit1\" class=\"need_beautify radio\" value=\">=\" checked>\n      <span class=\"beautify_radio\"></span>\n      <label for=\"widthHeightLimit1\">&gt;=&nbsp;</label>\n\n      <input type=\"radio\" name=\"widthHeightLimit\" id=\"widthHeightLimit2\" class=\"need_beautify radio\" value=\"=\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"widthHeightLimit2\">=&nbsp;</label>\n      \n      <input type=\"radio\" name=\"widthHeightLimit\" id=\"widthHeightLimit3\" class=\"need_beautify radio\" value=\"<=\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"widthHeightLimit3\">&lt;=&nbsp;</label>\n\n      <input type=\"text\" name=\"setWidth\" class=\"setinput_style1 blue\" value=\"0\">\n      <input type=\"radio\" name=\"setWidthAndOr\" id=\"setWidth_AndOr1\" class=\"need_beautify radio\" value=\"&\" checked>\n      <span class=\"beautify_radio\"></span>\n      <label for=\"setWidth_AndOr1\">and&nbsp;</label>\n      <input type=\"radio\" name=\"setWidthAndOr\" id=\"setWidth_AndOr2\" class=\"need_beautify radio\" value=\"|\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"setWidth_AndOr2\">or&nbsp;</label>\n      <input type=\"text\" name=\"setHeight\" class=\"setinput_style1 blue\" value=\"0\">\n      </span>\n      </p>\n\n      <p class=\"option\" data-no=\"8\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_设置宽高比例Title')}\">${lang.transl('_设置宽高比例')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"ratioSwitch\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"ratioSwitch\">\n      <input type=\"radio\" name=\"ratio\" id=\"ratio1\" class=\"need_beautify radio\" value=\"1\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"ratio1\"> ${lang.transl('_横图')}&nbsp; </label>\n      <input type=\"radio\" name=\"ratio\" id=\"ratio2\" class=\"need_beautify radio\" value=\"2\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"ratio2\"> ${lang.transl('_竖图')}&nbsp; </label>\n      <input type=\"radio\" name=\"ratio\" id=\"ratio3\" class=\"need_beautify radio\" value=\"3\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"ratio3\"> ${lang.transl('_输入宽高比')}</label>\n      <input type=\"text\" name=\"userRatio\" class=\"setinput_style1 blue\" value=\"\">\n      </span>\n      </p>\n\n      <p class=\"option\" data-no=\"9\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_设置id范围提示')}\">${lang.transl('_设置id范围')}&nbsp;&nbsp; <span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"idRangeSwitch\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"idRangeSwitch\">\n      <input type=\"radio\" name=\"idRange\" id=\"idRange1\" class=\"need_beautify radio\" value=\"1\" checked>\n      <span class=\"beautify_radio\"></span>\n      <label for=\"idRange1\">  ${lang.transl('_大于')}&nbsp; </label>\n      <input type=\"radio\" name=\"idRange\" id=\"idRange2\" class=\"need_beautify radio\" value=\"2\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"idRange2\">  ${lang.transl('_小于')}&nbsp; </label>\n      <input type=\"text\" name=\"idRangeInput\" class=\"setinput_style1 w100 blue\" value=\"\">\n      </span>\n      </p>\n\n      <p class=\"option\" data-no=\"10\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_设置投稿时间提示')}\">${lang.transl('_设置投稿时间')} <span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"postDate\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"postDate\">\n      <input type=\"datetime-local\" name=\"postDateStart\" placeholder=\"yyyy-MM-dd HH:mm\" class=\"setinput_style1 postDate blue\" value=\"\">\n      &nbsp;-&nbsp;\n      <input type=\"datetime-local\" name=\"postDateEnd\" placeholder=\"yyyy-MM-dd HH:mm\" class=\"setinput_style1 postDate blue\" value=\"\">\n      </span>\n      </p>\n\n      <p class=\"option\" data-no=\"11\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_必须tag的提示文字')}\">${lang.transl('_必须含有tag')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"needTagSwitch\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"needTagSwitch\">\n      <input type=\"radio\" name=\"needTagMode\" id=\"needTagMode1\" class=\"need_beautify radio\" value=\"all\" checked>\n      <span class=\"beautify_radio\"></span>\n      <label for=\"needTagMode1\">  ${lang.transl('_全部')}&nbsp; </label>\n      <input type=\"radio\" name=\"needTagMode\" id=\"needTagMode2\" class=\"need_beautify radio\" value=\"one\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"needTagMode2\">  ${lang.transl('_任一')}&nbsp; </label>\n      <input type=\"text\" name=\"needTag\" class=\"setinput_style1 blue setinput_tag\">\n      </span>\n      </p>\n\n      <p class=\"option\" data-no=\"12\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_排除tag的提示文字')}\">${lang.transl('_不能含有tag')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"notNeedTagSwitch\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"notNeedTagSwitch\">\n      <input type=\"text\" name=\"notNeedTag\" class=\"setinput_style1 blue setinput_tag\">\n      </span>\n      </p>\n\n      <slot data-name=\"crawlBtns\" class=\"centerWrap_btns\"></slot>\n    </div>\n    <div class=\"con\">\n    <p class=\"option\" data-no=\"13\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_设置文件夹名的提示')}\">${lang.transl('_命名规则')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"text\" name=\"userSetName\" class=\"setinput_style1 blue fileNameRule\" value=\"{id}\">\n      <select name=\"fileNameSelect\">\n        <option value=\"default\">…</option>\n        <option value=\"{id}\">{id}</option>\n        <option value=\"{user}\">{user}</option>\n        <option value=\"{user_id}\">{user_id}</option>\n        <option value=\"{title}\">{title}</option>\n        <option value=\"{p_title}\">{p_title}</option>\n        <option value=\"{tags}\">{tags}</option>\n        <option value=\"{tags_translate}\">{tags_translate}</option>\n        <option value=\"{tags_transl_only}\">{tags_transl_only}</option>\n        <option value=\"{p_tag}\">{p_tag}</option>\n        <option value=\"{type}\">{type}</option>\n        <option value=\"{bmk}\">{bmk}</option>\n        <option value=\"{rank}\">{rank}</option>\n        <option value=\"{date}\">{date}</option>\n        <option value=\"{task_date}\">{task_date}</option>\n        <option value=\"{px}\">{px}</option>\n        <option value=\"{series_title}\">{series_title}</option>\n        <option value=\"{series_order}\">{series_order}</option>\n        <option value=\"{id_num}\">{id_num}</option>\n        <option value=\"{p_num}\">{p_num}</option>\n        </select>\n      &nbsp;\n      <slot data-name=\"saveNamingRule\" class=\"\"></slot>\n      <button class=\"showFileNameTip textButton\" type=\"button\">?</button>\n      </p>\n      <p class=\"fileNameTip tip\">\n      <strong>${lang\r\n    .transl('_设置文件夹名的提示')\r\n    .replace('<br>', '. ')}</strong>\n      <br>\n      ${lang.transl('_命名标记提醒')}\n      <br>\n      <span class=\"blue\">{id}</span>\n      ${lang.transl('_命名标记id')}\n      <br>\n      <span class=\"blue\">{user}</span>\n      ${lang.transl('_命名标记user')}\n      <br>\n      <span class=\"blue\">{user_id}</span>\n      ${lang.transl('_命名标记userid')}\n      <br>\n      <span class=\"blue\">{title}</span>\n      ${lang.transl('_命名标记title')}\n      <br>\n      <span class=\"blue\">{p_title}</span>\n      ${lang.transl('_文件夹标记PTitle')}\n      <br>\n      <span class=\"blue\">{tags}</span>\n      ${lang.transl('_命名标记tags')}\n      <br>\n      <span class=\"blue\">{tags_translate}</span>\n      ${lang.transl('_命名标记tags_trans')}\n      <br>\n      <span class=\"blue\">{tags_transl_only}</span>\n      ${lang.transl('_命名标记tags_transl_only')}\n      <br>\n      <span class=\"blue\">{p_tag}</span>\n      ${lang.transl('_文件夹标记PTag')}\n      <br>\n      <span class=\"blue\">{type}</span>\n      ${lang.transl('_命名标记type')}\n      <br>\n      <span class=\"blue\">{bmk}</span>\n      ${lang.transl('_命名标记bmk')}\n      <br>\n      <span class=\"blue\">{rank}</span>\n      ${lang.transl('_命名标记rank')}\n      <br>\n      <span class=\"blue\">{date}</span>\n      ${lang.transl('_命名标记date')}\n      <br>\n      <span class=\"blue\">{task_date}</span>\n      ${lang.transl('_命名标记taskDate')}\n      <br>\n      <span class=\"blue\">{px}</span>\n      ${lang.transl('_命名标记px')}\n      <br>\n      <span class=\"blue\">{series_title}</span>\n      ${lang.transl('_命名标记seriesTitle')}\n      <br>\n      <span class=\"blue\">{series_order}</span>\n      ${lang.transl('_命名标记seriesOrder')}\n      <br>\n      <span class=\"blue\">{id_num}</span>\n      ${lang.transl('_命名标记id_num')}\n      <br>\n      <span class=\"blue\">{p_num}</span>\n      ${lang.transl('_命名标记p_num')}\n      </p>\n\n      <p class=\"option\" data-no=\"29\">\n      <span class=\"settingNameStyle1\">${lang.transl('_文件名长度限制')}<span class=\"gray1\"> </span></span>\n      <input type=\"checkbox\" name=\"fileNameLengthLimitSwitch\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"fileNameLengthLimitSwitch\">\n      <input type=\"text\" name=\"fileNameLengthLimit\" class=\"setinput_style1 blue\" value=\"200\">\n      </span>\n      </p>\n\n      <p class=\"option\" data-no=\"14\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_添加字段名称提示')}\">${lang.transl('_添加命名标记前缀')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"tagNameToFileName\" id=\"setTagNameToFileName\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      </p>\n      <p class=\"option\" data-no=\"22\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_第一张图不带序号说明')}\">${lang.transl('_第一张图不带序号')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"noSerialNo\" id=\"setNoSerialNo\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      </p>\n      <p class=\"option\" data-no=\"19\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_多图建立目录提示')}\">${lang.transl('_多图建立目录')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"multipleImageDir\" id=\"setMultipleImageDir\" class=\"need_beautify checkbox_switch\" >\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"multipleImageDir\">\n      <span>${lang.transl('_目录名使用')}</span>\n      <input type=\"radio\" name=\"multipleImageFolderName\" id=\"multipleImageFolderName1\" class=\"need_beautify radio\" value=\"1\" checked>\n      <span class=\"beautify_radio\"></span>\n      <label for=\"multipleImageFolderName1\"> ID&nbsp; </label>\n      <input type=\"radio\" name=\"multipleImageFolderName\" id=\"multipleImageFolderName2\" class=\"need_beautify radio\" value=\"2\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"multipleImageFolderName2\"> ${lang.transl('_命名规则')}&nbsp; </label>\n      </span>\n      </p>\n\n      <p class=\"option\" data-no=\"15\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_快速下载建立文件夹提示')}\">${lang.transl('_快速下载建立文件夹')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"alwaysFolder\" id=\"setAlwaysFolder\" class=\"need_beautify checkbox_switch\" >\n      <span class=\"beautify_switch\"></span>\n      </p>\n\n      <slot data-name=\"namingBtns\" class=\"centerWrap_btns\"></slot>\n\n      <p class=\"option\" data-no=\"16\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_线程数字')}\">${lang.transl('_设置下载线程')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"text\" name=\"downloadThread\" class=\"setinput_style1 blue\" value=\"5\">\n      </p>\n\n      <p class=\"option\" data-no=\"17\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_快速下载的提示')}\">${lang.transl('_自动开始下载')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"quietDownload\" id=\"setQuietDownload\" class=\"need_beautify checkbox_switch\" checked>\n      <span class=\"beautify_switch\"></span>\n      </p>\n\n      <slot data-name=\"downloadArea\"></slot>\n      <slot data-name=\"progressBar\"></slot>\n    </div>\n    \n    <div class=\"con\">\n\n      <p class=\"option\" data-no=\"4\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_动图保存格式title')}\">${lang.transl('_动图保存格式')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"radio\" name=\"ugoiraSaveAs\" id=\"ugoiraSaveAs1\" class=\"need_beautify radio\" value=\"webm\" checked>\n      <span class=\"beautify_radio\"></span>\n      <label for=\"ugoiraSaveAs1\"> ${lang.transl('_webmVideo')} &nbsp;</label>\n      <input type=\"radio\" name=\"ugoiraSaveAs\" id=\"ugoiraSaveAs3\" class=\"need_beautify radio\" value=\"gif\"> \n      <span class=\"beautify_radio\"></span>\n      <label for=\"ugoiraSaveAs3\">${lang.transl('_gif')} &nbsp;</label>\n      <input type=\"radio\" name=\"ugoiraSaveAs\" id=\"ugoiraSaveAs4\" class=\"need_beautify radio\" value=\"png\"> \n      <span class=\"beautify_radio\"></span>\n      <label for=\"ugoiraSaveAs4\" class=\"has_tip\" data-tip=\"${lang.transl('_无损')}\">${lang.transl('_apng')} &nbsp;</label>\n      <input type=\"radio\" name=\"ugoiraSaveAs\" id=\"ugoiraSaveAs2\" class=\"need_beautify radio\" value=\"zip\"> \n      <span class=\"beautify_radio\"></span>\n      <label for=\"ugoiraSaveAs2\">${lang.transl('_zipFile')} &nbsp;</label>\n      </p>\n\n      <p class=\"option\" data-no=\"24\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_同时转换多少个动图警告')}\">${lang.transl('_同时转换多少个动图')}</span>\n      <input type=\"text\" name=\"convertUgoiraThread\" class=\"setinput_style1 blue\" value=\"1\">\n      <span class=\"has_tip gray1\" data-tip=\"${lang.transl('_同时转换多少个动图警告')}\"> ${lang.transl('_提示')} </span>\n      </p>\n\n      <p class=\"option\" data-no=\"26\">\n      <span class=\"settingNameStyle1\">${lang.transl('_小说保存格式')}<span class=\"gray1\"> &nbsp; </span></span>\n      <input type=\"radio\" name=\"novelSaveAs\" id=\"novelSaveAs1\" class=\"need_beautify radio\" value=\"txt\" checked>\n      <span class=\"beautify_radio\"></span>\n      <label for=\"novelSaveAs1\"> TXT &nbsp;</label>\n      <input type=\"radio\" name=\"novelSaveAs\" id=\"novelSaveAs2\" class=\"need_beautify radio\" value=\"epub\"> \n      <span class=\"beautify_radio\"></span>\n      <label for=\"novelSaveAs2\"> EPUB &nbsp;</label>\n      </p>\n      \n      <p class=\"option\" data-no=\"27\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_在小说里保存元数据提示')}\">${lang.transl('_在小说里保存元数据')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"saveNovelMeta\" class=\"need_beautify checkbox_switch\" >\n      <span class=\"beautify_switch\"></span>\n      </p>\n\n      <p class=\"option\" data-no=\"30\">\n      <span class=\"settingNameStyle1\">${lang.transl('_图片尺寸')} </span>\n      <input type=\"radio\" name=\"imageSize\" id=\"imageSize1\" class=\"need_beautify radio\" value=\"original\" checked>\n      <span class=\"beautify_radio\"></span>\n      <label for=\"imageSize1\"> ${lang.transl('_原图')} </label>\n      &nbsp;\n      <input type=\"radio\" name=\"imageSize\" id=\"imageSize2\" class=\"need_beautify radio\" value=\"regular\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"imageSize2\"> ${lang.transl('_普通')} </label>\n      <span class=\"gray1\">(1200*1200)</span>\n      &nbsp;\n      <input type=\"radio\" name=\"imageSize\" id=\"imageSize3\" class=\"need_beautify radio\" value=\"small\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"imageSize3\"> ${lang.transl('_小图')} </label>\n      <span class=\"gray1\">(540*540)</span>\n      </p>\n  \n      <p class=\"option\" data-no=\"25\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_不符合要求的文件不会被保存')}\">\n      ${lang.transl('_文件体积限制')} <span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"sizeSwitch\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"sizeSwitch\">\n      <input type=\"text\" name=\"sizeMin\" class=\"setinput_style1 blue\" value=\"0\">MiB\n      &nbsp;-&nbsp;\n      <input type=\"text\" name=\"sizeMax\" class=\"setinput_style1 blue\" value=\"100\">MiB\n      </span>\n      </p>\n\n      <p class=\"option\" data-no=\"28\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_不下载重复文件的提示')}\">\n      ${lang.transl('_不下载重复文件')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"deduplication\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"deduplication\">\n      <span>&nbsp; ${lang.transl('_策略')}</span>\n      <input type=\"radio\" name=\"dupliStrategy\" id=\"dupliStrategy1\" class=\"need_beautify radio\" value=\"strict\" checked>\n      <span class=\"beautify_radio\"></span>\n      <label class=\"has_tip\" for=\"dupliStrategy1\" data-tip=\"${lang.transl('_严格模式说明')}\">${lang.transl('_严格')}</label>\n      &nbsp;\n      <input type=\"radio\" name=\"dupliStrategy\" id=\"dupliStrategy2\" class=\"need_beautify radio\" value=\"loose\">\n      <span class=\"beautify_radio\"></span>\n      <label class=\"has_tip\" for=\"dupliStrategy2\" data-tip=\"${lang.transl('_宽松模式说明')}\">${lang.transl('_宽松')}</label>\n      &nbsp;\n      <button class=\"textButton gray1\" type=\"button\" id=\"exportDownloadRecord\">${lang.transl('_导出')}</button>\n      <button class=\"textButton gray1\" type=\"button\" id=\"importDownloadRecord\">${lang.transl('_导入')}</button>\n      <button class=\"textButton gray1\" type=\"button\" id=\"clearDownloadRecord\">${lang.transl('_清除')}</button>\n      </span>\n      </p>\n\n      <p class=\"option\" data-no=\"35\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_用户阻止名单的说明')}\">${lang.transl('_用户阻止名单')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"userBlockList\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"userBlockList\">\n      <input type=\"text\" name=\"blockList\" class=\"setinput_style1 blue setinput_tag\">\n      </span>\n      </p>\n\n      <hr />\n      \n      <p class=\"option\" data-no=\"33\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_下载之后收藏作品的提示')}\">\n      ${lang.transl('_下载之后收藏作品')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"bmkAfterDL\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      </p>\n\n      <p class=\"option\" data-no=\"34\">\n      <span class=\"settingNameStyle1\">${lang.transl('_收藏设置')}</span>\n      \n      <input type=\"radio\" name=\"widthTag\" id=\"widthTag1\" class=\"need_beautify radio\" value=\"1\" checked>\n      <span class=\"beautify_radio\"></span>\n      <label for=\"widthTag1\">${lang.transl('_添加tag')}&nbsp;</label>\n      <input type=\"radio\" name=\"widthTag\" id=\"widthTag2\" class=\"need_beautify radio\" value=\"-1\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"widthTag2\">${lang.transl('_不添加tag')}</label>\n\n      <span class=\"verticalSplit\"></span>\n      \n      <input type=\"radio\" name=\"restrict\" id=\"restrict1\" class=\"need_beautify radio\" value=\"-1\" checked>\n      <span class=\"beautify_radio\"></span>\n      <label for=\"restrict1\">${lang.transl('_公开')}&nbsp;</label>\n      <input type=\"radio\" name=\"restrict\" id=\"restrict2\" class=\"need_beautify radio\" value=\"1\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"restrict2\">${lang.transl('_不公开')}</label>\n      </p>\n\n      <hr />\n\n      <p class=\"option\" data-no=\"18\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_预览搜索结果说明')}\">${lang.transl('_预览搜索结果')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"previewResult\" id=\"setPreviewResult\" class=\"need_beautify checkbox_switch\" checked>\n      <span class=\"beautify_switch\"></span>\n      </p>\n\n      <p class=\"option\" data-no=\"31\">\n      <span class=\"settingNameStyle1\">${lang.transl('_日期格式')}</span>\n      <input type=\"text\" name=\"dateFormat\" class=\"setinput_style1 blue\" style=\"width:250px;\" value=\"YYYY-MM-DD\">\n      <button type=\"button\" class=\"gray1 textButton showDateTip\">${lang.transl('_提示')}</button>\n      </p>\n      <p class=\"dateFormatTip tip\" style=\"display:none\">\n      <span>${lang.transl('_日期格式提示')}</span>\n      <br>\n      <span class=\"blue\">YYYY</span> <span>2021</span>\n      <br>\n      <span class=\"blue\">YY</span> <span>21</span>\n      <br>\n      <span class=\"blue\">MM</span> <span>04</span>\n      <br>\n      <span class=\"blue\">MMM</span> <span>Apr</span>\n      <br>\n      <span class=\"blue\">MMMM</span> <span>April</span>\n      <br>\n      <span class=\"blue\">DD</span> <span>30</span>\n      <br>\n      <span class=\"blue\">hh</span> <span>06</span>\n      <br>\n      <span class=\"blue\">mm</span> <span>40</span>\n      <br>\n      <span class=\"blue\">ss</span> <span>08</span>\n      <br>\n      </p>\n\n      <p class=\"option\" data-no=\"36\">\n      <span class=\"settingNameStyle1\">${lang.transl('_颜色主题')}</span>\n      <input type=\"radio\" name=\"theme\" id=\"theme1\" class=\"need_beautify radio\" value=\"auto\" checked>\n      <span class=\"beautify_radio\"></span>\n      <label for=\"theme1\">${lang.transl('_自动检测')}</label>\n      &nbsp;\n      <input type=\"radio\" name=\"theme\" id=\"theme2\" class=\"need_beautify radio\" value=\"white\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"theme2\">White</label>\n      &nbsp;\n      <input type=\"radio\" name=\"theme\" id=\"theme3\" class=\"need_beautify radio\" value=\"dark\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"theme3\">Dark</label>\n      </p>\n\n      <p class=\"option\" data-no=\"32\">\n      <span class=\"settingNameStyle1\">Language</span>\n      <input type=\"radio\" name=\"userSetLang\" id=\"userSetLang1\" class=\"need_beautify radio\" value=\"-1\" checked>\n      <span class=\"beautify_radio\"></span>\n      <label for=\"userSetLang1\">${lang.transl('_自动检测')}</label>\n      &nbsp;\n      <input type=\"radio\" name=\"userSetLang\" id=\"userSetLang2\" class=\"need_beautify radio\" value=\"0\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"userSetLang2\">简体中文</label>\n      &nbsp;\n      <input type=\"radio\" name=\"userSetLang\" id=\"userSetLang3\" class=\"need_beautify radio\" value=\"3\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"userSetLang3\">繁體中文</label>\n      &nbsp;\n      <input type=\"radio\" name=\"userSetLang\" id=\"userSetLang4\" class=\"need_beautify radio\" value=\"1\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"userSetLang4\">日本語</label>\n      &nbsp;\n      <input type=\"radio\" name=\"userSetLang\" id=\"userSetLang5\" class=\"need_beautify radio\" value=\"2\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"userSetLang5\">English</label>\n      &nbsp;\n      </p>\n\n      <p class=\"option\" data-no=\"37\">\n      <span class=\"settingNameStyle1\">${lang.transl('_管理设置')}</span>\n      <button class=\"textButton gray1\" type=\"button\" id=\"exportSettings\">${lang.transl('_导出设置')}</button>\n      <button class=\"textButton gray1\" type=\"button\" id=\"importSettings\">${lang.transl('_导入设置')}</button>\n      <button class=\"textButton gray1\" type=\"button\" id=\"resetSettings\">${lang.transl('_重置设置')}</button>\n      </p>\n\n      <slot data-name=\"otherBtns\" class=\"centerWrap_btns\"></slot>\n    </div>\n  </div>\n</form>`;\r\nexport default formHtml;\r\n","import { EVT } from '../EVT';\r\nimport { pageType } from '../PageType';\r\nimport { settings } from './Settings';\r\n// 管理 from 表单里的选项（类型为 input 元素的选项），从 settings 里设置选项的值；当选项改变时保存到 settings 里\r\n// 不属于 input 类型的选项，不在这里处理。\r\n// 补充说明：\r\n// 选项 setWantPage 并不需要实际上进行保存和恢复。保存和恢复时使用的是 wantPageArr\r\nclass FormSettings {\r\n    constructor(form) {\r\n        this.form = form;\r\n        this.bindEvents();\r\n        this.ListenChange();\r\n        this.restoreFormSettings();\r\n    }\r\n    bindEvents() {\r\n        window.addEventListener(EVT.list.pageSwitchedTypeChange, () => {\r\n            this.restoreWantPage();\r\n        });\r\n        window.addEventListener(EVT.list.resetSettingsEnd, () => {\r\n            this.restoreFormSettings();\r\n        });\r\n    }\r\n    // 处理输入框： change 时保存 value\r\n    saveTextInput(name) {\r\n        const el = this.form[name];\r\n        el.addEventListener('change', () => {\r\n            this.emitChange(name, el.value);\r\n        });\r\n    }\r\n    // 处理复选框： click 时保存 checked\r\n    saveCheckBox(name) {\r\n        const el = this.form[name];\r\n        el.addEventListener('click', () => {\r\n            this.emitChange(name, el.checked);\r\n        });\r\n    }\r\n    // 处理单选框： click 时保存 value\r\n    saveRadio(name) {\r\n        const radios = this.form[name];\r\n        for (const radio of radios) {\r\n            radio.addEventListener('click', () => {\r\n                this.emitChange(name, radio.value);\r\n            });\r\n        }\r\n    }\r\n    // 监听所有选项的变化，触发 settingChange 事件\r\n    // 该函数可执行一次，否则事件会重复绑定\r\n    ListenChange() {\r\n        // 保存页数/个数设置\r\n        this.saveTextInput('setWantPage');\r\n        // 保存 wantPageArr\r\n        this.form.setWantPage.addEventListener('change', () => {\r\n            const temp = Array.from(settings.wantPageArr);\r\n            temp[pageType.type] = this.form.setWantPage.value;\r\n            this.emitChange('wantPageArr', temp);\r\n        });\r\n        // 保存下载的作品类型\r\n        this.saveCheckBox('downType0');\r\n        this.saveCheckBox('downType1');\r\n        this.saveCheckBox('downType2');\r\n        this.saveCheckBox('downType3');\r\n        this.saveCheckBox('downSingleImg');\r\n        this.saveCheckBox('downMultiImg');\r\n        this.saveCheckBox('downColorImg');\r\n        this.saveCheckBox('downBlackWhiteImg');\r\n        // 保存多图作品设置\r\n        this.saveCheckBox('firstFewImagesSwitch');\r\n        this.saveTextInput('firstFewImages');\r\n        // 保存只下载已收藏\r\n        this.saveCheckBox('setOnlyBmk');\r\n        // 保存动图格式选项\r\n        this.saveRadio('ugoiraSaveAs');\r\n        // 保存动图转换线程数\r\n        this.saveTextInput('convertUgoiraThread');\r\n        this.saveRadio('novelSaveAs');\r\n        this.saveCheckBox('saveNovelMeta');\r\n        // 保存收藏数量选项\r\n        this.saveCheckBox('BMKNumSwitch');\r\n        // 保存收藏数量数值\r\n        this.saveTextInput('BMKNumMin');\r\n        this.saveTextInput('BMKNumMax');\r\n        // 保存宽高条件\r\n        this.saveCheckBox('setWHSwitch');\r\n        this.saveRadio('widthHeightLimit');\r\n        this.saveRadio('setWidthAndOr');\r\n        this.saveTextInput('setWidth');\r\n        this.saveTextInput('setHeight');\r\n        // 保存宽高比例\r\n        this.saveCheckBox('ratioSwitch');\r\n        this.saveRadio('ratio');\r\n        this.saveTextInput('userRatio');\r\n        // 保存投稿时间\r\n        this.saveCheckBox('postDate');\r\n        this.saveTextInput('postDateStart');\r\n        this.saveTextInput('postDateEnd');\r\n        // 保存 id 范围\r\n        this.saveCheckBox('idRangeSwitch');\r\n        this.saveTextInput('idRangeInput');\r\n        this.saveRadio('idRange');\r\n        // 保存必须的 tag 设置\r\n        this.saveCheckBox('needTagSwitch');\r\n        this.saveTextInput('needTag');\r\n        // 保存排除的 tag 设置\r\n        this.saveCheckBox('notNeedTagSwitch');\r\n        this.saveTextInput('notNeedTag');\r\n        // 保存命名规则\r\n        const userSetNameInput = this.form.userSetName;\r\n        ['change', 'focus'].forEach((ev) => {\r\n            userSetNameInput.addEventListener(ev, () => {\r\n                this.emitChange('userSetName', userSetNameInput.value);\r\n            });\r\n        });\r\n        // 保存是否添加标记名称\r\n        this.saveCheckBox('tagNameToFileName');\r\n        // 保存第一张图不带序号\r\n        this.saveCheckBox('noSerialNo');\r\n        // 保存是否始终建立文件夹\r\n        this.saveCheckBox('alwaysFolder');\r\n        // 保存是否为多图作品自动建立文件夹\r\n        this.saveCheckBox('multipleImageDir');\r\n        // 保存多图建立文件夹时的命名规则\r\n        this.saveRadio('multipleImageFolderName');\r\n        // 保存文件体积限制\r\n        this.saveCheckBox('sizeSwitch');\r\n        this.saveTextInput('sizeMin');\r\n        this.saveTextInput('sizeMax');\r\n        // 保存自动下载\r\n        this.saveCheckBox('quietDownload');\r\n        // 保存下载线程\r\n        this.saveTextInput('downloadThread');\r\n        // 保存预览搜索结果\r\n        this.saveCheckBox('previewResult');\r\n        // 保存去重设置\r\n        this.saveCheckBox('deduplication');\r\n        this.saveRadio('dupliStrategy');\r\n        // 保存文件名长度限制\r\n        this.saveCheckBox('fileNameLengthLimitSwitch');\r\n        this.saveTextInput('fileNameLengthLimit');\r\n        this.saveRadio('imageSize');\r\n        this.saveTextInput('dateFormat');\r\n        this.saveRadio('userSetLang');\r\n        this.saveCheckBox('bmkAfterDL');\r\n        this.saveRadio('restrict');\r\n        this.saveRadio('widthTag');\r\n        this.saveCheckBox('userBlockList');\r\n        this.saveTextInput('blockList');\r\n        this.saveRadio('needTagMode');\r\n        this.saveRadio('theme');\r\n    }\r\n    // 表单里的设置发生改变时，调用这个方法，传递选项名和值\r\n    emitChange(name, value) {\r\n        ;\r\n        settings[name] = value;\r\n        EVT.fire(EVT.list.settingChange, { name: name, value: value });\r\n    }\r\n    // 恢复值为 Boolean 的设置项\r\n    // input[type='checkbox'] 使用\r\n    restoreBoolean(name) {\r\n        if (settings[name] !== undefined) {\r\n            this.form[name].checked = settings[name];\r\n        }\r\n    }\r\n    // 恢复值为 string 的设置项\r\n    // input[type='radio'] 和 input[type='text'] 使用\r\n    restoreString(name) {\r\n        if (settings[name] !== undefined) {\r\n            this.form[name].value = settings[name].toString();\r\n        }\r\n    }\r\n    // 设置当前页面类型的 setWantPage\r\n    restoreWantPage() {\r\n        const want = settings.wantPageArr[pageType.type];\r\n        if (want !== '' && want !== undefined) {\r\n            this.form.setWantPage.value = want;\r\n            settings.setWantPage = want;\r\n        }\r\n    }\r\n    // 读取设置，恢复表单里的设置项\r\n    restoreFormSettings() {\r\n        this.restoreWantPage();\r\n        // 设置下载的作品类型\r\n        this.restoreBoolean('downType0');\r\n        this.restoreBoolean('downType1');\r\n        this.restoreBoolean('downType2');\r\n        this.restoreBoolean('downType3');\r\n        this.restoreBoolean('downSingleImg');\r\n        this.restoreBoolean('downMultiImg');\r\n        this.restoreBoolean('downColorImg');\r\n        this.restoreBoolean('downBlackWhiteImg');\r\n        // 多图下载前几张图作品设置\r\n        this.restoreBoolean('firstFewImagesSwitch');\r\n        this.restoreString('firstFewImages');\r\n        // 设置只下载已收藏\r\n        this.restoreBoolean('setOnlyBmk');\r\n        // 设置动图格式选项\r\n        this.restoreString('ugoiraSaveAs');\r\n        // 设置动图转换线程数\r\n        this.restoreString('convertUgoiraThread');\r\n        this.restoreString('novelSaveAs');\r\n        this.restoreBoolean('saveNovelMeta');\r\n        // 设置收藏数量选项\r\n        this.restoreBoolean('BMKNumSwitch');\r\n        // 设置收藏数量数值\r\n        this.restoreString('BMKNumMin');\r\n        this.restoreString('BMKNumMax');\r\n        // 设置宽高条件\r\n        this.restoreBoolean('setWHSwitch');\r\n        this.restoreString('widthHeightLimit');\r\n        this.restoreString('setWidthAndOr');\r\n        this.restoreString('setWidth');\r\n        this.restoreString('setHeight');\r\n        // 设置宽高比例\r\n        this.restoreBoolean('ratioSwitch');\r\n        this.restoreString('ratio');\r\n        this.restoreString('userRatio');\r\n        // 设置 id 范围\r\n        this.restoreBoolean('idRangeSwitch');\r\n        this.restoreString('idRangeInput');\r\n        this.restoreString('idRange');\r\n        // 设置必须的 tag\r\n        this.restoreBoolean('needTagSwitch');\r\n        this.restoreString('needTag');\r\n        // 设置排除的 tag\r\n        this.restoreBoolean('notNeedTagSwitch');\r\n        this.restoreString('notNeedTag');\r\n        // 设置投稿时间\r\n        this.restoreBoolean('postDate');\r\n        this.restoreString('postDateStart');\r\n        this.restoreString('postDateEnd');\r\n        // 设置自动下载\r\n        this.restoreBoolean('quietDownload');\r\n        // 设置下载线程\r\n        this.restoreString('downloadThread');\r\n        // 设置文件命名规则\r\n        this.restoreString('userSetName');\r\n        // 设置是否添加标记名称\r\n        this.restoreBoolean('tagNameToFileName');\r\n        // 设置第一张图不带序号\r\n        this.restoreBoolean('noSerialNo');\r\n        // 设置是否始终建立文件夹\r\n        this.restoreBoolean('alwaysFolder');\r\n        // 设置是否为多图作品自动建立文件夹\r\n        this.restoreBoolean('multipleImageDir');\r\n        // 设置多图作品建立文件夹时的文件名规则\r\n        this.restoreString('multipleImageFolderName');\r\n        // 设置预览搜索结果\r\n        this.restoreBoolean('previewResult');\r\n        // 设置文件体积限制\r\n        this.restoreBoolean('sizeSwitch');\r\n        this.restoreString('sizeMin');\r\n        this.restoreString('sizeMax');\r\n        // 恢复去重设置\r\n        this.restoreBoolean('deduplication');\r\n        this.restoreString('dupliStrategy');\r\n        // 恢复文件名长度限制\r\n        this.restoreBoolean('fileNameLengthLimitSwitch');\r\n        this.restoreString('fileNameLengthLimit');\r\n        this.restoreString('imageSize');\r\n        this.restoreString('dateFormat');\r\n        this.restoreString('userSetLang');\r\n        this.restoreBoolean('bmkAfterDL');\r\n        this.restoreString('restrict');\r\n        this.restoreString('widthTag');\r\n        this.restoreBoolean('userBlockList');\r\n        this.restoreString('blockList');\r\n        this.restoreString('needTagMode');\r\n        this.restoreString('theme');\r\n    }\r\n}\r\nexport { FormSettings };\r\n","import { form } from './Form';\r\n// 操作设置表单的选项区域\r\n// 可以控制每个设置的隐藏、显示\r\n// 可以直接设置每个选项的值\r\nclass Options {\r\n    constructor() {\r\n        this.allOption = form.querySelectorAll('.option');\r\n        // 获取“页数/个数”设置的元素\r\n        const wantPageOption = this.getOption(1);\r\n        this.wantPageEls = {\r\n            text: wantPageOption.querySelector('.setWantPageTip1'),\r\n            rangTip: wantPageOption.querySelector('.setWantPageTip2'),\r\n            input: wantPageOption.querySelector('.setWantPage'),\r\n        };\r\n    }\r\n    // 使用编号获取指定选项的元素\r\n    getOption(no) {\r\n        for (const option of this.allOption) {\r\n            if (option.dataset.no === no.toString()) {\r\n                return option;\r\n            }\r\n        }\r\n        throw `Not found this option: ${no}`;\r\n    }\r\n    // 显示或隐藏指定的选项\r\n    setOptionDisplay(no, display) {\r\n        for (const number of no) {\r\n            this.getOption(number).style.display = display;\r\n        }\r\n    }\r\n    // 显示所有选项\r\n    // 在切换不同页面时使用\r\n    showAllOption() {\r\n        for (const el of this.allOption) {\r\n            el.style.display = 'block';\r\n        }\r\n    }\r\n    // 隐藏指定的选项。参数是数组，传递设置项的编号。\r\n    hideOption(no) {\r\n        this.setOptionDisplay(no, 'none');\r\n    }\r\n    // 显示指定的选项。因为页面无刷新加载，所以一些选项被隐藏后，可能需要再次显示\r\n    showOption(no) {\r\n        this.setOptionDisplay(no, 'block');\r\n    }\r\n    // 设置 “设置页面/作品数量” 选项的提示和预设值\r\n    setWantPageTip(arg) {\r\n        this.wantPageEls.text.textContent = arg.text;\r\n        this.wantPageEls.text.dataset.tip = arg.tip;\r\n        this.wantPageEls.rangTip.textContent = arg.rangTip;\r\n    }\r\n}\r\nconst options = new Options();\r\nexport { options };\r\n","import { EVT } from '../EVT';\r\nimport { DOM } from '../DOM';\r\nimport { lang } from '../Lang';\r\nimport { log } from '../Log';\r\nimport { theme } from '../Theme';\r\nimport { settings } from './Settings';\r\n// 保存和加载命名规则列表\r\nclass SaveNamingRule {\r\n    constructor(ruleInput) {\r\n        this.limit = 20; // 最大保存数量\r\n        this._show = false; // 是否显示列表\r\n        this.html = `\n  <div class=\"saveNamingRuleWrap\">\n  <button class=\"nameSave textButton has_tip\" type=\"button\" data-tip=\"${lang.transl('_保存命名规则提示', this.limit.toString())}\">${lang.transl('_保存')}</button>\n  <button class=\"nameLoad textButton\" type=\"button\">${lang.transl('_加载')}</button>\n  <ul class=\"namingRuleList\"></ul>\n  </div>`;\r\n        this.ruleInput = ruleInput;\r\n        DOM.clearSlot('saveNamingRule');\r\n        const wrap = DOM.useSlot('saveNamingRule', this.html);\r\n        theme.register(wrap);\r\n        this.saveBtn = wrap.querySelector('button.nameSave');\r\n        this.loadBtn = wrap.querySelector('button.nameLoad');\r\n        this.listWrap = wrap.querySelector('ul.namingRuleList');\r\n        this.createList();\r\n        this.bindEvents();\r\n    }\r\n    set show(boolean) {\r\n        this._show = boolean;\r\n        boolean ? this.showListWrap() : this.hideListWrap();\r\n    }\r\n    get show() {\r\n        return this._show;\r\n    }\r\n    bindEvents() {\r\n        this.saveBtn.addEventListener('click', () => {\r\n            this.add(this.ruleInput.value);\r\n        });\r\n        this.loadBtn.addEventListener('click', () => {\r\n            this.show = !this.show;\r\n        });\r\n        this.listWrap.addEventListener('mouseleave', () => {\r\n            this.show = false;\r\n        });\r\n        // 当设置发生了变化，就重新创建列表\r\n        // 这里不要判断事件的 data.name，因为恢复设置时没有传递 data.name ，但此时依旧需要重新创建列表\r\n        window.addEventListener(EVT.list.settingChange, () => {\r\n            this.createList();\r\n        });\r\n    }\r\n    add(rule) {\r\n        if (settings.namingRuleList.length === this.limit) {\r\n            settings.namingRuleList.splice(0, 1);\r\n        }\r\n        // 如果这个规则已存在，不会重复添加它\r\n        if (!settings.namingRuleList.includes(rule)) {\r\n            settings.namingRuleList.push(rule);\r\n            this.handleChange();\r\n        }\r\n        log.success(lang.transl('_已保存命名规则'));\r\n    }\r\n    delete(index) {\r\n        settings.namingRuleList.splice(index, 1);\r\n        this.handleChange();\r\n    }\r\n    select(rule) {\r\n        this.ruleInput.value = rule;\r\n        settings.userSetName = rule;\r\n        EVT.fire(EVT.list.settingChange, { name: 'userSetName', value: rule });\r\n    }\r\n    handleChange() {\r\n        EVT.fire(EVT.list.settingChange, {\r\n            name: 'namingRuleList',\r\n            value: settings.namingRuleList,\r\n        });\r\n    }\r\n    createList() {\r\n        const htmlArr = [];\r\n        for (let i = 0; i < settings.namingRuleList.length; i++) {\r\n            const html = `<li>\n      <span class=\"rule\">${settings.namingRuleList[i]}</span>\n      <button class=\"delete textButton\" type=\"button\" data-index=\"${i}\">×</button>\n    </li>`;\r\n            htmlArr.push(html);\r\n        }\r\n        if (settings.namingRuleList.length === 0) {\r\n            htmlArr.push(`<li><i>&nbsp;&nbsp;&nbsp;&nbsp;no data</i></li>`);\r\n        }\r\n        this.listWrap.innerHTML = htmlArr.join('');\r\n        const ruleEls = this.listWrap.querySelectorAll('.rule');\r\n        for (const el of ruleEls) {\r\n            el.addEventListener('click', () => {\r\n                this.select(el.textContent);\r\n                this.show = false;\r\n            });\r\n        }\r\n        const deleteEls = this.listWrap.querySelectorAll('.delete');\r\n        for (const el of deleteEls) {\r\n            el.addEventListener('click', () => {\r\n                const index = parseInt(el.dataset.index);\r\n                this.delete(index);\r\n            });\r\n        }\r\n    }\r\n    showListWrap() {\r\n        this.listWrap.style.display = 'block';\r\n    }\r\n    hideListWrap() {\r\n        this.listWrap.style.display = 'none';\r\n    }\r\n}\r\nexport { SaveNamingRule };\r\n","import { API } from '../API';\r\nimport { EVT } from '../EVT';\r\nimport { lang } from '../Lang';\r\nimport { log } from '../Log';\r\nimport { settings } from './Settings';\r\n// 设置相关的 API\r\nclass SettingAPI {\r\n    constructor() {\r\n        this.firstFewImages = 0; // 缓存多图作品只下载前几张图片的值\r\n        this.bindEvents();\r\n        this.firstFewImages = this.getFirstFewImages();\r\n    }\r\n    bindEvents() {\r\n        // 当 firstFewImages 设置改变时，保存它的值\r\n        window.addEventListener(EVT.list.settingChange, (event) => {\r\n            const data = event.detail.data;\r\n            if (data.name === 'firstFewImages') {\r\n                this.firstFewImages = this.getFirstFewImages();\r\n            }\r\n        });\r\n    }\r\n    // 获取作品张数设置\r\n    getFirstFewImages() {\r\n        const check = API.checkNumberGreater0(settings.firstFewImages);\r\n        if (check.result) {\r\n            return check.value;\r\n        }\r\n        // 如果用户输入的数字不合法（不大于0）\r\n        EVT.fire(EVT.list.wrongSetting);\r\n        const msg = lang.transl('_下载前几张图片') + ' ' + lang.transl('_必须大于0');\r\n        log.error(msg);\r\n        EVT.sendMsg({\r\n            msg: msg,\r\n            type: 'error',\r\n        });\r\n        throw new Error(msg);\r\n    }\r\n    // 计算要从这个作品里下载几张图片\r\n    getDLCount(pageCount) {\r\n        if (settings.firstFewImagesSwitch && this.firstFewImages <= pageCount) {\r\n            return this.firstFewImages;\r\n        }\r\n        return pageCount;\r\n    }\r\n}\r\nconst settingAPI = new SettingAPI();\r\nexport { settingAPI };\r\n","// settings 保存了下载器的所有设置项\r\n// 每当修改了 settings 的值，都要触发 EVT.list.settingChange 事件，让其他模块可以监听到变化\r\n// 如果修改的是整个 settings，settingChange 事件没有参数\r\n// 如果修改的是某一个属性的值，settingChange 事件参数应该传递这个属性的数据 {name:string, value:any}\r\n// 如果打开了多个标签页，每个页面的 settings 数据是互相独立的。但是 localStorage 里的数据只有一份：最后一个设置变更是在哪个页面发生的，就把哪个页面的 settings 保存到 localStorage 里。所以恢复设置时，恢复的也是这个页面的设置。\r\nimport { EVT } from '../EVT';\r\nimport { DOM } from '../DOM';\r\nclass Settings {\r\n    constructor() {\r\n        this.storeName = 'xzSetting';\r\n        // 默认设置\r\n        this.defaultSettings = {\r\n            setWantPage: '-1',\r\n            wantPageArr: [\r\n                '-1',\r\n                '-1',\r\n                '-1',\r\n                '-1',\r\n                '-1',\r\n                '1000',\r\n                '-1',\r\n                '500',\r\n                '-1',\r\n                '1000',\r\n                '100',\r\n                '-1',\r\n                '100',\r\n                '-1',\r\n                '-1',\r\n                '1000',\r\n                '100',\r\n                '100',\r\n                '100',\r\n                '100',\r\n                '-1',\r\n            ],\r\n            firstFewImagesSwitch: false,\r\n            firstFewImages: '1',\r\n            downType0: true,\r\n            downType1: true,\r\n            downType2: true,\r\n            downType3: true,\r\n            downSingleImg: true,\r\n            downMultiImg: true,\r\n            downColorImg: true,\r\n            downBlackWhiteImg: true,\r\n            setOnlyBmk: false,\r\n            ugoiraSaveAs: 'webm',\r\n            convertUgoiraThread: '1',\r\n            needTag: '',\r\n            notNeedTag: '',\r\n            quietDownload: true,\r\n            downloadThread: '5',\r\n            userSetName: '{id}',\r\n            namingRuleList: [],\r\n            tagNameToFileName: false,\r\n            alwaysFolder: false,\r\n            multipleImageDir: false,\r\n            multipleImageFolderName: '1',\r\n            showOptions: true,\r\n            postDate: false,\r\n            postDateStart: '',\r\n            postDateEnd: '',\r\n            previewResult: true,\r\n            BMKNumSwitch: false,\r\n            BMKNumMin: '0',\r\n            BMKNumMax: '999999',\r\n            setWHSwitch: false,\r\n            widthHeightLimit: '>=',\r\n            setWidthAndOr: '&',\r\n            setWidth: '0',\r\n            setHeight: '0',\r\n            ratioSwitch: false,\r\n            ratio: '1',\r\n            userRatio: '1.4',\r\n            idRangeSwitch: false,\r\n            idRangeInput: '0',\r\n            idRange: '1',\r\n            needTagSwitch: false,\r\n            notNeedTagSwitch: false,\r\n            noSerialNo: false,\r\n            filterBlackWhite: false,\r\n            sizeSwitch: false,\r\n            sizeMin: '0',\r\n            sizeMax: '100',\r\n            novelSaveAs: 'txt',\r\n            saveNovelMeta: false,\r\n            deduplication: false,\r\n            dupliStrategy: 'loose',\r\n            fileNameLengthLimitSwitch: false,\r\n            fileNameLengthLimit: '200',\r\n            imageSize: 'original',\r\n            dateFormat: 'YYYY-MM-DD',\r\n            userSetLang: '-1',\r\n            bmkAfterDL: false,\r\n            widthTag: '1',\r\n            restrict: '-1',\r\n            userBlockList: false,\r\n            blockList: '',\r\n            theme: 'auto',\r\n            needTagMode: 'all',\r\n        };\r\n        // 深拷贝一份设置，作为实际使用的设置\r\n        this.settings = Object.assign({}, this.defaultSettings);\r\n        // 第一时间恢复用户设置\r\n        this.restoreSettings();\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        // 当设置发生变化时进行本地存储\r\n        window.addEventListener(EVT.list.settingChange, () => {\r\n            localStorage.setItem(this.storeName, JSON.stringify(this.settings));\r\n        });\r\n        window.addEventListener(EVT.list.resetSettings, () => {\r\n            this.reset();\r\n        });\r\n        window.addEventListener(EVT.list.exportSettings, () => {\r\n            this.exportSettings();\r\n        });\r\n        window.addEventListener(EVT.list.importSettings, () => {\r\n            this.importSettings();\r\n        });\r\n    }\r\n    // 读取保存的设置，合并到当前设置上\r\n    restoreSettings() {\r\n        const savedSettings = localStorage.getItem(this.storeName);\r\n        if (savedSettings) {\r\n            // 使用 assign 合并设置，而不是直接覆盖 settings\r\n            // 这样如果新版本多了某个设置项，旧版本（本地存储里）没有，这个选项就会使用新版本里的默认值。\r\n            Object.assign(this.settings, JSON.parse(savedSettings));\r\n            // 这里 settings 的改变不需要触发 settingChange 事件，因为这个模块是最早执行的，其他模块尚未执行\r\n        }\r\n    }\r\n    exportSettings() {\r\n        const str = JSON.stringify(settings, null, 2);\r\n        const blob = new Blob([str], { type: 'application/json' });\r\n        const url = URL.createObjectURL(blob);\r\n        DOM.downloadFile(url, `pixiv_batch_downloader-settings.json`);\r\n    }\r\n    async importSettings() {\r\n        const loadedJSON = (await DOM.loadJSONFile().catch((err) => {\r\n            return EVT.sendMsg({\r\n                type: 'error',\r\n                msg: err,\r\n            });\r\n        }));\r\n        if (!loadedJSON) {\r\n            return;\r\n        }\r\n        // 检查是否存在设置里的属性\r\n        if (loadedJSON.downloadThread === undefined) {\r\n            return EVT.sendMsg({\r\n                type: 'error',\r\n                msg: 'Format error!',\r\n            });\r\n        }\r\n        // 开始恢复导入的设置\r\n        this.reset(loadedJSON);\r\n    }\r\n    // 重设选项\r\n    // 可选参数：传递整个设置的数据，用于从配置文件导入，恢复设置\r\n    reset(data) {\r\n        if (data) {\r\n            Object.assign(settings, data);\r\n        }\r\n        else {\r\n            // 将选项恢复为默认值\r\n            Object.assign(settings, this.defaultSettings);\r\n        }\r\n        // 触发设置改变事件\r\n        EVT.fire(EVT.list.settingChange);\r\n        EVT.fire(EVT.list.resetSettingsEnd);\r\n    }\r\n}\r\nconst settings = new Settings().settings;\r\nexport { settings };\r\n","import { EVT } from '../EVT';\r\nimport { settings } from '../setting/Settings';\r\nimport { toWebM } from './ToWebM';\r\nimport { toGIF } from './ToGIF';\r\nimport { toAPNG } from './ToAPNG';\r\n// 控制动图转换\r\nclass ConvertUgoira {\r\n    constructor() {\r\n        this.downloading = true; // 是否在下载。如果下载停止了则不继续转换后续任务，避免浪费资源\r\n        this._count = 0; // 统计有几个转换任务\r\n        this.maxCount = 1; // 允许同时运行多少个转换任务\r\n        this.setMaxCount();\r\n        window.addEventListener(EVT.list.downloadStart, () => {\r\n            this.downloading = true;\r\n        });\r\n        [EVT.list.downloadPause, EVT.list.downloadStop].forEach((event) => {\r\n            window.addEventListener(event, () => {\r\n                this.downloading = false;\r\n            });\r\n        });\r\n        window.addEventListener(EVT.list.settingChange, () => {\r\n            this.setMaxCount();\r\n        });\r\n        window.addEventListener(EVT.list.convertSuccess, () => {\r\n            this.complete();\r\n        });\r\n        window.addEventListener(EVT.list.readZipError, () => {\r\n            this.complete();\r\n        });\r\n    }\r\n    setMaxCount() {\r\n        this.maxCount = parseInt(settings.convertUgoiraThread) || 1;\r\n    }\r\n    set count(num) {\r\n        this._count = num;\r\n        EVT.fire(EVT.list.convertChange, this._count);\r\n    }\r\n    async start(file, info, type) {\r\n        return new Promise(async (resolve, reject) => {\r\n            const t = window.setInterval(async () => {\r\n                if (this._count < this.maxCount) {\r\n                    window.clearInterval(t);\r\n                    if (!this.downloading) {\r\n                        return;\r\n                    }\r\n                    this.count = this._count + 1;\r\n                    if (type === 'gif') {\r\n                        resolve(toGIF.convert(file, info));\r\n                    }\r\n                    else if (type === 'png') {\r\n                        resolve(toAPNG.convert(file, info));\r\n                    }\r\n                    else {\r\n                        // 如果没有 type 则默认使用 webm\r\n                        resolve(toWebM.convert(file, info));\r\n                    }\r\n                }\r\n            }, 200);\r\n        });\r\n    }\r\n    complete() {\r\n        this.count = this._count - 1;\r\n    }\r\n    // 转换成 WebM\r\n    async webm(file, info) {\r\n        return await this.start(file, info, 'webm');\r\n    }\r\n    // 转换成 GIF\r\n    async gif(file, info) {\r\n        return await this.start(file, info, 'gif');\r\n    }\r\n    // 转换成 APNG\r\n    async apng(file, info) {\r\n        return await this.start(file, info, 'png');\r\n    }\r\n}\r\nconst converter = new ConvertUgoira();\r\nexport { converter };\r\n","import { EVT } from '../EVT';\r\n// 从 zip 提取图片数据\r\nclass ExtractImage {\r\n    constructor() {\r\n        this.loadWorkerJS();\r\n    }\r\n    async loadWorkerJS() {\r\n        if ('zip' in window === false) {\r\n            return;\r\n        }\r\n        // 添加 zip 的 worker 文件\r\n        let zipWorker = await fetch(chrome.extension.getURL('lib/z-worker.js'));\r\n        const zipWorkerBolb = await zipWorker.blob();\r\n        const zipWorkerUrl = URL.createObjectURL(zipWorkerBolb);\r\n        zip.workerScripts = {\r\n            inflater: [zipWorkerUrl],\r\n        };\r\n    }\r\n    // 解压 zip 文件，把里面的图片转换成 DataURL\r\n    async extractImageAsDataURL(zipFile, ugoiraInfo) {\r\n        return new Promise(function (resolve, reject) {\r\n            zip.createReader(new zip.BlobReader(zipFile), (zipReader) => {\r\n                // 读取成功时的回调函数，files 保存了文件列表的信息\r\n                zipReader.getEntries((files) => {\r\n                    // 创建数组，长度与文件数量一致\r\n                    const imgFile = new Array(files.length);\r\n                    // 获取每个文件的数据。因为这个操作是异步的，所以必须检查图片数量\r\n                    files.forEach((file) => {\r\n                        file.getData(new zip.Data64URIWriter(ugoiraInfo.mime_type), (data) => {\r\n                            const fileNo = parseInt(file.filename);\r\n                            imgFile[fileNo] = data;\r\n                            // 把图片按原编号存入对应的位置。这是因为我怀疑有时候 zip.Data64URIWriter 的回调顺序不一致，直接 push 可能导致图片的顺序乱掉\r\n                            for (let i = 0; i < imgFile.length; i++) {\r\n                                // 检测到空值说明没有添加完毕，退出循环\r\n                                if (!imgFile[i]) {\r\n                                    break;\r\n                                }\r\n                                // 如果检查到最后一项，说明添加完毕\r\n                                if (i === imgFile.length - 1) {\r\n                                    resolve(imgFile);\r\n                                }\r\n                            }\r\n                        });\r\n                    });\r\n                });\r\n            }, (message) => {\r\n                EVT.fire(EVT.list.readZipError);\r\n                reject(new Error('ReadZIP error: ' + message));\r\n            });\r\n        });\r\n    }\r\n}\r\nconst extractImage = new ExtractImage();\r\nexport { extractImage };\r\n","import { extractImage } from './ExtractImage';\r\nimport { DOM } from '../DOM';\r\nimport { EVT } from '../EVT';\r\nclass ToAPNG {\r\n    async convert(file, info) {\r\n        return new Promise(async (resolve, reject) => {\r\n            // 获取解压后的图片数据\r\n            let base64Arr = await extractImage\r\n                .extractImageAsDataURL(file, info)\r\n                .catch(() => {\r\n                reject(new Error('Start error'));\r\n            });\r\n            if (!base64Arr) {\r\n                return;\r\n            }\r\n            // 每一帧的数据\r\n            let arrayBuffList = await this.getFrameData(base64Arr);\r\n            // 延迟数据\r\n            const delayList = [];\r\n            for (const d of info.frames) {\r\n                delayList.push(d.delay);\r\n            }\r\n            // 获取宽高\r\n            const img = await DOM.loadImg(base64Arr[0]);\r\n            // 编码\r\n            const png = UPNG.encode(arrayBuffList, img.width, img.height, 0, delayList);\r\n            base64Arr = null;\r\n            arrayBuffList = null;\r\n            const blob = new Blob([png], {\r\n                type: 'image/vnd.mozilla.apng',\r\n            });\r\n            EVT.fire(EVT.list.convertSuccess);\r\n            resolve(blob);\r\n        });\r\n    }\r\n    // 获取每一帧的数据，传递给编码器使用\r\n    async getFrameData(imgFile) {\r\n        const resultList = [];\r\n        return new Promise(async (resolve, reject) => {\r\n            for (const base64 of imgFile) {\r\n                const img = await DOM.loadImg(base64);\r\n                const canvas = document.createElement('canvas');\r\n                const ctx = canvas.getContext('2d');\r\n                canvas.width = img.width;\r\n                canvas.height = img.height;\r\n                ctx.drawImage(img, 0, 0);\r\n                const buff = ctx.getImageData(0, 0, img.width, img.height).data.buffer;\r\n                resultList.push(buff);\r\n            }\r\n            resolve(resultList);\r\n        });\r\n    }\r\n}\r\nconst toAPNG = new ToAPNG();\r\nexport { toAPNG };\r\n","import { extractImage } from './ExtractImage';\r\nimport { DOM } from '../DOM';\r\nimport { EVT } from '../EVT';\r\nclass ToGIF {\r\n    constructor() {\r\n        this.gifWorkerUrl = '';\r\n        this.loadWorkerJS();\r\n    }\r\n    async loadWorkerJS() {\r\n        // 添加 gif 的 worker 文件\r\n        let gifWorker = await fetch(chrome.extension.getURL('lib/gif.worker.js'));\r\n        const gifWorkerBolb = await gifWorker.blob();\r\n        this.gifWorkerUrl = URL.createObjectURL(gifWorkerBolb);\r\n    }\r\n    // 转换成 GIF\r\n    async convert(file, info) {\r\n        return new Promise(async (resolve, reject) => {\r\n            // 配置 gif.js\r\n            let gif = new GIF({\r\n                workers: 4,\r\n                quality: 10,\r\n                workerScript: this.gifWorkerUrl,\r\n            });\r\n            // 绑定渲染完成事件\r\n            gif.on('finished', (file) => {\r\n                EVT.fire(EVT.list.convertSuccess);\r\n                resolve(file);\r\n            });\r\n            // 获取解压后的图片数据\r\n            let base64Arr = await extractImage\r\n                .extractImageAsDataURL(file, info)\r\n                .catch(() => {\r\n                reject(new Error('Start error'));\r\n            });\r\n            if (!base64Arr) {\r\n                return;\r\n            }\r\n            // 生成每一帧的数据\r\n            let imgList = await this.getFrameData(base64Arr);\r\n            // 添加帧数据\r\n            for (let index = 0; index < imgList.length; index++) {\r\n                gif.addFrame(imgList[index], {\r\n                    delay: info.frames[index].delay,\r\n                });\r\n            }\r\n            base64Arr = null;\r\n            imgList = null;\r\n            // 渲染 gif\r\n            gif.render();\r\n        });\r\n    }\r\n    // 添加每一帧的数据\r\n    async getFrameData(imgFile) {\r\n        const resultList = [];\r\n        return new Promise(async (resolve, reject) => {\r\n            for (const base64 of imgFile) {\r\n                const img = await DOM.loadImg(base64);\r\n                resultList.push(img);\r\n            }\r\n            resolve(resultList);\r\n        });\r\n    }\r\n}\r\nconst toGIF = new ToGIF();\r\nexport { toGIF };\r\n","import { extractImage } from './ExtractImage';\r\nimport { DOM } from '../DOM';\r\nimport { EVT } from '../EVT';\r\nclass ToWebM {\r\n    async convert(file, info) {\r\n        return new Promise(async (resolve, reject) => {\r\n            // 创建视频编码器\r\n            const encoder = new Whammy.Video();\r\n            // 获取解压后的图片数据\r\n            let base64Arr = await extractImage\r\n                .extractImageAsDataURL(file, info)\r\n                .catch(() => {\r\n                reject(new Error('Start error'));\r\n            });\r\n            if (!base64Arr) {\r\n                return;\r\n            }\r\n            // 生成每一帧的数据\r\n            let canvasList = await this.getFrameData(base64Arr);\r\n            // 添加帧数据\r\n            for (let index = 0; index < canvasList.length; index++) {\r\n                encoder.add(canvasList[index], info.frames[index].delay);\r\n            }\r\n            base64Arr = null;\r\n            canvasList = null;\r\n            // 获取生成的视频\r\n            file = await this.encodeVideo(encoder);\r\n            EVT.fire(EVT.list.convertSuccess);\r\n            resolve(file);\r\n        });\r\n    }\r\n    // 获取每一帧的数据，传递给编码器使用\r\n    async getFrameData(imgFile) {\r\n        const resultList = [];\r\n        return new Promise(async (resolve, reject) => {\r\n            for (const base64 of imgFile) {\r\n                const img = await DOM.loadImg(base64);\r\n                const canvas = document.createElement('canvas');\r\n                const ctx = canvas.getContext('2d');\r\n                canvas.width = img.width;\r\n                canvas.height = img.height;\r\n                ctx.drawImage(img, 0, 0);\r\n                resultList.push(canvas);\r\n            }\r\n            resolve(resultList);\r\n        });\r\n    }\r\n    // 编码视频\r\n    async encodeVideo(encoder) {\r\n        return new Promise(function (resolve, reject) {\r\n            encoder.compile(false, function (video) {\r\n                resolve(video);\r\n            });\r\n        });\r\n    }\r\n}\r\nconst toWebM = new ToWebM();\r\nexport { toWebM };\r\n"],"sourceRoot":""}